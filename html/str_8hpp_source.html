<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>307Lib: X:/_Workspace/_repo/cpp-307lib/str-lib/include/str.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gear-2.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">307Lib
   </div>
   <div id="projectbrief">C++ Libraries made by radj307</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('str_8hpp_source.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">str.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="str_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> * @file    str.hpp</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> * @author  radj307</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> * @brief   Includes all of the str namespace extension headers, and additional functions related to string manipulation &amp; conversions.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">pragma</span> <span class="preprocessor">once</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">strconv</span><span class="preprocessor">.</span><span class="preprocessor">hpp</span><span class="preprocessor">&gt;</span>          <span class="comment">// str library component that includes string conversion functions.</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">strmanip</span><span class="preprocessor">.</span><span class="preprocessor">hpp</span><span class="preprocessor">&gt;</span>         <span class="comment">// str library component that includes string manipulation functions.</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">strlocale</span><span class="preprocessor">.</span><span class="preprocessor">hpp</span><span class="preprocessor">&gt;</span>        <span class="comment">// str library component that includes &lt;locale&gt;-based string functions.</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">var</span><span class="preprocessor">.</span><span class="preprocessor">hpp</span><span class="preprocessor">&gt;</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">iomanip</span><span class="preprocessor">&gt;</span>              <span class="comment">// for std::setw &amp; other std::iostream manipulation functions.</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160; </div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; <span class="comment">/// Define DISABLE_STR_LITERALS to disable adding std::string_literals to the global namespace.</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> * @def     DISABLE_STR_LITERALS</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> * @brief   Disables the &quot;using namespace std::string_literals;&quot; from being declared in the global namespace.</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">ifndef</span> <span class="preprocessor">DISABLE_STR_LITERALS</span></div>
<div class="line"><a name="l00020"></a><span class="lineno"><a class="line" href="str_8hpp.html#a65bc2f112d723a2d6e8492077a63318c">   20</a></span>&#160;<span class="preprocessor">#</span><span class="preprocessor">define</span> <span class="preprocessor">DISABLE_STR_LITERALS</span> <span class="comment">// for doxygen to see the definition</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">undef</span> <span class="preprocessor">DISABLE_STR_LITERALS</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">endif</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> * @brief   Check if a given character is a valid hexadecimal digit. Valid: ( 0-9 | a-f | A-F )</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> * @param c Input Character</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> * @returns int</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"> *          0   Character is not a valid hexadecimal digit.</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment"> *          1   Character is a valid hexadecimal digit.</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00032"></a><span class="lineno"><a class="line" href="str_8hpp.html#a9dea0e9b46c42a30922ce893c17d88a8">   32</a></span>&#160;<span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="str_8hpp.html#a9dea0e9b46c42a30922ce893c17d88a8">ishexnum</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; c)</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">return</span> (c &gt;= <span class="stringliteral">&#39;0&#39;</span> &amp;&amp; c &lt;= <span class="stringliteral">&#39;9&#39;</span>)           <span class="comment">// digit</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        || (c &gt;= <span class="stringliteral">&#39;a&#39;</span> &amp;&amp; c &lt;= <span class="stringliteral">&#39;f&#39;</span>)   <span class="comment">// a-f</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        || (c &gt;= <span class="stringliteral">&#39;A&#39;</span> &amp;&amp; c &lt;= <span class="stringliteral">&#39;F&#39;</span>);  <span class="comment">// A-F</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;}</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment"> * @brief Test that checks if a given char is a quotation mark. (Accepts single or double quotes.)</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment"> * @param c - Input char</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment"> * @returns bool</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00043"></a><span class="lineno"><a class="line" href="str_8hpp.html#aa415d1d4d4888d8486edf353a9405d9f">   43</a></span>&#160;<span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a class="code" href="str_8hpp.html#aa415d1d4d4888d8486edf353a9405d9f">isquote</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> c)</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;{</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">switch</span> (c) {</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keywordflow">case</span> <span class="stringliteral">&#39;\&quot;&#39;</span>: [[fallthrough]];</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">case</span> <span class="stringliteral">&#39;\&#39;&#39;</span>:</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    }</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;}</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160; </div>
<div class="line"><a name="l00054"></a><span class="lineno"><a class="line" href="namespacestr.html">   54</a></span>&#160;<span class="keyword">namespace</span> <a class="code" href="namespacestr.html">str</a> {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">     *  disable &quot;use of a moved from object &#39;buffer&#39;&quot;, speed comparison testing shows a major performance</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">     *  increase when using return-move() for these functions. (~300000ns)</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">pragma</span> <span class="preprocessor">warning</span> <span class="preprocessor">(</span><span class="preprocessor">disable</span><span class="preprocessor">:</span> 26800<span class="preprocessor">)</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;     <span class="comment">/**</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">      * @brief Creates a stringstream, inserts all of the given arguments, then move-returns the resulting stringstream.</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">      * @tparam ...VT   - Variadic Templated Arguments.</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">      * @param ...args  - Arguments to insert into the stream, in order.</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">      * @returns std::stringstream</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">      */</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keyword">template</span>&lt;<a class="code" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">var</a>::<a class="code" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">Streamable</a>... <a class="code" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">VT</a>&gt;</div>
<div class="line"><a name="l00067"></a><span class="lineno"><a class="line" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">   67</a></span>&#160;    [[<a class="code" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">nodiscard</a>]] <span class="keyword">static</span> <a class="code" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">std</a>::<a class="code" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">stringstream</a> <a class="code" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">streamify</a>(<a class="code" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">VT</a>... <a class="code" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">args</a>)</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    {</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">stringstream</a> <a class="code" href="namespacestr.html">buffer</a>;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        (<a class="code" href="namespacestr.html">buffer</a> &lt;&lt; ... &lt;&lt; <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">move</a>(<a class="code" href="namespacestr.html">args</a>));</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">move</a>(<a class="code" href="namespacestr.html">buffer</a>);</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    }</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160; </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment">     * @brief Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the stringstream&#39;s str() function.</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">     * @tparam ...VT    - Variadic Templated Arguments.</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">     * @param ...args   - Arguments to insert into the stream, in order. Nearly anything can be included here, so long as it has an operator&lt;&lt; stream insertion operator.</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment">     * @returns std::string</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keyword">template</span>&lt;var::Streamable... VT&gt;</div>
<div class="line"><a name="l00081"></a><span class="lineno"><a class="line" href="namespacestr.html#a670a97b2121a31298814cb8e4a5d13ff">   81</a></span>&#160;    [[<a class="code" href="namespacestr.html#a670a97b2121a31298814cb8e4a5d13ff">nodiscard</a>]] <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> std::string <a class="code" href="namespacestr.html#a670a97b2121a31298814cb8e4a5d13ff">stringify</a>(<span class="keyword">const</span> VT&amp;... args)</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (var::none&lt;VT...&gt;)</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keywordflow">return</span>{};</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        std::stringstream buffer;   <span class="comment">// init stringstream</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        (buffer &lt;&lt; ... &lt;&lt; args);    <span class="comment">// insert variadic arguments in order</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="keywordflow">return</span> std::move(buffer.str());     <span class="comment">// return as string</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160; </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">     * @brief stringify() variant that accepts a vector of elements instead of variadic arguments.</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">     * @tparam ContainerT   - Container Type. Accepts most STL containers that hold a single type, such as: std::vector, std::set, etc.</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">     * @tparam ElemT        - Templated Element Type. Must be compatible with ostream::operator&lt;&lt;.</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">     * @tparam ...VT        - Variadic Templated Separators. These are inserted in order between every element in the container.</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">     * @param container     - Input Container. Element type must have an overload for operator&lt;&lt; to allow insertion into an ostream.</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment">     * @param ...separators - Any number of separators. These are inserted in order between every element. This can be used to apply formatting, insert spaces, or anything else. Note that separators are only inserted BETWEEN elements, and will never be trailing!</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment">     * @returns std::string</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>, <span class="keyword">class</span>&gt; <span class="keyword">class</span> ContainerT, <span class="keyword">class</span> ElemT, var::Streamable... VT&gt; requires std::convertible_to&lt;<a class="code" href="namespacestr.html">ElemT</a>, <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">string</a>&gt;</div>
<div class="line"><a name="l00100"></a><span class="lineno"><a class="line" href="namespacestr.html#a76cdfa929c2dbd674745f23f30f4f9f4">  100</a></span>&#160;    [[<a class="code" href="namespacestr.html">nodiscard</a>]] <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">string</a> <a class="code" href="namespacestr.html">stringify_container</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html">ContainerT</a>&lt;<a class="code" href="namespacestr.html">ElemT</a>, <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">allocator</a>&lt;<a class="code" href="namespacestr.html">ElemT</a>&gt;&gt;&amp; <a class="code" href="namespacestr.html">container</a>, <a class="code" href="namespacestr.html">VT</a>... <a class="code" href="namespacestr.html">separators</a>)</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">stringstream</a> <a class="code" href="namespacestr.html">buffer</a>;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code" href="namespacestr.html">element</a>{ <a class="code" href="namespacestr.html">container</a>.<a class="code" href="namespacestr.html">begin</a>() }; <a class="code" href="namespacestr.html">element</a> != <a class="code" href="namespacestr.html">container</a>.<a class="code" href="namespacestr.html">end</a>(); ++<a class="code" href="namespacestr.html">element</a>) {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacestr.html">element</a> != <a class="code" href="namespacestr.html">container</a>.<a class="code" href="namespacestr.html">begin</a>())</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                (<a class="code" href="namespacestr.html">buffer</a> &lt;&lt; ... &lt;&lt; <a class="code" href="namespacestr.html">separators</a>);</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            <a class="code" href="namespacestr.html">buffer</a> &lt;&lt; <span class="keyword">static_cast</span>&lt;<a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">string</a>&gt;(*<a class="code" href="namespacestr.html">element</a>);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        }</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">move</a>(<a class="code" href="namespacestr.html">buffer</a>.<a class="code" href="namespacestr.html">str</a>());</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    }</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160; </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">     * @brief Creates a temporary stringstream and inserts all of the given arguments in sequential order, then uses the given delimiter to split the resulting string into a vector of strings.</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">     * @tparam DelimType    - Input Delimiter Type</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment">     * @tparam ...VT        - Variadic Templated Arguments.</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">     * @param delimiter     - Delimiter to use when splitting the result.</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">     * @param ...args       - Arguments to insert into the stream in sequential order.</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">     * @returns std::vector&lt;std::string&gt;</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span> DelimType, var::Streamable... VT&gt;</div>
<div class="line"><a name="l00120"></a><span class="lineno"><a class="line" href="namespacestr.html#ae44a61b1fed1e226ac26abe03d69adab">  120</a></span>&#160;    [[<a class="code" href="namespacestr.html#ae44a61b1fed1e226ac26abe03d69adab">nodiscard</a>]] <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> std::vector&lt;std::string&gt; <a class="code" href="namespacestr.html#ae44a61b1fed1e226ac26abe03d69adab">stringify_split</a>(<span class="keyword">const</span> DelimType&amp; delimiter, VT... args)</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    {</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        std::stringstream buffer;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        (buffer &lt;&lt; ... &lt;&lt; args) &lt;&lt; delimiter;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        std::vector&lt;std::string&gt; vec;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        vec.reserve(std::count(buffer.beg(), buffer.end(), delimiter));</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">for</span> (std::string sub{}; <a class="code" href="namespacestr.html">str</a>::getline(buffer, sub, delimiter); vec.emplace_back(sub)) {}</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        vec.shrink_to_fit();</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keywordflow">return</span> std::move(vec);</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160; </div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="keyword">template</span>&lt;var::valid_string T, var::valid_string... vT&gt;</div>
<div class="line"><a name="l00132"></a><span class="lineno"><a class="line" href="namespacestr.html#a802a7f5eadf01d0ec26752bd6e6499c4">  132</a></span>&#160;    <span class="keyword">static</span> <a class="code" href="namespacestr.html#a802a7f5eadf01d0ec26752bd6e6499c4">T</a> <a class="code" href="namespacestr.html#a802a7f5eadf01d0ec26752bd6e6499c4">longest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a802a7f5eadf01d0ec26752bd6e6499c4">T</a>&amp; <a class="code" href="namespacestr.html#a802a7f5eadf01d0ec26752bd6e6499c4">fst</a>, <span class="keyword">const</span> <a class="code" href="namespacestr.html#a802a7f5eadf01d0ec26752bd6e6499c4">vT</a>&amp;... <a class="code" href="namespacestr.html#a802a7f5eadf01d0ec26752bd6e6499c4">strings</a>)</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    {</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespacestr.html">longer</a>{ [](<span class="keyword">const</span> <a class="code" href="namespacestr.html">T</a>&amp; <a class="code" href="namespacestr.html">str</a>, <span class="keyword">const</span> <a class="code" href="namespacestr.html">T</a>&amp; <a class="code" href="namespacestr.html">longest</a>) {</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacestr.html">str</a>.<a class="code" href="namespacestr.html">size</a>() &gt; <a class="code" href="namespacestr.html">longest</a>.<a class="code" href="namespacestr.html">size</a>() ? <a class="code" href="namespacestr.html">str</a> : <a class="code" href="namespacestr.html">longest</a>;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        } };</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacestr.html">longer</a>(<a class="code" href="namespacestr.html">fst</a>, <a class="code" href="namespacestr.html">longer</a>(<a class="code" href="namespacestr.html">strings</a>, <span class="stringliteral">&quot;&quot;s</span>));</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    }</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="keyword">template</span>&lt;var::valid_string T, var::valid_string... vT&gt;</div>
<div class="line"><a name="l00140"></a><span class="lineno"><a class="line" href="namespacestr.html#aa2856fdd3500f6da597f8f52124f4d3a">  140</a></span>&#160;    <span class="keyword">static</span> <a class="code" href="namespacestr.html#aa2856fdd3500f6da597f8f52124f4d3a">T</a> <a class="code" href="namespacestr.html#aa2856fdd3500f6da597f8f52124f4d3a">shortest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#aa2856fdd3500f6da597f8f52124f4d3a">T</a>&amp; <a class="code" href="namespacestr.html#aa2856fdd3500f6da597f8f52124f4d3a">fst</a>, <span class="keyword">const</span> <a class="code" href="namespacestr.html#aa2856fdd3500f6da597f8f52124f4d3a">vT</a>&amp;... <a class="code" href="namespacestr.html#aa2856fdd3500f6da597f8f52124f4d3a">strings</a>)</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespacestr.html">shorter</a>{ [](<span class="keyword">const</span> <a class="code" href="namespacestr.html">T</a>&amp; <a class="code" href="namespacestr.html">str</a>, <span class="keyword">const</span> <a class="code" href="namespacestr.html">T</a>&amp; <a class="code" href="namespacestr.html">longest</a>) {</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacestr.html">str</a>.<a class="code" href="namespacestr.html">size</a>() &lt; <a class="code" href="namespacestr.html">longest</a>.<a class="code" href="namespacestr.html">size</a>() ? <a class="code" href="namespacestr.html">str</a> : <a class="code" href="namespacestr.html">longest</a>;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        } };</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacestr.html">shorter</a>(<a class="code" href="namespacestr.html">fst</a>, <a class="code" href="namespacestr.html">shorter</a>(<a class="code" href="namespacestr.html">strings</a>, <span class="stringliteral">&quot;&quot;s</span>));</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    }</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160; </div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="keyword">template</span>&lt;var::valid_string T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>, <span class="keyword">class</span>&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00149"></a><span class="lineno"><a class="line" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">  149</a></span>&#160;    <span class="keyword">static</span> Cont&lt;T, std::allocator&lt;T&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">longest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">Cont</a>&lt;<a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">T</a>, <a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">std</a>::<a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">allocator</a>&lt;<a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">T</a>&gt;&gt;&amp; <a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">strings</a>)</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    {</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keyword">auto</span> longest{ strings.end() };</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> str{ strings.begin() }; str != strings.end(); ++str)</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            <span class="keywordflow">if</span> (longest == strings.end() || str-&gt;size() &gt; longest-&gt;size())</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                longest = str;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        <span class="keywordflow">return</span> longest;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    }</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="keyword">template</span>&lt;var::valid_string T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>, <span class="keyword">class</span>&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00158"></a><span class="lineno"><a class="line" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">  158</a></span>&#160;    <span class="keyword">static</span> Cont&lt;T, std::allocator&lt;T&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">shortest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">Cont</a>&lt;<a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">T</a>, <a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">std</a>::<a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">allocator</a>&lt;<a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">T</a>&gt;&gt;&amp; <a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">strings</a>)</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keyword">auto</span> shortest{ strings.end() };</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> str{ strings.begin() }; str != strings.end(); ++str)</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keywordflow">if</span> (shortest == strings.end() || str-&gt;size() &lt; shortest-&gt;size())</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                shortest = str;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keywordflow">return</span> shortest;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    }</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160; </div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> index, var::valid_string T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00168"></a><span class="lineno"><a class="line" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">  168</a></span>&#160;    <span class="keyword">static</span> Cont&lt;std::pair&lt;T, T&gt;, std::allocator&lt;std::pair&lt;T, T&gt;&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">longest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">Cont</a>&lt;<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">std</a>::<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">pair</a>&lt;<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">T</a>, <a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">T</a>&gt;, <a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">std</a>::<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">allocator</a>&lt;<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">std</a>::<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">pair</a>&lt;<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">T</a>, <a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">T</a>&gt;&gt;&gt;&amp; <a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">strings</a>)</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <span class="keyword">auto</span> longest{ strings.end() };</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> strpr{ strings.begin() }; strpr != strings.end(); ++strpr)</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keywordflow">if</span> (longest == strings.end() || (!index ? strpr-&gt;first.size() : strpr-&gt;second.size()) &gt; (!index ? longest-&gt;first.size() : longest-&gt;second.size()))</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                longest = strpr;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="keywordflow">return</span> longest;</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    }</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> index, var::valid_string T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00177"></a><span class="lineno"><a class="line" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">  177</a></span>&#160;    <span class="keyword">static</span> Cont&lt;std::pair&lt;T, T&gt;, std::allocator&lt;std::pair&lt;T, T&gt;&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">shortest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">Cont</a>&lt;<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">std</a>::<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">pair</a>&lt;<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">T</a>, <a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">T</a>&gt;, <a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">std</a>::<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">allocator</a>&lt;<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">std</a>::<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">pair</a>&lt;<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">T</a>, <a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">T</a>&gt;&gt;&gt;&amp; <a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">strings</a>)</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    {</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        <span class="keyword">auto</span> shortest{ strings.end() };</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> strpr{ strings.begin() }; strpr != strings.end(); ++strpr)</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="keywordflow">if</span> (shortest == strings.end() || (!index ? strpr-&gt;first.size() : strpr-&gt;second.size()) &lt; (!index ? shortest-&gt;first.size() : shortest-&gt;second.size()))</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                shortest = strpr;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        <span class="keywordflow">return</span> shortest;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    }</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160; </div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment">     * @brief           Get the longest string in a container of string tuples.</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">     * @tparam index    Which index to call std::get on each time. Ex: 0 will compare the first string in each tuple.</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">     * @tparam ...vT    Variadic type contained by the tuple.</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">     * @tparam Cont     Container type containing std::tuples.</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">     * @param strings   Container</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">     * @returns         Cont::const_iterator</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="keyword">template</span>&lt;size_t index, var::valid_string... vT, <span class="keyword">template</span>&lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00195"></a><span class="lineno"><a class="line" href="namespacestr.html#a5b023e1ea9bf3de8039119fc7b30f136">  195</a></span>&#160;    <span class="keyword">static</span> Cont&lt;std::tuple&lt;vT...&gt;, std::allocator&lt;std::tuple&lt;vT...&gt;&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">longest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">Cont</a>&lt;<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">std</a>::<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">tuple</a>&lt;<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">vT</a>...&gt;, <a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">std</a>::<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">allocator</a>&lt;<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">std</a>::<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">tuple</a>&lt;<a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">vT</a>...&gt;&gt;&gt;&amp; <a class="code" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">strings</a>)</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    {</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="keyword">static_assert</span>(index &lt; <span class="keyword">sizeof</span>...(vT), <span class="stringliteral">&quot;str::longest()\tCannot specify out-of-bounds index!&quot;</span>);</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keyword">auto</span> longest{ strings.end() };</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> strtpl{ strings.begin() }; strtpl != strings.end(); ++strtpl)</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            <span class="keywordflow">if</span> (longest == strings.end() || std::get&lt;index&gt;(*strtpl).size() &gt; std::get&lt;index&gt;(*longest).size())</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                longest = strtpl;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">return</span> longest;</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    }</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">     * @brief           Get the shortest string in a container of string tuples.</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment">     * @tparam index    Which index to call std::get on each time. Ex: 0 will compare the first string in each tuple.</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment">     * @tparam ...vT    Variadic type contained by the tuple.</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment">     * @tparam Cont     Container type containing std::tuples.</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">     * @param strings   Container</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">     * @returns         Cont::const_iterator</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="keyword">template</span>&lt;size_t index, var::valid_string... vT, <span class="keyword">template</span>&lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00213"></a><span class="lineno"><a class="line" href="namespacestr.html#a23139dad6dcb1f62b17d1ba483195dd7">  213</a></span>&#160;    <span class="keyword">static</span> Cont&lt;std::tuple&lt;vT...&gt;, std::allocator&lt;std::tuple&lt;vT...&gt;&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">shortest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">Cont</a>&lt;<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">std</a>::<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">tuple</a>&lt;<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">vT</a>...&gt;, <a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">std</a>::<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">allocator</a>&lt;<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">std</a>::<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">tuple</a>&lt;<a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">vT</a>...&gt;&gt;&gt;&amp; <a class="code" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">strings</a>)</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    {</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keyword">static_assert</span>(index &lt; <span class="keyword">sizeof</span>...(vT), <span class="stringliteral">&quot;str::longest()\tCannot specify out-of-bounds index!&quot;</span>);</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <span class="keyword">auto</span> shortest{ strings.end() };</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> strtpl{ strings.begin() }; strtpl != strings.end(); ++strtpl)</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            <span class="keywordflow">if</span> (shortest == strings.end() || std::get&lt;index&gt;(*strtpl).size() &lt; std::get&lt;index&gt;(*shortest).size())</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                shortest = strtpl;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        <span class="keywordflow">return</span> shortest;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    }</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">pragma</span> <span class="preprocessor">warning</span> <span class="preprocessor">(</span><span class="preprocessor">default</span><span class="preprocessor">:</span> 26800<span class="preprocessor">)</span> <span class="comment">// re-enable moved-from-object warning</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160; </div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment">     * @brief Compare 2 strings.</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">     * @tparam T1               - Convertible to string type.</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">     * @tparam T2               - Convertible to string type.</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">     * @param left              - Comparison target 1</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">     * @param right             - Comparison target 2</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">     * @param case_sensitive    - When false, both strings are first converted to lowercase, then compared.</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment">     * @returns bool</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <a class="code" href="namespacestr.html">T1</a>, <span class="keyword">class</span> <a class="code" href="namespacestr.html">T2</a>&gt; <a class="code" href="namespacestr.html">requires</a> <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">convertible_to</a>&lt;<a class="code" href="namespacestr.html">T1</a>, <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">string</a>&gt;&amp;&amp; <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">convertible_to</a>&lt;<a class="code" href="namespacestr.html">T2</a>, <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">string</a>&gt;</div>
<div class="line"><a name="l00234"></a><span class="lineno"><a class="line" href="namespacestr.html#acd4ee543bc885f863faf20217f7142fe">  234</a></span>&#160;    <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="namespacestr.html">compare</a>(<a class="code" href="namespacestr.html">T1</a> <a class="code" href="namespacestr.html">left</a>, <a class="code" href="namespacestr.html">T2</a> <a class="code" href="namespacestr.html">right</a>, <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="namespacestr.html">case_sensitive</a> = <span class="keyword">true</span>)</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    {</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">string</a> <a class="code" href="namespacestr.html">l</a>{ <a class="code" href="namespacestr.html">case_sensitive</a> ? <a class="code" href="namespacestr.html">left</a> : <a class="code" href="namespacestr.html">tolower</a>(<a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">string</a>(<a class="code" href="namespacestr.html">left</a>)) }, <a class="code" href="namespacestr.html">r</a>{ <a class="code" href="namespacestr.html">case_sensitive</a> ? <a class="code" href="namespacestr.html">right</a> : <a class="code" href="namespacestr.html">tolower</a>(<a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">string</a>(<a class="code" href="namespacestr.html">right</a>)) };</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacestr.html">l</a> == <a class="code" href="namespacestr.html">r</a>;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    }</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160; </div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">pragma</span> <span class="preprocessor">region</span> <span class="preprocessor">concepts</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment">     * @concept ConvertibleStringT</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment">     * @brief Allows types that are constructor-convertible to std::string</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">     * @tparam T    - Input Type</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00246"></a><span class="lineno"><a class="line" href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">  246</a></span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span>... <a class="code" href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">T</a>&gt; <a class="code" href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">concept</a> <a class="code" href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">ConvertibleStringT</a> = <a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">constructible_from</a>&lt;<a class="code" href="namespacestr.html">std</a>::<a class="code" href="namespacestr.html">string</a>, <a class="code" href="namespacestr.html">T</a>...&gt;;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">pragma</span> <span class="preprocessor">endregion</span> <span class="preprocessor">concepts</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160; </div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">     * @struct Printable</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">     * @brief A generic wrapper for any number of any types. Allows functions to return an inline-printable value so the function can be used in an output stream operator&lt;&lt; statement.</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment">     * @tparam ...VT    - Variadic Templated Types.</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span>... VT&gt;</div>
<div class="line"><a name="l00255"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html">  255</a></span>&#160;    <span class="keyword">struct</span> <a class="code" href="structstr_1_1_printable.html">Printable</a> {</div>
<div class="line"><a name="l00256"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html#aa096ba2fe91640135686d959d48b9d58">  256</a></span>&#160;        <span class="keyword">const</span> std::string <a class="code" href="structstr_1_1_printable.html#aa096ba2fe91640135686d959d48b9d58">_div</a>;</div>
<div class="line"><a name="l00257"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html#a097f661e8c2bb195fc5cb0965076435c">  257</a></span>&#160;        <span class="keyword">const</span> std::tuple&lt;VT...&gt; <a class="code" href="structstr_1_1_printable.html#a097f661e8c2bb195fc5cb0965076435c">_values</a>;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        <span class="comment">/**</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment">         * @brief Default Constructor</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">         * @param divider   - This string will be inserted between each value, excluding before the first, and after the last, value.</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">         * @param ...values - Arguments to print out, in order.</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment">         */</span></div>
<div class="line"><a name="l00263"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html#a6018e952ad17342eca6ed9cdf0e4add8">  263</a></span>&#160;        <span class="keyword">constexpr</span> <a class="code" href="structstr_1_1_printable.html#a6018e952ad17342eca6ed9cdf0e4add8">Printable</a>(std::string divider, <span class="keyword">const</span> VT&amp;... values) : <a class="code" href="structstr_1_1_printable.html#aa096ba2fe91640135686d959d48b9d58">_div</a>{ std::move(divider) }, <a class="code" href="structstr_1_1_printable.html#a6018e952ad17342eca6ed9cdf0e4add8">_values</a>{ <a class="code" href="structstr_1_1_printable.html#a6018e952ad17342eca6ed9cdf0e4add8">std</a>::<a class="code" href="structstr_1_1_printable.html#a6018e952ad17342eca6ed9cdf0e4add8">move</a>(<a class="code" href="structstr_1_1_printable.html#a6018e952ad17342eca6ed9cdf0e4add8">values</a>) } {}</div>
<div class="line"><a name="l00264"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html#aae7c738de43acc54b691ec8ad1a7a45c">  264</a></span>&#160;        <span class="keyword">constexpr</span> <a class="code" href="structstr_1_1_printable.html#aae7c738de43acc54b691ec8ad1a7a45c">operator</a> <span class="keyword">const</span> std::tuple&lt;VT...&gt;() <span class="keyword">const</span> { <span class="keywordflow">return</span> <a class="code" href="structstr_1_1_printable.html#a097f661e8c2bb195fc5cb0965076435c">_values</a>; }</div>
<div class="line"><a name="l00265"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html#af46b7a404c4bc202c5a622f47b5d86b8">  265</a></span>&#160;        <span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> <a class="code" href="structstr_1_1_printable.html">Printable</a>&lt;VT...&gt;&amp; obj)</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            <span class="keyword">constexpr</span> <span class="keyword">const</span> <a class="code" href="structstr_1_1_printable.html">size_t</a> <a class="code" href="structstr_1_1_printable.html">sz</a>{ <span class="keyword">sizeof</span>...(<a class="code" href="structstr_1_1_printable.html">VT</a>) };</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="structstr_1_1_printable.html">size_t</a> <a class="code" href="structstr_1_1_printable.html">i</a>{ 0ull }; <a class="code" href="structstr_1_1_printable.html">i</a> &lt; <a class="code" href="structstr_1_1_printable.html">sz</a>; ++<a class="code" href="structstr_1_1_printable.html">i</a>) {</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                <a class="code" href="structstr_1_1_printable.html">os</a> &lt;&lt; <a class="code" href="structstr_1_1_printable.html">std</a>::<a class="code" href="structstr_1_1_printable.html">get</a>&lt;<a class="code" href="structstr_1_1_printable.html">i</a>&gt;(<a class="code" href="structstr_1_1_printable.html">obj</a>.<a class="code" href="structstr_1_1_printable.html">_values</a>);</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="structstr_1_1_printable.html">i</a> &lt; <a class="code" href="structstr_1_1_printable.html">sz</a> - 1ull)</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                    <a class="code" href="structstr_1_1_printable.html">os</a> &lt;&lt; <a class="code" href="structstr_1_1_printable.html">obj</a>.<a class="code" href="structstr_1_1_printable.html">_div</a>;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            }</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="structstr_1_1_printable.html">os</a>;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        }</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    };</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160; </div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">     * @brief std::string::find function that returns an optional instead of std::string::npos</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">     * @param str       - String to search within.</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">     * @param search    - Character(s) to search for.</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment">     * @returns std::optional&lt;size_t&gt;</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00283"></a><span class="lineno"><a class="line" href="namespacestr.html#a68189011dff0dc860136f8606606169c">  283</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">std</a>::<a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">optional</a>&lt;<a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">size_t</a>&gt; <a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">optional_find</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">std</a>::<a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">string</a>&amp; <a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">str</a>, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">search</a>)</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    {</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> pos{ str.find(std::forward&lt;<span class="keyword">decltype</span>(search)&gt;(search)) }; pos_valid(pos))</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            <span class="keywordflow">return</span> pos;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    }</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160; </div>
<div class="line"><a name="l00290"></a><span class="lineno"><a class="line" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">  290</a></span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... <a class="code" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">VT</a>&gt; <a class="code" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> (<span class="keyword">sizeof</span>...(<a class="code" href="namespacestr.html">VT</a>) &gt; 0)</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keyword">static</span> std::optional&lt;size_t&gt; optional_find(<span class="keyword">const</span> std::string&amp; str, VT&amp;&amp;... search)</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    {</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; s : var::variadic_accumulate&lt;std::string&gt;(std::string{ std::forward&lt;<span class="keyword">decltype</span>(search)&gt;(search) }...))</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> pos{ optional_find(str, s) }; pos.has_value())</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                <span class="keywordflow">return</span> pos;</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    }</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160; </div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="comment">     * @struct VariableIndentation</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="comment">     * @brief Uses the std::setw() function to create a variable amount of indentation in an output stream.</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00303"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html">  303</a></span>&#160;    <span class="keyword">struct</span> <a class="code" href="structstr_1_1_variable_indentation.html">VariableIndentation</a> {</div>
<div class="line"><a name="l00304"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">  304</a></span>&#160;        <span class="keyword">const</span> std::streamsize <a class="code" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">_max_width</a>, <a class="code" href="structstr_1_1_variable_indentation.html#afc60cbed1df803159396e0e3ea7e30a9">_sub_width</a>;</div>
<div class="line"><a name="l00305"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">  305</a></span>&#160;        <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">_fill</a>;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160; </div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        <span class="comment">/**</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment">         * @brief Default Constructor</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment">         * @param max_width         - This is the total amount of desired indentation, in characters.</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment">         * @param subtract_width    - This is the amount of width that has already been used, in characters. (To align multiple lines of varying length, this should be the length of the preceeding string, or 0 if there is no preceeding text.)</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment">         * @param fill_character    - Character to use as indent.</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment">         */</span></div>
<div class="line"><a name="l00313"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html#a0b7ed36241b97b1ff080384c0e1ba4d3">  313</a></span>&#160;        <span class="keyword">constexpr</span> <a class="code" href="structstr_1_1_variable_indentation.html#a0b7ed36241b97b1ff080384c0e1ba4d3">VariableIndentation</a>(std::streamsize max_width, std::streamsize subtract_width = 0, <span class="keywordtype">char</span> fill_character = <span class="stringliteral">&#39; &#39;</span>) : <a class="code" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">_max_width</a>{ std::move(max_width) }, <a class="code" href="structstr_1_1_variable_indentation.html#afc60cbed1df803159396e0e3ea7e30a9">_sub_width</a>{ std::move(subtract_width) }, <a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">_fill</a>{ std::move(fill_character) } {}</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160; </div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        <span class="comment">// Returns the actual amount of indentation</span></div>
<div class="line"><a name="l00316"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">  316</a></span>&#160;        <span class="keyword">constexpr</span> <a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">operator</a> std::streamsize() <span class="keyword">const</span> { <span class="keywordflow">return</span> <a class="code" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">_max_width</a> - <a class="code" href="structstr_1_1_variable_indentation.html#afc60cbed1df803159396e0e3ea7e30a9">_sub_width</a>; }</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160; </div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <span class="comment">// Insert the indentation into the given output stream</span></div>
<div class="line"><a name="l00319"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html#a4d20f3113d6afbb3ed312a762a1d2acd">  319</a></span>&#160;        <span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> <a class="code" href="structstr_1_1_variable_indentation.html">VariableIndentation</a>&amp; indent)</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        {</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            <span class="keywordflow">if</span> (indent<a class="code" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">.</a><a class="code" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">_max_width</a> == 0ull)</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;            <span class="keywordflow">return</span> os &lt;&lt; std::setfill(indent<a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">.</a><a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">_fill</a>) &lt;&lt; std::setw(indent<a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">.</a><a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">operator</a> std<a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">::</a>streamsize<a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">(</a><a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">)</a>) &lt;&lt; indent<a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">.</a><a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">_fill</a>;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        }</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    };</div>
<div class="line"><a name="l00326"></a><span class="lineno"><a class="line" href="namespacestr.html#a576148d382d024fc11d46dc0ef839cec">  326</a></span>&#160;    <span class="keyword">using</span> VIndent = <a class="code" href="structstr_1_1_variable_indentation.html">VariableIndentation</a>;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160; </div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">     * @brief               Split a string into a pair of strings by position. This is a simple wrapper to return a string split operation as a pair of strings.</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">     * @param str           Input String to Split.</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">     * @param pos           Position in the string to split.</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment">     * @param discard_pos   When true, the character at the given position is discarded, otherwise the character is the first character of the second return value.</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment">     * @returns             std::pair&lt;std::string, std::string&gt;</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00335"></a><span class="lineno"><a class="line" href="namespacestr.html#ab70976cba041bd3c2870814317b2cff4">  335</a></span>&#160;    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> std::pair&lt;std::string, std::string&gt; <a class="code" href="namespacestr.html#ab70976cba041bd3c2870814317b2cff4">split</a>(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">const</span> size_t&amp; pos, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; discard_pos = <span class="keyword">false</span>)</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    {</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keywordflow">return</span>{ str.substr(0ull, pos), str.substr(pos + !!discard_pos) };</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    }</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160; </div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment">     * @brief       Split a string into a pair of strings by finding the first occurrence of a given delimiter.</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment">     * @param str   Input String to Split.</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment">     * @param delim Delimiter to search for. The delimiter is discarded from the string.</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment">     * @returns     std::pair&lt;std::string, std::string&gt;</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00346"></a><span class="lineno"><a class="line" href="namespacestr.html#aea590984a3074c9eb9af7112dfc5a4ad">  346</a></span>&#160;    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> std::pair&lt;std::string, std::string&gt; <a class="code" href="namespacestr.html#aea590984a3074c9eb9af7112dfc5a4ad">split</a>(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">const</span> <span class="keywordtype">char</span>&amp; delim, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; occurrence = 0ull)</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    {</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        <span class="keywordtype">unsigned</span> matched{ 0u };</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        <span class="keywordflow">for</span> (size_t pos{ str.find(delim) }; <a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">pos_valid</a><a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">(</a>pos<a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">)</a>; pos = str.find(delim, pos + 1ull))</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            <span class="keywordflow">if</span> (occurrence == matched++)</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                <span class="keywordflow">return</span>{ str.substr(0ull, pos), str.substr(pos + 1ull) };</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        <span class="keywordflow">return</span>{ str, {} };</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    }</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160; </div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment">     * @brief       Split a string into a pair of strings by finding the first occurrence of a given delimiter.</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment">     * @param str   Input String to Split.</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment">     * @param delim Delimiter to search for. The delimiter is discarded from the string.</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment">     * @returns     std::pair&lt;std::string, std::string&gt;</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00361"></a><span class="lineno"><a class="line" href="namespacestr.html#a28b64545b20e75933729d6a9f6ccbdc0">  361</a></span>&#160;    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> std::pair&lt;std::string, std::string&gt; <a class="code" href="namespacestr.html#a28b64545b20e75933729d6a9f6ccbdc0">rsplit</a>(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">const</span> <span class="keywordtype">char</span>&amp; delim, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; occurrence = 0ull)</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    {</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        <span class="keywordtype">unsigned</span> matched{ 0u };</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keywordflow">for</span> (size_t pos{ str.rfind(delim) }; <a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">pos_valid</a><a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">(</a>pos<a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">)</a>; pos = str.rfind(delim, pos + 1ull))</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;            <span class="keywordflow">if</span> (occurrence == matched++)</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                <span class="keywordflow">return</span>{ str.substr(0ull, pos), str.substr(pos + 1ull) };</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        <span class="keywordflow">return</span>{ str, {} };</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    }</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160; </div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;};</div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_f49cb943032e4e6c5a25b1950233e477.html">str-lib</a></li><li class="navelem"><a class="el" href="dir_ffa891b75186ca993979c5c1cd9ce2c1.html">include</a></li><li class="navelem"><a class="el" href="str_8hpp.html">str.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
