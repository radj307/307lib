<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>307Lib: /home/runner/work/307lib/307lib/strlib/include/str.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gear-2.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">307Lib
   </div>
   <div id="projectbrief">C++ Libraries made by radj307</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('str_8hpp_source.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">str.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="str_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> * @file    str.hpp</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> * @author  radj307</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> * @brief   Includes all of the str namespace extension headers, and additional functions related to string manipulation &amp; conversions.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">pragma</span> <span class="preprocessor">once</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">strconv</span><span class="preprocessor">.</span><span class="preprocessor">hpp</span><span class="preprocessor">&gt;</span>          <span class="comment">// str library component that includes string conversion functions.</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">strmanip</span><span class="preprocessor">.</span><span class="preprocessor">hpp</span><span class="preprocessor">&gt;</span>         <span class="comment">// str library component that includes string manipulation functions.</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">strlocale</span><span class="preprocessor">.</span><span class="preprocessor">hpp</span><span class="preprocessor">&gt;</span>        <span class="comment">// str library component that includes &lt;locale&gt;-based string functions.</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">var</span><span class="preprocessor">.</span><span class="preprocessor">hpp</span><span class="preprocessor">&gt;</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">iomanip</span><span class="preprocessor">&gt;</span>              <span class="comment">// for std::setw &amp; other std::iostream manipulation functions.</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160; </div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; <span class="comment">/// Define DISABLE_STR_LITERALS to disable adding std::string_literals to the global namespace.</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> * @def     DISABLE_STR_LITERALS</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> * @brief   Disables the &quot;using namespace std::string_literals;&quot; from being declared in the global namespace.</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">ifndef</span> <span class="preprocessor">DISABLE_STR_LITERALS</span></div>
<div class="line"><a name="l00020"></a><span class="lineno"><a class="line" href="str_8hpp.html#a65bc2f112d723a2d6e8492077a63318c">   20</a></span>&#160;<span class="preprocessor">#</span><span class="preprocessor">define</span> <span class="preprocessor">DISABLE_STR_LITERALS</span> <span class="comment">// for doxygen to see the definition</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">undef</span> <span class="preprocessor">DISABLE_STR_LITERALS</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">endif</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> * @brief Test that checks if a given char is a quotation mark. (Accepts single or double quotes.)</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> * @param c - Input char</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> * @returns bool</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00030"></a><span class="lineno"><a class="line" href="str_8hpp.html#aa415d1d4d4888d8486edf353a9405d9f">   30</a></span>&#160;<span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a class="code" href="str_8hpp.html#aa415d1d4d4888d8486edf353a9405d9f">isquote</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> c)</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;{</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="keywordflow">switch</span> (c) {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">case</span> <span class="stringliteral">&#39;\&quot;&#39;</span>: [[fallthrough]];</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">case</span> <span class="stringliteral">&#39;\&#39;&#39;</span>:</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    }</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;}</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; </div>
<div class="line"><a name="l00041"></a><span class="lineno"><a class="line" href="namespacestr.html">   41</a></span>&#160;<span class="keyword">namespace</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str</a> {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">     *  disable &quot;use of a moved from object &#39;buffer&#39;&quot;, speed comparison testing shows a major performance</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment">     *  increase when using return-move() for these functions. (~300000ns)</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">pragma</span> <span class="preprocessor">warning</span> <span class="preprocessor">(</span><span class="preprocessor">disable</span><span class="preprocessor">:</span> 26800<span class="preprocessor">)</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;     <span class="comment">/**</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">      * @brief          Creates a stringstream, inserts all of the given arguments, then move-returns the resulting stringstream.</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">      * @tparam ...Ts   Variadic Templated Arguments.</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">      * @param ...args  Arguments to insert into the stream, in order.</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">      * @returns        std::stringstream</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">      */</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keyword">template</span>&lt;<a class="code" href="namespacestr.html#a18758598172725d265bdab25d48f5836">var</a>::<a class="code" href="namespacestr.html#a18758598172725d265bdab25d48f5836">Streamable</a>... <a class="code" href="namespacestr.html#a18758598172725d265bdab25d48f5836">Ts</a>&gt;</div>
<div class="line"><a name="l00054"></a><span class="lineno"><a class="line" href="namespacestr.html#a18758598172725d265bdab25d48f5836">   54</a></span>&#160;    [[<a class="code" href="namespacestr.html#a18758598172725d265bdab25d48f5836">nodiscard</a>]] <span class="keyword">static</span> <a class="code" href="namespacestr.html#a18758598172725d265bdab25d48f5836">std</a>::<a class="code" href="namespacestr.html#a18758598172725d265bdab25d48f5836">stringstream</a> <a class="code" href="namespacestr.html#a18758598172725d265bdab25d48f5836">streamify</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">Ts</a>&amp;&amp;... <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">args</a>)</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    {</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">stringstream</a> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">buffer</a>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        (<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">buffer</a> &lt;&lt; ... &lt;&lt; <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">forward</a>&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">Ts</a>&gt;(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">args</a>));</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">move</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">buffer</a>);</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    }</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">     * @brief Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the stringstream&#39;s str() function.</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">     * @tparam ...Ts    - Variadic Templated Arguments.</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">     * @param ...args   - Arguments to insert into the stream, in order. Nearly anything can be included here, so long as it has an operator&lt;&lt; stream insertion operator.</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">     * @returns std::string</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keyword">template</span>&lt;<a class="code" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">var</a>::<a class="code" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">Streamable</a>... <a class="code" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">Ts</a>&gt;</div>
<div class="line"><a name="l00068"></a><span class="lineno"><a class="line" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">   68</a></span>&#160;    [[<a class="code" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">nodiscard</a>]] <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">std</a>::<a class="code" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">string</a> <a class="code" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">stringify</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">Ts</a>&amp;&amp;... <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">args</a>)</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    {</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">var</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">none</a>&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">Ts</a>...&gt;)</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            <span class="keywordflow">return</span>{};</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">stringstream</a> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">buffer</a>;   <span class="comment">// init stringstream</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        (<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">buffer</a> &lt;&lt; ... &lt;&lt; <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">forward</a>&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">Ts</a>&gt;(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">args</a>));  <span class="comment">// insert variadic arguments in order</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">move</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">buffer</a>.<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str</a>());     <span class="comment">// return as string</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    }</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160; </div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment">     * @brief</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment">     * @tparam ContainerT   - Container Type. Accepts most STL containers that hold a single type, such as: std::vector, std::set, etc.</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment">     * @tparam ElemT        - Templated Element Type. Must be compatible with ostream::operator&lt;&lt;.</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment">     * @tparam ...VT        - Variadic Templated Separators. These are inserted in order between every element in the container.</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment">     * @param container     - Input Container. Element type must have an overload for operator&lt;&lt; to allow insertion into an ostream.</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment">     * @param ...separators - Any number of separators. These are inserted in order between every element. This can be used to apply formatting, insert spaces, or anything else. Note that separators are only inserted BETWEEN elements, and will never be trailing!</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">     * @returns std::string</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>, <span class="keyword">class</span>&gt; <span class="keyword">class</span> ContainerT, <span class="keyword">class</span> ElemT, var::Streamable... VT&gt; requires std::convertible_to&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">ElemT</a>, <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">string</a>&gt;</div>
<div class="line"><a name="l00087"></a><span class="lineno"><a class="line" href="namespacestr.html#acf8be91baa116c4582e66f6278db959f">   87</a></span>&#160;    [[<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">nodiscard</a>]] <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">string</a> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">join</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">ContainerT</a>&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">ElemT</a>, <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">allocator</a>&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">ElemT</a>&gt;&gt;&amp; <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">container</a>, <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">VT</a>... <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">separators</a>)</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    {</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">stringstream</a> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">buffer</a>;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">element</a>{ <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">container</a>.<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">begin</a>() }; <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">element</a> != <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">container</a>.<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">end</a>(); ++<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">element</a>) {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">element</a> != <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">container</a>.<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">begin</a>())</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                (<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">buffer</a> &lt;&lt; ... &lt;&lt; <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">separators</a>);</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">buffer</a> &lt;&lt; <span class="keyword">static_cast</span>&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">string</a>&gt;(*<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">element</a>);</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        }</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">move</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">buffer</a>.<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str</a>());</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    }</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160; </div>
<div class="line"><a name="l00098"></a><span class="lineno"><a class="line" href="namespacestr.html#a8a8c67ed7c199414fca456eef77b60e7">   98</a></span>&#160;    <span class="keyword">inline</span> <span class="keyword">static</span> size_t <a class="code" href="namespacestr.html#a8a8c67ed7c199414fca456eef77b60e7">count</a>(std::stringstream&amp; ss, <span class="keywordtype">char</span> delim)</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        size_t count{ 0ull };</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keywordflow">for</span> (std::string sbuf; std::getline(ss, sbuf, delim); ++count) {}</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="keywordflow">return</span> count;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    }</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160; </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment">     * @brief Creates a temporary stringstream and inserts all of the given arguments in sequential order, then uses the given delimiter to split the resulting string into a vector of strings.</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment">     * @tparam DelimType    - Input Delimiter Type</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment">     * @tparam ...VT        - Variadic Templated Arguments.</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">     * @param delimiter     - Delimiter to use when splitting the result.</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment">     * @param ...args       - Arguments to insert into the stream in sequential order.</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment">     * @returns std::vector&lt;std::string&gt;</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span> DelimType, var::Streamable... Ts&gt;</div>
<div class="line"><a name="l00114"></a><span class="lineno"><a class="line" href="namespacestr.html#a3d0e9313e9c0b862cfe77a3814139aa9">  114</a></span>&#160;    [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> std::vector&lt;std::string&gt; <a class="code" href="namespacestr.html#a3d0e9313e9c0b862cfe77a3814139aa9">stringify_split</a>(<span class="keyword">const</span> DelimType&amp; delimiter, Ts&amp;&amp;... args)</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    {</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        std::stringstream buffer;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        (buffer &lt;&lt; ... &lt;&lt; std::forward&lt;Ts&gt;(args)) &lt;&lt; delimiter;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        std::vector&lt;std::string&gt; vec;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        vec.reserve(count(buffer, delimiter));</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">for</span> (std::string sub{}; <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str</a>::getline(buffer, sub, delimiter); vec.emplace_back(sub)) {}</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        vec.shrink_to_fit();</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="keywordflow">return</span> std::move(vec);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    }</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160; </div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment">     * @brief Creates a temporary stringstream and inserts all of the given arguments in sequential order, then uses the given delimiter to split the resulting string into a vector of strings.</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">     * @tparam DelimType    - Input Delimiter Type</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">     * @tparam ...VT        - Variadic Templated Arguments.</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment">     * @param delimiter     - Delimiter to use when splitting the result.</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">     * @param ...args       - Arguments to insert into the stream in sequential order.</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment">     * @returns std::vector&lt;std::string&gt;</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span> DelimType, var::Streamable T&gt;</div>
<div class="line"><a name="l00134"></a><span class="lineno"><a class="line" href="namespacestr.html#a89e1ce424ded2930c3b83b41a06b0894">  134</a></span>&#160;    [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> std::vector&lt;std::string&gt; <a class="code" href="namespacestr.html#a89e1ce424ded2930c3b83b41a06b0894">stringify_split</a>(<span class="keyword">const</span> DelimType&amp; delimiter, <span class="keyword">const</span> std::vector&lt;T&gt;&amp; args)</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    {</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        std::stringstream buffer;</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        size_t count{ 0ull };</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it{ args.begin() }; it != args.end(); ++it, ++count) {</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            buffer &lt;&lt; *it;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            <span class="keywordflow">if</span> (std::distance(it, args.end()) &gt; 1)</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                buffer &lt;&lt; <span class="stringliteral">&#39; &#39;</span>;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        }</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        std::vector&lt;std::string&gt; vec;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        vec.reserve(count);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="keywordflow">for</span> (std::string sub{}; <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str</a>::getline(buffer, sub, delimiter); vec.emplace_back(sub)) {}</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        vec.shrink_to_fit();</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        <span class="keywordflow">return</span> std::move(vec);</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    }</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160; </div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keyword">template</span>&lt;var::valid_string_or_convertible T, <span class="keyword">class</span> Pred, var::valid_string_or_convertible... Ts&gt;</div>
<div class="line"><a name="l00151"></a><span class="lineno"><a class="line" href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">  151</a></span>&#160;    <span class="keyword">static</span> <a class="code" href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">T</a> <a class="code" href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">compare</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">Pred</a>&amp; <a class="code" href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">predicate</a>, <span class="keyword">const</span> <a class="code" href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">T</a>&amp; <a class="code" href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">fst</a>, <span class="keyword">const</span> <a class="code" href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">Ts</a>&amp;... <a class="code" href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">strings</a>)</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    {</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        std::unique_ptr&lt;T&gt; ptr{ <span class="keywordtype">nullptr</span> };</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; it : var::variadic_accumulate&lt;T&gt;(fst, strings...))</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            <span class="keywordflow">if</span> (ptr.get() == <span class="keywordtype">nullptr</span> || predicate(*ptr.get(), it))</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                ptr = std::make_unique&lt;T&gt;(it);</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">return</span> { ptr != <span class="keywordtype">nullptr</span> ? *ptr.get() : T{} };</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    }</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="keyword">template</span>&lt;var::valid_string_or_convertible T, var::valid_string_or_convertible... Ts&gt;</div>
<div class="line"><a name="l00160"></a><span class="lineno"><a class="line" href="namespacestr.html#a4e29c1c2f11c9fdba7e76bb2e3327c4b">  160</a></span>&#160;    <span class="keyword">static</span> <a class="code" href="namespacestr.html#a4e29c1c2f11c9fdba7e76bb2e3327c4b">T</a> <a class="code" href="namespacestr.html#a4e29c1c2f11c9fdba7e76bb2e3327c4b">longest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a4e29c1c2f11c9fdba7e76bb2e3327c4b">T</a>&amp; <a class="code" href="namespacestr.html#a4e29c1c2f11c9fdba7e76bb2e3327c4b">fst</a>, <span class="keyword">const</span> <a class="code" href="namespacestr.html#a4e29c1c2f11c9fdba7e76bb2e3327c4b">Ts</a>&amp;... <a class="code" href="namespacestr.html#a4e29c1c2f11c9fdba7e76bb2e3327c4b">strings</a>) { <span class="keywordflow">return</span> compare&lt;T&gt;([](<span class="keyword">const</span> T&amp; l, <span class="keyword">const</span> T&amp; r) { <span class="keywordflow">return</span> l.size() &lt; r.size(); }, fst, strings...); }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keyword">template</span>&lt;var::valid_string_or_convertible T, var::valid_string_or_convertible... Ts&gt;</div>
<div class="line"><a name="l00162"></a><span class="lineno"><a class="line" href="namespacestr.html#a87c41dd852c1db4ba8b8f1d28e4728b5">  162</a></span>&#160;    <span class="keyword">static</span> <a class="code" href="namespacestr.html#a87c41dd852c1db4ba8b8f1d28e4728b5">T</a> <a class="code" href="namespacestr.html#a87c41dd852c1db4ba8b8f1d28e4728b5">shortest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a87c41dd852c1db4ba8b8f1d28e4728b5">T</a>&amp; <a class="code" href="namespacestr.html#a87c41dd852c1db4ba8b8f1d28e4728b5">fst</a>, <span class="keyword">const</span> <a class="code" href="namespacestr.html#a87c41dd852c1db4ba8b8f1d28e4728b5">Ts</a>&amp;... <a class="code" href="namespacestr.html#a87c41dd852c1db4ba8b8f1d28e4728b5">strings</a>) { <span class="keywordflow">return</span> compare&lt;T&gt;([](<span class="keyword">const</span> T&amp; l, <span class="keyword">const</span> T&amp; r) { <span class="keywordflow">return</span> l.size() &gt; r.size(); }, fst, strings...); }</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160; </div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="keyword">template</span>&lt;var::valid_string T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>, <span class="keyword">class</span>&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00165"></a><span class="lineno"><a class="line" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">  165</a></span>&#160;    <span class="keyword">static</span> Cont&lt;T, std::allocator&lt;T&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">longest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">Cont</a>&lt;<a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">T</a>, <a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">std</a>::<a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">allocator</a>&lt;<a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">T</a>&gt;&gt;&amp; <a class="code" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">strings</a>)</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    {</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keyword">auto</span> longest{ strings.end() };</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> str{ strings.begin() }; str != strings.end(); ++str)</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            <span class="keywordflow">if</span> (longest == strings.end() || str-&gt;size() &gt; longest-&gt;size())</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                longest = str;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">return</span> longest;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    }</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    <span class="keyword">template</span>&lt;var::valid_string T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>, <span class="keyword">class</span>&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00174"></a><span class="lineno"><a class="line" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">  174</a></span>&#160;    <span class="keyword">static</span> Cont&lt;T, std::allocator&lt;T&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">shortest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">Cont</a>&lt;<a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">T</a>, <a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">std</a>::<a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">allocator</a>&lt;<a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">T</a>&gt;&gt;&amp; <a class="code" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">strings</a>)</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    {</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        <span class="keyword">auto</span> shortest{ strings.end() };</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> str{ strings.begin() }; str != strings.end(); ++str)</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            <span class="keywordflow">if</span> (shortest == strings.end() || str-&gt;size() &lt; shortest-&gt;size())</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                shortest = str;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordflow">return</span> shortest;</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    }</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160; </div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> index, var::valid_string T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00184"></a><span class="lineno"><a class="line" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">  184</a></span>&#160;    <span class="keyword">static</span> Cont&lt;std::pair&lt;T, T&gt;, std::allocator&lt;std::pair&lt;T, T&gt;&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">longest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">Cont</a>&lt;<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">std</a>::<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">pair</a>&lt;<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">T</a>, <a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">T</a>&gt;, <a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">std</a>::<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">allocator</a>&lt;<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">std</a>::<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">pair</a>&lt;<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">T</a>, <a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">T</a>&gt;&gt;&gt;&amp; <a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">strings</a>)</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    {</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="keyword">auto</span> longest{ strings.end() };</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> strpr{ strings.begin() }; strpr != strings.end(); ++strpr)</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            <span class="keywordflow">if</span> (longest == strings.end() || (!index ? strpr-&gt;first.size() : strpr-&gt;second.size()) &gt; (!index ? longest-&gt;first.size() : longest-&gt;second.size()))</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                longest = strpr;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="keywordflow">return</span> longest;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    }</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> index, var::valid_string T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00193"></a><span class="lineno"><a class="line" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">  193</a></span>&#160;    <span class="keyword">static</span> Cont&lt;std::pair&lt;T, T&gt;, std::allocator&lt;std::pair&lt;T, T&gt;&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">shortest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">Cont</a>&lt;<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">std</a>::<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">pair</a>&lt;<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">T</a>, <a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">T</a>&gt;, <a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">std</a>::<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">allocator</a>&lt;<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">std</a>::<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">pair</a>&lt;<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">T</a>, <a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">T</a>&gt;&gt;&gt;&amp; <a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">strings</a>)</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    {</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="keyword">auto</span> shortest{ strings.end() };</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> strpr{ strings.begin() }; strpr != strings.end(); ++strpr)</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            <span class="keywordflow">if</span> (shortest == strings.end() || (!index ? strpr-&gt;first.size() : strpr-&gt;second.size()) &lt; (!index ? shortest-&gt;first.size() : shortest-&gt;second.size()))</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                shortest = strpr;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">return</span> shortest;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    }</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160; </div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment">     * @brief           Get the longest string in a container of string tuples.</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment">     * @tparam index    Which index to call std::get on each time. Ex: 0 will compare the first string in each tuple.</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">     * @tparam ...vT    Variadic type contained by the tuple.</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment">     * @tparam Cont     Container type containing std::tuples.</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment">     * @param strings   Container</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment">     * @returns         Cont::const_iterator</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    <span class="keyword">template</span>&lt;size_t index, var::valid_string... Ts, <span class="keyword">template</span>&lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00211"></a><span class="lineno"><a class="line" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">  211</a></span>&#160;    <span class="keyword">static</span> Cont&lt;std::tuple&lt;Ts...&gt;, std::allocator&lt;std::tuple&lt;Ts...&gt;&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">longest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">Cont</a>&lt;<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">std</a>::<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">tuple</a>&lt;<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">Ts</a>...&gt;, <a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">std</a>::<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">allocator</a>&lt;<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">std</a>::<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">tuple</a>&lt;<a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">Ts</a>...&gt;&gt;&gt;&amp; <a class="code" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">strings</a>)</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <span class="keyword">static_assert</span>(index &lt; <span class="keyword">sizeof</span>...(Ts), <span class="stringliteral">&quot;str::longest()\tCannot specify out-of-bounds index!&quot;</span>);</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="keyword">auto</span> longest{ strings.end() };</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> strtpl{ strings.begin() }; strtpl != strings.end(); ++strtpl)</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            <span class="keywordflow">if</span> (longest == strings.end() || std::get&lt;index&gt;(*strtpl).size() &gt; std::get&lt;index&gt;(*longest).size())</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                longest = strtpl;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="keywordflow">return</span> longest;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">     * @brief           Get the shortest string in a container of string tuples.</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment">     * @tparam index    Which index to call std::get on each time. Ex: 0 will compare the first string in each tuple.</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment">     * @tparam ...vT    Variadic type contained by the tuple.</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment">     * @tparam Cont     Container type containing std::tuples.</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment">     * @param strings   Container</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">     * @returns         Cont::const_iterator</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <span class="keyword">template</span>&lt;size_t index, var::valid_string... Ts, <span class="keyword">template</span>&lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> Cont&gt;</div>
<div class="line"><a name="l00229"></a><span class="lineno"><a class="line" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">  229</a></span>&#160;    <span class="keyword">static</span> Cont&lt;std::tuple&lt;Ts...&gt;, std::allocator&lt;std::tuple&lt;Ts...&gt;&gt;&gt;::const_iterator <a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">shortest</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">Cont</a>&lt;<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">std</a>::<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">tuple</a>&lt;<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">Ts</a>...&gt;, <a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">std</a>::<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">allocator</a>&lt;<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">std</a>::<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">tuple</a>&lt;<a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">Ts</a>...&gt;&gt;&gt;&amp; <a class="code" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">strings</a>)</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    {</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <span class="keyword">static_assert</span>(index &lt; <span class="keyword">sizeof</span>...(Ts), <span class="stringliteral">&quot;str::longest()\tCannot specify out-of-bounds index!&quot;</span>);</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <span class="keyword">auto</span> shortest{ strings.end() };</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> strtpl{ strings.begin() }; strtpl != strings.end(); ++strtpl)</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            <span class="keywordflow">if</span> (shortest == strings.end() || std::get&lt;index&gt;(*strtpl).size() &lt; std::get&lt;index&gt;(*shortest).size())</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                shortest = strtpl;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="keywordflow">return</span> shortest;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    }</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">pragma</span> <span class="preprocessor">warning</span> <span class="preprocessor">(</span><span class="preprocessor">default</span><span class="preprocessor">:</span> 26800<span class="preprocessor">)</span> <span class="comment">// re-enable moved-from-object warning</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160; </div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment">     * @brief Compare 2 strings.</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment">     * @tparam T1               - Convertible to string type.</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment">     * @tparam T2               - Convertible to string type.</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">     * @param left              - Comparison target 1</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment">     * @param right             - Comparison target 2</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment">     * @param case_sensitive    - When false, both strings are first converted to lowercase, then compared.</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">     * @returns bool</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">T1</a>, <span class="keyword">class</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">T2</a>&gt; <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">requires</a> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">convertible_to</a>&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">T1</a>, <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">string</a>&gt;&amp;&amp; <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">convertible_to</a>&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">T2</a>, <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">string</a>&gt;</div>
<div class="line"><a name="l00250"></a><span class="lineno"><a class="line" href="namespacestr.html#acd4ee543bc885f863faf20217f7142fe">  250</a></span>&#160;    <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">compare</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">T1</a> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">left</a>, <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">T2</a> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">right</a>, <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">case_sensitive</a> = <span class="keyword">true</span>)</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    {</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">string</a> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">l</a>{ <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">case_sensitive</a> ? <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">left</a> : <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">tolower</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">string</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">left</a>)) }, <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">r</a>{ <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">case_sensitive</a> ? <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">right</a> : <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">tolower</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">string</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">right</a>)) };</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">l</a> == <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">r</a>;</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    }</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160; </div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">pragma</span> <span class="preprocessor">region</span> <span class="preprocessor">concepts</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment">     * @concept ConvertibleStringT</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment">     * @brief Allows types that are constructor-convertible to std::string</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">     * @tparam T    - Input Type</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00262"></a><span class="lineno"><a class="line" href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">  262</a></span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span>... <a class="code" href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">T</a>&gt; <a class="code" href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">concept</a> <a class="code" href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">ConvertibleStringT</a> = <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">constructible_from</a>&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">std</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">string</a>, <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">T</a>...&gt;;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">pragma</span> <span class="preprocessor">endregion</span> <span class="preprocessor">concepts</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160; </div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">     * @struct Printable</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">     * @brief A generic wrapper for any number of any types. Allows functions to return an inline-printable value so the function can be used in an output stream operator&lt;&lt; statement.</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">     * @tparam ...VT    - Variadic Templated Types.</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span>... VT&gt;</div>
<div class="line"><a name="l00271"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html">  271</a></span>&#160;    <span class="keyword">struct</span> <a class="code" href="structstr_1_1_printable.html">Printable</a> {</div>
<div class="line"><a name="l00272"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html#aa096ba2fe91640135686d959d48b9d58">  272</a></span>&#160;        <span class="keyword">const</span> std::string <a class="code" href="structstr_1_1_printable.html#aa096ba2fe91640135686d959d48b9d58">_div</a>;</div>
<div class="line"><a name="l00273"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html#a097f661e8c2bb195fc5cb0965076435c">  273</a></span>&#160;        <span class="keyword">const</span> std::tuple&lt;VT...&gt; <a class="code" href="structstr_1_1_printable.html#a097f661e8c2bb195fc5cb0965076435c">_values</a>;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        <span class="comment">/**</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">         * @brief Default Constructor</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment">         * @param divider   - This string will be inserted between each value, excluding before the first, and after the last, value.</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">         * @param ...values - Arguments to print out, in order.</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">         */</span></div>
<div class="line"><a name="l00279"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html#a6018e952ad17342eca6ed9cdf0e4add8">  279</a></span>&#160;        <span class="keyword">constexpr</span> <a class="code" href="structstr_1_1_printable.html#a6018e952ad17342eca6ed9cdf0e4add8">Printable</a>(std::string divider, <span class="keyword">const</span> VT&amp;... values) : <a class="code" href="structstr_1_1_printable.html#aa096ba2fe91640135686d959d48b9d58">_div</a>{ std::move(divider) }, <a class="code" href="structstr_1_1_printable.html#a097f661e8c2bb195fc5cb0965076435c">_values</a>{ values... } {}</div>
<div class="line"><a name="l00280"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html#aae7c738de43acc54b691ec8ad1a7a45c">  280</a></span>&#160;        <span class="keyword">constexpr</span> <a class="code" href="structstr_1_1_printable.html#aae7c738de43acc54b691ec8ad1a7a45c">operator</a> <span class="keyword">const</span> std::tuple&lt;VT...&gt;() <span class="keyword">const</span> { <span class="keywordflow">return</span> <a class="code" href="structstr_1_1_printable.html#a097f661e8c2bb195fc5cb0965076435c">_values</a>; }</div>
<div class="line"><a name="l00281"></a><span class="lineno"><a class="line" href="structstr_1_1_printable.html#af46b7a404c4bc202c5a622f47b5d86b8">  281</a></span>&#160;        <span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> <a class="code" href="structstr_1_1_printable.html">Printable</a>&lt;VT...&gt;&amp; obj)</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        {</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;            <span class="keyword">constexpr</span> <span class="keyword">const</span> size_t sz{ <span class="keyword">sizeof</span>...(VT) };</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            <span class="keywordflow">for</span> (size_t i{ 0ull }; i &lt; sz; ++i) {</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                os &lt;&lt; std::get&lt;i&gt;(obj._values);</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                <span class="keywordflow">if</span> (i &lt; sz - 1ull)</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                    os &lt;&lt; obj._div;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            }</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        }</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    };</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160; </div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment">     * @brief std::string::find function that returns an optional instead of std::string::npos</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment">     * @param str       - String to search within.</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment">     * @param search    - Character(s) to search for.</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment">     * @returns std::optional&lt;size_t&gt;</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00299"></a><span class="lineno"><a class="line" href="namespacestr.html#a68189011dff0dc860136f8606606169c">  299</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">std</a>::<a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">optional</a>&lt;<a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">size_t</a>&gt; <a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">optional_find</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">std</a>::<a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">string</a>&amp; <a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">str</a>, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="namespacestr.html#a68189011dff0dc860136f8606606169c">search</a>)</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    {</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> pos{ str.find(std::forward&lt;<span class="keyword">decltype</span>(search)&gt;(search)) }; pos_valid(pos))</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            <span class="keywordflow">return</span> pos;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    }</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160; </div>
<div class="line"><a name="l00306"></a><span class="lineno"><a class="line" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">  306</a></span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... <a class="code" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">VT</a>&gt; <a class="code" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> (<span class="keyword">sizeof</span>...(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">VT</a>) &gt; 0)</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        <span class="keyword">static</span> std::optional&lt;size_t&gt; optional_find(<span class="keyword">const</span> std::string&amp; str, VT&amp;&amp;... search)</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    {</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; s : var::variadic_accumulate&lt;std::string&gt;(std::string{ std::forward&lt;<span class="keyword">decltype</span>(search)&gt;(search) }...))</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> pos{ optional_find(str, s) }; pos.has_value())</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                <span class="keywordflow">return</span> pos;</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    }</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160; </div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment">     * @struct VariableIndentation</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment">     * @brief Uses the std::setw() function to create a variable amount of indentation in an output stream.</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00319"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html">  319</a></span>&#160;    <span class="keyword">struct</span> <a class="code" href="structstr_1_1_variable_indentation.html">VariableIndentation</a> {</div>
<div class="line"><a name="l00320"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html#afc60cbed1df803159396e0e3ea7e30a9">  320</a></span>&#160;        <span class="keyword">const</span> std::streamsize <a class="code" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">_max_width</a>, <a class="code" href="structstr_1_1_variable_indentation.html#afc60cbed1df803159396e0e3ea7e30a9">_sub_width</a>;</div>
<div class="line"><a name="l00321"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">  321</a></span>&#160;        <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">_fill</a>;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160; </div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        <span class="comment">/**</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment">         * @brief Default Constructor</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment">         * @param max_width         - This is the total amount of desired indentation, in characters.</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">         * @param subtract_width    - This is the amount of width that has already been used, in characters. (To align multiple lines of varying length, this should be the length of the preceeding string, or 0 if there is no preceeding text.)</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment">         * @param fill_character    - Character to use as indent.</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">         */</span></div>
<div class="line"><a name="l00329"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html#a0b7ed36241b97b1ff080384c0e1ba4d3">  329</a></span>&#160;        <span class="keyword">constexpr</span> <a class="code" href="structstr_1_1_variable_indentation.html#a0b7ed36241b97b1ff080384c0e1ba4d3">VariableIndentation</a>(std::streamsize max_width, std::streamsize subtract_width = 0, <span class="keywordtype">char</span> fill_character = <span class="stringliteral">&#39; &#39;</span>) : <a class="code" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">_max_width</a>{ std::move(max_width) }, <a class="code" href="structstr_1_1_variable_indentation.html#afc60cbed1df803159396e0e3ea7e30a9">_sub_width</a>{ std::move(subtract_width) }, <a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">_fill</a>{ std::move(fill_character) } {}</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160; </div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        <span class="comment">// Returns the actual amount of indentation</span></div>
<div class="line"><a name="l00332"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">  332</a></span>&#160;        <span class="keyword">constexpr</span> <a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">operator</a> std::streamsize() <span class="keyword">const</span> { <span class="keywordflow">return</span> <a class="code" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">_max_width</a> - <a class="code" href="structstr_1_1_variable_indentation.html#afc60cbed1df803159396e0e3ea7e30a9">_sub_width</a>; }</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160; </div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        <span class="comment">// Insert the indentation into the given output stream</span></div>
<div class="line"><a name="l00335"></a><span class="lineno"><a class="line" href="structstr_1_1_variable_indentation.html#a4d20f3113d6afbb3ed312a762a1d2acd">  335</a></span>&#160;        <span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> <a class="code" href="structstr_1_1_variable_indentation.html">VariableIndentation</a>&amp; indent)</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        {</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;            <span class="keywordflow">if</span> (indent<a class="code" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">.</a><a class="code" href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">_max_width</a> == 0ull)</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            <span class="keywordflow">return</span> os &lt;&lt; std::setfill(indent<a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">.</a><a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">_fill</a>) &lt;&lt; std::setw(indent<a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">.</a><a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">operator</a> std<a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">::</a>streamsize<a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">(</a><a class="code" href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">)</a>) &lt;&lt; indent<a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">.</a><a class="code" href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">_fill</a>;</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        }</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    };</div>
<div class="line"><a name="l00342"></a><span class="lineno"><a class="line" href="namespacestr.html#a576148d382d024fc11d46dc0ef839cec">  342</a></span>&#160;    <span class="keyword">using</span> VIndent = <a class="code" href="structstr_1_1_variable_indentation.html">VariableIndentation</a>;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160; </div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment">     * @brief               Split a string into a pair of strings by position. This is a simple wrapper to return a string split operation as a pair of strings.</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">     * @param str           Input String to Split.</span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment">     * @param pos           Position in the string to split.</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment">     * @param discard_pos   When true, the character at the given position is discarded, otherwise the character is the first character of the second return value.</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment">     * @returns             std::pair&lt;std::string, std::string&gt;</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00351"></a><span class="lineno"><a class="line" href="namespacestr.html#aba03dcb83941ed1d96f1ae269db82fc0">  351</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> <span class="keyword">const</span> std::pair&lt;std::string, std::string&gt; <a class="code" href="namespacestr.html#aba03dcb83941ed1d96f1ae269db82fc0">split</a>(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">const</span> size_t&amp; pos, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; discard_pos = <span class="keyword">false</span>)</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    {</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        <span class="keywordflow">return</span>{ str.substr(0ull, pos), str.substr(pos + !!discard_pos) };</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    }</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160; </div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment">     * @brief       Split a string into a pair of strings by finding the first occurrence of a given delimiter.</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment">     * @param str   Input String to Split.</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment">     * @param delim Delimiter to search for. The delimiter is discarded from the string.</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment">     * @returns     std::pair&lt;std::string, std::string&gt;</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00362"></a><span class="lineno"><a class="line" href="namespacestr.html#ab81d06e112031542961adc0b38bd0b2b">  362</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> <span class="keyword">const</span> std::pair&lt;std::string, std::string&gt; <a class="code" href="namespacestr.html#ab81d06e112031542961adc0b38bd0b2b">split</a>(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">const</span> <span class="keywordtype">char</span>&amp; delim, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; occurrence = 0ull)</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    {</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keywordtype">unsigned</span> matched{ 0u };</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        <span class="keywordflow">for</span> (size_t pos{ str.find(delim) }; <a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">pos_valid</a><a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">(</a>pos<a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">)</a>; pos = str.find(delim, pos + 1ull))</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;            <span class="keywordflow">if</span> (occurrence == matched++)</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                <span class="keywordflow">return</span>{ str.substr(0ull, pos), str.substr(pos + 1ull) };</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="keywordflow">return</span>{ str, {} };</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    }</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160; </div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="comment">     * @brief       Split a string into a pair of strings by finding the first occurrence of a given delimiter.</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="comment">     * @param str   Input String to Split.</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="comment">     * @param delim Delimiter to search for. The delimiter is discarded from the string.</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment">     * @returns     std::pair&lt;std::string, std::string&gt;</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00377"></a><span class="lineno"><a class="line" href="namespacestr.html#a69b4c7c470963c0be1a41227ccf6f86e">  377</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> <span class="keyword">const</span> std::pair&lt;std::string, std::string&gt; <a class="code" href="namespacestr.html#a69b4c7c470963c0be1a41227ccf6f86e">rsplit</a>(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">const</span> <span class="keywordtype">char</span>&amp; delim, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; occurrence = 0ull)</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    {</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keywordtype">unsigned</span> matched{ 0u };</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">for</span> (size_t pos{ str.rfind(delim) }; <a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">pos_valid</a><a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">(</a>pos<a class="code" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">)</a>; pos = str.rfind(delim, pos + 1ull))</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;            <span class="keywordflow">if</span> (occurrence == matched++)</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                <span class="keywordflow">return</span>{ str.substr(0ull, pos), str.substr(pos + 1ull) };</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        <span class="keywordflow">return</span>{ str, {} };</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    }</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160; </div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="comment">     * @brief               Remove trailing characters from a string.</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="comment">     * @tparam DelimT       Variadic Input Types.</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="comment">     * @param float_str     Input String.</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="comment">     * @param delims...     At least one character to remove from the end of the string. These are casted to char before comparing!</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="comment">     * @returns             std::string_view</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <span class="keyword">template</span>&lt;std::same_as&lt;<span class="keywordtype">char</span>&gt;... DelimT&gt;</div>
<div class="line"><a name="l00394"></a><span class="lineno"><a class="line" href="namespacestr.html#a45c1b11a2e282a4fc8d38548eaf45f3c">  394</a></span>&#160;    <span class="keyword">inline</span> <span class="keyword">static</span> std::string <a class="code" href="namespacestr.html#a45c1b11a2e282a4fc8d38548eaf45f3c">strip_trailing</a>(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">const</span> DelimT&amp;... delims)</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    {</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>...(DelimT) &gt; 0, <span class="stringliteral">&quot;strip_trailing() requires at least one delimiter char!&quot;</span>);</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        size_t i{ 0ull };</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> rit{ str.rbegin() }; rit != str.rend(); ++rit) {</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;            <span class="keywordflow">if</span> (var::variadic_or(*rit == <span class="keyword">static_cast</span>&lt;<span class="keywordtype">char</span>&gt;(delims)...))</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                ++i;</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        }</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        <span class="keywordflow">return</span> str.substr(0ull, str.size() - i);</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    }</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment">     * @brief               Remove preceeding characters from a string.</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment">     * @tparam DelimT       Variadic Input Types.</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment">     * @param float_str     Input String.</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">     * @param delims...     At least one character to remove from the beginning of the string. These are casted to char before comparing!</span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="comment">     * @returns             std::string_view</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keyword">template</span>&lt;std::same_as&lt;<span class="keywordtype">char</span>&gt;... DelimT&gt;</div>
<div class="line"><a name="l00413"></a><span class="lineno"><a class="line" href="namespacestr.html#a4a7fab88e397cd6251944c3d01a7438d">  413</a></span>&#160;    <span class="keyword">inline</span> <span class="keyword">static</span> std::string <a class="code" href="namespacestr.html#a4a7fab88e397cd6251944c3d01a7438d">strip_preceeding</a>(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">const</span> DelimT&amp;... delims)</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    {</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>...(DelimT) &gt; 0, <span class="stringliteral">&quot;strip_preceeding() requires at least one delimiter char!&quot;</span>);</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        size_t i{ 0ull };</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it{ str.begin() }; it != str.end(); ++it) {</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;            <span class="keywordflow">if</span> (var::variadic_or(*it == <span class="keyword">static_cast</span>&lt;<span class="keywordtype">char</span>&gt;(delims)...))</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                ++i;</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        }</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        <span class="keywordflow">return</span> str.substr(i);</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    }</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160; </div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="comment">     * @brief           Remove all specified characters from the given string.</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="comment">     * @param str       Input String</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment">     * @param delims    A string containing all of the blacklisted characters.</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="comment">     * @returns         std::string</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00431"></a><span class="lineno"><a class="line" href="namespacestr.html#acf63c00706c91be7da3f18b08a088224">  431</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> <span class="keyword">static</span> std::string <a class="code" href="namespacestr.html#acf63c00706c91be7da3f18b08a088224">strip</a>(std::string s, <span class="keyword">const</span> std::string_view&amp; delims)</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    {</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        <span class="keywordflow">if</span> (!s.empty() &amp;&amp; !delims.empty())</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            s.erase(std::remove_if(s.begin(), s.end(), [&amp;delims](<span class="keyword">auto</span>&amp;&amp; ch) {<span class="keywordflow">return</span> delims.find(ch) != std::string::npos; }), s.end());</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        <span class="keywordflow">return</span> s;</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    }</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160; </div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="comment">     * @brief           Remove all specified characters from the given string.</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="comment">     * @param str       Input String</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="comment">     * @param ...delims Any number of characters to remove from the given string.</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="comment">     * @returns         std::string</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <span class="keyword">template</span>&lt;std::same_as&lt;<span class="keywordtype">char</span>&gt;... DelimT&gt;</div>
<div class="line"><a name="l00445"></a><span class="lineno"><a class="line" href="namespacestr.html#a333afe30699add89dd4b33e8f8e965af">  445</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> <span class="keyword">static</span> std::string <a class="code" href="namespacestr.html#a333afe30699add89dd4b33e8f8e965af">strip</a>(std::string s, <span class="keyword">const</span> DelimT&amp;... delims)</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    {</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        s.erase(std::remove_if(s.begin(), s.end(), [&amp;delims...](<span class="keyword">auto</span>&amp;&amp; ch) { <span class="keywordflow">return</span> var::variadic_or(ch == delims...); }), s.end());</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        <span class="keywordflow">return</span> s;</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    }</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160; </div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment">     * @brief               Variadic variant of the getline function.</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="comment">     * @tparam Ch           Char Type</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment">     * @tparam Tr           Char Traits</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment">     * @tparam A            Allocator Type</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="comment">     * @tparam DelimT...    Any number of types that are the same or convertible to Ch</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="comment">     * @param is            Input stream ref</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="comment">     * @param str           Output string ref</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="comment">     * @param delimiters    Any number of characters to use as delimiters.</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="comment">     * @returns             basic_istream&lt;Ch, Tr&gt;&amp;</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch, <span class="keyword">class</span> Tr, <span class="keyword">class</span> A, var::same_or_convertible&lt;Ch&gt;... DelimT&gt;</div>
<div class="line"><a name="l00463"></a><span class="lineno"><a class="line" href="namespacestr.html#ae828e40bdc8eec39773e1a4dac9d7ed3">  463</a></span>&#160;    std::basic_istream&lt;Ch, Tr&gt;&amp; <a class="code" href="namespacestr.html#ae828e40bdc8eec39773e1a4dac9d7ed3">getline</a>(std::basic_istream&lt;Ch, Tr&gt;&amp; is, std::basic_string&lt;Ch, Tr, A&gt;&amp; str, DelimT <span class="keyword">const</span>&amp;... delims)</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    {</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        std::string::size_type nread{ 0 }; <span class="comment">// number of characters read</span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="keywordflow">if</span> (std::istream::sentry(is, <span class="keyword">true</span>)) {</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;            std::streambuf* sbuf{ is.rdbuf() };</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;            str.clear();</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;            <span class="keywordflow">while</span> (nread &lt; str.max_size()) {</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                <span class="keyword">auto</span> c1{ sbuf-&gt;sbumpc() };</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                <span class="keywordflow">if</span> (Tr::eq_int_type(c1, Tr::eof())) {</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                    is.setstate(std::istream::eofbit);</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                }</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                ++nread;</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;                <span class="keywordflow">if</span> (<span class="keyword">const</span> Ch ch{ Tr::to_char_type(c1) }; !var::variadic_or(ch == delims...))</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                    str.push_back(ch);</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            }</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        }</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        <span class="keywordflow">if</span> (nread == 0 || nread &gt;= str.max_size())</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;            is.setstate(std::istream::failbit);</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        <span class="keywordflow">return</span> is;</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    }</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160; </div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="comment">     * @brief               Check if the given string starts with the given characters.</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="comment">     * @param str           Input String.</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="comment">     * @param ...prefix     Any number of types that can be represented with a string to check for.</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="comment">     * @returns             bool</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    <span class="keyword">template</span>&lt;var::Streamable&lt;std::stringstream&gt;... Ts&gt;</div>
<div class="line"><a name="l00493"></a><span class="lineno"><a class="line" href="namespacestr.html#ad50e9ee8aa4a8666ec47aefff8fa4bca">  493</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> <span class="keywordtype">bool</span> <a class="code" href="namespacestr.html#ad50e9ee8aa4a8666ec47aefff8fa4bca">startsWith</a>(<span class="keyword">const</span> std::string&amp; str, Ts&amp;&amp;... prefix)</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    {</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<span class="keyword">sizeof</span>...(Ts) == 0ull)</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str.empty())</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160; </div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        <span class="keyword">const</span> std::string&amp; comp{ stringify(std::forward&lt;Ts&gt;(prefix)...) };</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160; </div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        <span class="keywordflow">if</span> (comp.size() &gt; str.size())</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160; </div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        size_t matches{ 0ull };</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> itstr{ str.begin() }, itstrEnd{ str.end() }, itcomp{ comp.begin() }, itcompEnd{ comp.end() }; itstr &lt; itstrEnd &amp;&amp; itcomp &lt; itcompEnd; ++itstr, ++itcomp) {</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            <span class="keywordflow">if</span> (*itstr == *itcomp)</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                ++matches;</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        }</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        <span class="keywordflow">return</span> matches == comp.size();</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    }</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160; </div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="comment">     * @brief               Check if the given string ends with the given characters.</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="comment">     * @param str           Input String.</span></div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="comment">     * @param ...suffix     Any number of types that can be represented with a string to check for.</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="comment">     *\n                    The resolved strings are checked in reverse sequential order.</span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="comment">     * @returns             bool</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    <span class="keyword">template</span>&lt;var::Streamable&lt;std::stringstream&gt;... Ts&gt;</div>
<div class="line"><a name="l00522"></a><span class="lineno"><a class="line" href="namespacestr.html#a25dcad1131572f82cbb30a06c81006b0">  522</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> <span class="keywordtype">bool</span> <a class="code" href="namespacestr.html#a25dcad1131572f82cbb30a06c81006b0">endsWith</a>(<span class="keyword">const</span> std::string&amp; str, Ts&amp;&amp;... suffix)</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    {</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<span class="keyword">sizeof</span>...(Ts) == 0ull)</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str.empty())</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160; </div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;        <span class="keyword">const</span> std::string&amp; comp{ stringify(std::forward&lt;Ts&gt;(suffix)...) };</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160; </div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        <span class="keywordflow">if</span> (comp.size() &gt; str.size())</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160; </div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        size_t matches{ 0ull };</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> itstr{ str.rbegin() }, itstrEnd{ str.rend() }, itcomp{comp.rbegin()}, itcompEnd{ comp.rend() }; itstr &lt; itstrEnd &amp;&amp; itcomp &lt; itcompEnd; ++itstr, ++itcomp) {</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;            <span class="keywordflow">if</span> (*itstr == *itcomp)</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;                ++matches;</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;        }</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;        <span class="keywordflow">return</span> matches == comp.size();</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    }</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160; </div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="comment">     * @brief               Check if the given string is equal to at least one other string.</span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="comment">     * @param str           Input string to compare.</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="comment">     * @param ...compare    Comparison Strings.</span></div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="comment">     * @returns             bool</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> IGNORE_CASE = <span class="keyword">false</span>, var::all_same_or_convertible&lt;std::string&gt;... Ts&gt;</div>
<div class="line"><a name="l00550"></a><span class="lineno"><a class="line" href="namespacestr.html#ac0941f8566d99a99085690ce06c8eec1">  550</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> <span class="keywordtype">bool</span> <a class="code" href="namespacestr.html#ac0941f8566d99a99085690ce06c8eec1">equalsAny</a>(<span class="keyword">const</span> std::string&amp; str, Ts&amp;&amp;... compare)</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    {</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (IGNORE_CASE) {</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; lc{ str::tolower(str) };</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;            <span class="keywordflow">return</span> var::variadic_or(lc == str::tolower(compare)...);</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        }</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;        <span class="keywordflow">return</span> var::variadic_or(str == compare...);</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    }</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment">     * @brief               Check if the given string is equal to at least one other string.</span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment">     * @param str           Input string to compare.</span></div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment">     * @param ...compare    Comparison Strings.</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment">     * @returns             bool</span></div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> IGNORE_CASE = <span class="keyword">false</span>, var::all_same_or_convertible&lt;std::wstring, <span class="keywordtype">char</span>&gt;... Ts&gt;</div>
<div class="line"><a name="l00565"></a><span class="lineno"><a class="line" href="namespacestr.html#ad5a0bf2d97851e9b37bad14d9ed8d224">  565</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> <span class="keywordtype">bool</span> <a class="code" href="namespacestr.html#ad5a0bf2d97851e9b37bad14d9ed8d224">equalsAny</a>(<span class="keyword">const</span> std::wstring&amp; str, Ts&amp;&amp;... compare)</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;    {</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (IGNORE_CASE) {</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; lc{ str::tolower(str) };</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;            <span class="keywordflow">return</span> var::variadic_or(lc == str::tolower(compare)...);</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;        }</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;        <span class="keywordflow">return</span> var::variadic_or(str == compare...);</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    }</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160; </div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    <span class="comment">/**</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="comment">     * @brief               Check if a given string matches any of a list of strings.</span></div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="comment">     * @tparam MatchCase    When true, matches are case sensitive, otherwise they are case insensitive.</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="comment">     * @tparam StrT         String Type.</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="comment">     * @tparam Ts...        Variadic number of types that are the same as StrT.</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="comment">     * @param str           Input String</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="comment">     * @param matches       At least one string to compare to str.</span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="comment">     * @returns bool</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> MatchCase = <span class="keyword">true</span>, var::valid_string StrT, var::same_or_convertible&lt;StrT&gt;... Ts&gt; requires var::at_least_one&lt;<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">Ts</a>...&gt;</div>
<div class="line"><a name="l00584"></a><span class="lineno"><a class="line" href="namespacestr.html#a99874f5b703e388240420d5bec8557a3">  584</a></span>&#160;    <span class="keyword">inline</span> <a class="code" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> <span class="keywordtype">bool</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">matches_any</a>(<span class="keyword">const</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">StrT</a>&amp; <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str</a>, <span class="keyword">const</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">Ts</a>&amp;... <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">matches</a>)</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    {</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (!<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">MatchCase</a>)</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">var</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">variadic_or</a>((<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">tolower</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str</a>) == <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">tolower</a>(<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">matches</a>))...);</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">var</a>::<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">variadic_or</a>((<a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str</a> == <a class="code" href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">matches</a>)...);</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    }</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;}</div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacestr_html_a2e4febc1416769a1b195250f723bcfc0"><div class="ttname"><a href="namespacestr.html#a2e4febc1416769a1b195250f723bcfc0">str::stob</a></div><div class="ttdeci">WINCONSTEXPR bool stob(const std::string &amp;str)</div><div class="ttdoc">Convert a string to a non-optional boolean with the following rules:   - Returns true if the input st...</div><div class="ttdef"><b>Definition:</b> <a href="strconv_8hpp_source.html#l00306">strconv.hpp:306</a></div></div>
<div class="ttc" id="anamespacestr_html_aba03dcb83941ed1d96f1ae269db82fc0"><div class="ttname"><a href="namespacestr.html#aba03dcb83941ed1d96f1ae269db82fc0">str::split</a></div><div class="ttdeci">const WINCONSTEXPR std::pair&lt; std::string, std::string &gt; split(const std::string &amp;str, const size_t &amp;pos, const bool &amp;discard_pos=false)</div><div class="ttdoc">Split a string into a pair of strings by position. This is a simple wrapper to return a string split ...</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00351">str.hpp:351</a></div></div>
<div class="ttc" id="astr_8hpp_html_aa415d1d4d4888d8486edf353a9405d9f"><div class="ttname"><a href="str_8hpp.html#aa415d1d4d4888d8486edf353a9405d9f">isquote</a></div><div class="ttdeci">constexpr bool isquote(const char c)</div><div class="ttdoc">Test that checks if a given char is a quotation mark. (Accepts single or double quotes....</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00030">str.hpp:30</a></div></div>
<div class="ttc" id="anamespacestr_html_a724f84184c0c1cd75e91b4ac95f40768"><div class="ttname"><a href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">str::stringify</a></div><div class="ttdeci">constexpr static const std::string stringify(Ts &amp;&amp;... args)</div><div class="ttdoc">Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the ...</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00068">str.hpp:68</a></div></div>
<div class="ttc" id="astructstr_1_1_printable_html_a6018e952ad17342eca6ed9cdf0e4add8"><div class="ttname"><a href="structstr_1_1_printable.html#a6018e952ad17342eca6ed9cdf0e4add8">str::Printable::Printable</a></div><div class="ttdeci">constexpr Printable(std::string divider, const VT &amp;... values)</div><div class="ttdoc">Default Constructor.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00279">str.hpp:279</a></div></div>
<div class="ttc" id="anamespacestr_html_a25dcad1131572f82cbb30a06c81006b0"><div class="ttname"><a href="namespacestr.html#a25dcad1131572f82cbb30a06c81006b0">str::endsWith</a></div><div class="ttdeci">WINCONSTEXPR bool endsWith(const std::string &amp;str, Ts &amp;&amp;... suffix)</div><div class="ttdoc">Check if the given string ends with the given characters.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00522">str.hpp:522</a></div></div>
<div class="ttc" id="anamespacestr_html_a333afe30699add89dd4b33e8f8e965af"><div class="ttname"><a href="namespacestr.html#a333afe30699add89dd4b33e8f8e965af">str::strip</a></div><div class="ttdeci">static WINCONSTEXPR std::string strip(std::string s, const DelimT &amp;... delims)</div><div class="ttdoc">Remove all specified characters from the given string.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00445">str.hpp:445</a></div></div>
<div class="ttc" id="anamespacestr_html_ab81d06e112031542961adc0b38bd0b2b"><div class="ttname"><a href="namespacestr.html#ab81d06e112031542961adc0b38bd0b2b">str::split</a></div><div class="ttdeci">const WINCONSTEXPR std::pair&lt; std::string, std::string &gt; split(const std::string &amp;str, const char &amp;delim, const unsigned &amp;occurrence=0ull)</div><div class="ttdoc">Split a string into a pair of strings by finding the first occurrence of a given delimiter.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00362">str.hpp:362</a></div></div>
<div class="ttc" id="astructstr_1_1_variable_indentation_html_a0b7ed36241b97b1ff080384c0e1ba4d3"><div class="ttname"><a href="structstr_1_1_variable_indentation.html#a0b7ed36241b97b1ff080384c0e1ba4d3">str::VariableIndentation::VariableIndentation</a></div><div class="ttdeci">constexpr VariableIndentation(std::streamsize max_width, std::streamsize subtract_width=0, char fill_character=' ')</div><div class="ttdoc">Default Constructor.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00329">str.hpp:329</a></div></div>
<div class="ttc" id="anamespacestr_html_a718e93d72455a6f9af50cca592378f99"><div class="ttname"><a href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">str::longest</a></div><div class="ttdeci">static Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt; &gt; &gt;::const_iterator longest(const Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt;&gt;&gt; &amp;strings)</div><div class="ttdoc">Get the longest string in a container of string tuples.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00211">str.hpp:211</a></div></div>
<div class="ttc" id="anamespacestr_html_ab58e4fd600a73d4ffbdea3d65c5bdabd"><div class="ttname"><a href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">str::compare</a></div><div class="ttdeci">static T compare(const Pred &amp;predicate, const T &amp;fst, const Ts &amp;... strings)</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00151">str.hpp:151</a></div></div>
<div class="ttc" id="anamespacestr_html_ae828e40bdc8eec39773e1a4dac9d7ed3"><div class="ttname"><a href="namespacestr.html#ae828e40bdc8eec39773e1a4dac9d7ed3">str::getline</a></div><div class="ttdeci">std::basic_istream&lt; Ch, Tr &gt; &amp; getline(std::basic_istream&lt; Ch, Tr &gt; &amp;is, std::basic_string&lt; Ch, Tr, A &gt; &amp;str, DelimT const &amp;... delims)</div><div class="ttdoc">Variadic variant of the getline function.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00463">str.hpp:463</a></div></div>
<div class="ttc" id="astructstr_1_1_variable_indentation_html_a61f3a5bfdecc177e798e4edb0d5656ba"><div class="ttname"><a href="structstr_1_1_variable_indentation.html#a61f3a5bfdecc177e798e4edb0d5656ba">str::VariableIndentation::_fill</a></div><div class="ttdeci">const char _fill</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00321">str.hpp:321</a></div></div>
<div class="ttc" id="asysarch_8h_html_a2fbf9b2640da245c6473f91b18781960"><div class="ttname"><a href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a></div><div class="ttdeci">#define WINCONSTEXPR</div><div class="ttdef"><b>Definition:</b> <a href="sysarch_8h_source.html#l00247">sysarch.h:247</a></div></div>
<div class="ttc" id="anamespacestr_html_aab273e18c3896683954b42ea222129f4"><div class="ttname"><a href="namespacestr.html#aab273e18c3896683954b42ea222129f4">str::longest</a></div><div class="ttdeci">static Cont&lt; T, std::allocator&lt; T &gt; &gt;::const_iterator longest(const Cont&lt; T, std::allocator&lt; T &gt;&gt; &amp;strings)</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00165">str.hpp:165</a></div></div>
<div class="ttc" id="astructstr_1_1_printable_html_aae7c738de43acc54b691ec8ad1a7a45c"><div class="ttname"><a href="structstr_1_1_printable.html#aae7c738de43acc54b691ec8ad1a7a45c">str::Printable::tuple&lt; VT... &gt;</a></div><div class="ttdeci">constexpr operator const std::tuple&lt; VT... &gt;() const</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00280">str.hpp:280</a></div></div>
<div class="ttc" id="astructstr_1_1_printable_html_aa096ba2fe91640135686d959d48b9d58"><div class="ttname"><a href="structstr_1_1_printable.html#aa096ba2fe91640135686d959d48b9d58">str::Printable::_div</a></div><div class="ttdeci">const std::string _div</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00272">str.hpp:272</a></div></div>
<div class="ttc" id="anamespacestr_html_a0377cd612795f7313947f6b43910b032"><div class="ttname"><a href="namespacestr.html#a0377cd612795f7313947f6b43910b032">str::shortest</a></div><div class="ttdeci">static Cont&lt; T, std::allocator&lt; T &gt; &gt;::const_iterator shortest(const Cont&lt; T, std::allocator&lt; T &gt;&gt; &amp;strings)</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00174">str.hpp:174</a></div></div>
<div class="ttc" id="anamespacestr_html_a3d0e9313e9c0b862cfe77a3814139aa9"><div class="ttname"><a href="namespacestr.html#a3d0e9313e9c0b862cfe77a3814139aa9">str::stringify_split</a></div><div class="ttdeci">constexpr static const std::vector&lt; std::string &gt; stringify_split(const DelimType &amp;delimiter, Ts &amp;&amp;... args)</div><div class="ttdoc">Creates a temporary stringstream and inserts all of the given arguments in sequential order,...</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00114">str.hpp:114</a></div></div>
<div class="ttc" id="anamespacestr_html_a4a7fab88e397cd6251944c3d01a7438d"><div class="ttname"><a href="namespacestr.html#a4a7fab88e397cd6251944c3d01a7438d">str::strip_preceeding</a></div><div class="ttdeci">static std::string strip_preceeding(const std::string &amp;str, const DelimT &amp;... delims)</div><div class="ttdoc">Remove preceeding characters from a string.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00413">str.hpp:413</a></div></div>
<div class="ttc" id="astructstr_1_1_printable_html_a097f661e8c2bb195fc5cb0965076435c"><div class="ttname"><a href="structstr_1_1_printable.html#a097f661e8c2bb195fc5cb0965076435c">str::Printable::_values</a></div><div class="ttdeci">const std::tuple&lt; VT... &gt; _values</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00273">str.hpp:273</a></div></div>
<div class="ttc" id="anamespacestr_html_a18758598172725d265bdab25d48f5836"><div class="ttname"><a href="namespacestr.html#a18758598172725d265bdab25d48f5836">str::streamify</a></div><div class="ttdeci">static std::stringstream streamify(Ts &amp;&amp;... args)</div><div class="ttdoc">Creates a stringstream, inserts all of the given arguments, then move-returns the resulting stringstr...</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00054">str.hpp:54</a></div></div>
<div class="ttc" id="anamespacestr_html_a8a8c67ed7c199414fca456eef77b60e7"><div class="ttname"><a href="namespacestr.html#a8a8c67ed7c199414fca456eef77b60e7">str::count</a></div><div class="ttdeci">static size_t count(std::stringstream &amp;ss, char delim)</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00098">str.hpp:98</a></div></div>
<div class="ttc" id="anamespacestr_html_acf63c00706c91be7da3f18b08a088224"><div class="ttname"><a href="namespacestr.html#acf63c00706c91be7da3f18b08a088224">str::strip</a></div><div class="ttdeci">static WINCONSTEXPR std::string strip(std::string s, const std::string_view &amp;delims)</div><div class="ttdoc">Remove all specified characters from the given string.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00431">str.hpp:431</a></div></div>
<div class="ttc" id="anamespacestr_html_a69b4c7c470963c0be1a41227ccf6f86e"><div class="ttname"><a href="namespacestr.html#a69b4c7c470963c0be1a41227ccf6f86e">str::rsplit</a></div><div class="ttdeci">const WINCONSTEXPR std::pair&lt; std::string, std::string &gt; rsplit(const std::string &amp;str, const char &amp;delim, const unsigned &amp;occurrence=0ull)</div><div class="ttdoc">Split a string into a pair of strings by finding the first occurrence of a given delimiter.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00377">str.hpp:377</a></div></div>
<div class="ttc" id="anamespacestr_html_a26bf9f8189aea4146e003477d8b7a62d"><div class="ttname"><a href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">str::pos_valid</a></div><div class="ttdeci">constexpr bool pos_valid(const T &amp;pos) noexcept</div><div class="ttdoc">Simply checks the given position value against std::string::npos.</div><div class="ttdef"><b>Definition:</b> <a href="strutility_8hpp_source.html#l00041">strutility.hpp:41</a></div></div>
<div class="ttc" id="anamespacestr_html_a87c41dd852c1db4ba8b8f1d28e4728b5"><div class="ttname"><a href="namespacestr.html#a87c41dd852c1db4ba8b8f1d28e4728b5">str::shortest</a></div><div class="ttdeci">static T shortest(const T &amp;fst, const Ts &amp;... strings)</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00162">str.hpp:162</a></div></div>
<div class="ttc" id="anamespacestr_html_a45c1b11a2e282a4fc8d38548eaf45f3c"><div class="ttname"><a href="namespacestr.html#a45c1b11a2e282a4fc8d38548eaf45f3c">str::strip_trailing</a></div><div class="ttdeci">static std::string strip_trailing(const std::string &amp;str, const DelimT &amp;... delims)</div><div class="ttdoc">Remove trailing characters from a string.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00394">str.hpp:394</a></div></div>
<div class="ttc" id="astructstr_1_1_variable_indentation_html_a05fd8fd34da86435e642909f90e30a97"><div class="ttname"><a href="structstr_1_1_variable_indentation.html#a05fd8fd34da86435e642909f90e30a97">str::VariableIndentation::_max_width</a></div><div class="ttdeci">const std::streamsize _max_width</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00320">str.hpp:320</a></div></div>
<div class="ttc" id="anamespacestr_html_abea510ab5719c607e5a2ce61bde9e03e"><div class="ttname"><a href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">str::ConvertibleStringT</a></div><div class="ttdeci">concept ConvertibleStringT</div><div class="ttdoc">Allows types that are constructor-convertible to std::string.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00262">str.hpp:262</a></div></div>
<div class="ttc" id="anamespacestr_html_a89e1ce424ded2930c3b83b41a06b0894"><div class="ttname"><a href="namespacestr.html#a89e1ce424ded2930c3b83b41a06b0894">str::stringify_split</a></div><div class="ttdeci">constexpr static const std::vector&lt; std::string &gt; stringify_split(const DelimType &amp;delimiter, const std::vector&lt; T &gt; &amp;args)</div><div class="ttdoc">Creates a temporary stringstream and inserts all of the given arguments in sequential order,...</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00134">str.hpp:134</a></div></div>
<div class="ttc" id="astructstr_1_1_printable_html"><div class="ttname"><a href="structstr_1_1_printable.html">str::Printable</a></div><div class="ttdoc">A generic wrapper for any number of any types. Allows functions to return an inline-printable value s...</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00271">str.hpp:271</a></div></div>
<div class="ttc" id="anamespacestr_html_a4e29c1c2f11c9fdba7e76bb2e3327c4b"><div class="ttname"><a href="namespacestr.html#a4e29c1c2f11c9fdba7e76bb2e3327c4b">str::longest</a></div><div class="ttdeci">static T longest(const T &amp;fst, const Ts &amp;... strings)</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00160">str.hpp:160</a></div></div>
<div class="ttc" id="anamespacestr_html_a58590dd003d9759582ee1de6d1b6dc9f"><div class="ttname"><a href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">str::shortest</a></div><div class="ttdeci">static Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt; &gt; &gt;::const_iterator shortest(const Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt;&gt;&gt; &amp;strings)</div><div class="ttdoc">Get the shortest string in a container of string tuples.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00229">str.hpp:229</a></div></div>
<div class="ttc" id="astructstr_1_1_variable_indentation_html_a3fd3bb0f4ea2fe6e4ea11b96935cac20"><div class="ttname"><a href="structstr_1_1_variable_indentation.html#a3fd3bb0f4ea2fe6e4ea11b96935cac20">str::VariableIndentation::streamsize</a></div><div class="ttdeci">constexpr operator std::streamsize() const</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00332">str.hpp:332</a></div></div>
<div class="ttc" id="anamespacestr_html_ad5a0bf2d97851e9b37bad14d9ed8d224"><div class="ttname"><a href="namespacestr.html#ad5a0bf2d97851e9b37bad14d9ed8d224">str::equalsAny</a></div><div class="ttdeci">WINCONSTEXPR bool equalsAny(const std::wstring &amp;str, Ts &amp;&amp;... compare)</div><div class="ttdoc">Check if the given string is equal to at least one other string.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00565">str.hpp:565</a></div></div>
<div class="ttc" id="anamespacestr_html_a68189011dff0dc860136f8606606169c"><div class="ttname"><a href="namespacestr.html#a68189011dff0dc860136f8606606169c">str::optional_find</a></div><div class="ttdeci">std::optional&lt; size_t &gt; optional_find(const std::string &amp;str, auto &amp;&amp;search)</div><div class="ttdoc">std::string::find function that returns an optional instead of std::string::npos</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00299">str.hpp:299</a></div></div>
<div class="ttc" id="anamespacestr_html_ac0941f8566d99a99085690ce06c8eec1"><div class="ttname"><a href="namespacestr.html#ac0941f8566d99a99085690ce06c8eec1">str::equalsAny</a></div><div class="ttdeci">WINCONSTEXPR bool equalsAny(const std::string &amp;str, Ts &amp;&amp;... compare)</div><div class="ttdoc">Check if the given string is equal to at least one other string.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00550">str.hpp:550</a></div></div>
<div class="ttc" id="astructstr_1_1_variable_indentation_html_afc60cbed1df803159396e0e3ea7e30a9"><div class="ttname"><a href="structstr_1_1_variable_indentation.html#afc60cbed1df803159396e0e3ea7e30a9">str::VariableIndentation::_sub_width</a></div><div class="ttdeci">const std::streamsize _sub_width</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00320">str.hpp:320</a></div></div>
<div class="ttc" id="astructstr_1_1_variable_indentation_html"><div class="ttname"><a href="structstr_1_1_variable_indentation.html">str::VariableIndentation</a></div><div class="ttdoc">Uses the std::setw() function to create a variable amount of indentation in an output stream.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00319">str.hpp:319</a></div></div>
<div class="ttc" id="anamespacestr_html_ad50e9ee8aa4a8666ec47aefff8fa4bca"><div class="ttname"><a href="namespacestr.html#ad50e9ee8aa4a8666ec47aefff8fa4bca">str::startsWith</a></div><div class="ttdeci">WINCONSTEXPR bool startsWith(const std::string &amp;str, Ts &amp;&amp;... prefix)</div><div class="ttdoc">Check if the given string starts with the given characters.</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00493">str.hpp:493</a></div></div>
<div class="ttc" id="anamespacestr_html_ad35ece5b07dfe3a18235ccc6c0f563ba"><div class="ttname"><a href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">str::requires</a></div><div class="ttdeci">requires(sizeof...(VT) &gt; 0) static std</div><div class="ttdef"><b>Definition:</b> <a href="str_8hpp_source.html#l00306">str.hpp:306</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_2e4e8c1f89328c46a0e85a78c77acd1b.html">strlib</a></li><li class="navelem"><a class="el" href="dir_2c61375df6b494d1d8513826dcf76964.html">include</a></li><li class="navelem"><a class="el" href="str_8hpp.html">str.hpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
