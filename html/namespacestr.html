<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>307Lib: str Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gear-2.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">307Lib
   </div>
   <div id="projectbrief">C++ Libraries made by radj307</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacestr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">str Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains various string manipulation, conversion, and parsing functions.  
<a href="namespacestr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestr_1_1facet"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr_1_1facet.html">facet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestr_1_1op"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr_1_1op.html">op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstr_1_1_printable.html">Printable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic wrapper for any number of any types. Allows functions to return an inline-printable value so the function can be used in an output stream operator&lt;&lt; statement.  <a href="structstr_1_1_printable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstr_1_1_variable_indentation.html">VariableIndentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the std::setw() function to create a variable amount of indentation in an output stream.  <a href="structstr_1_1_variable_indentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstr_1_1_set_locale.html">SetLocale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the locale of a stream. If you want to apply a locale Facet, use struct SetLocaleFacet&lt;&gt; instead.  <a href="structstr_1_1_set_locale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstr_1_1_set_locale_facet.html">SetLocaleFacet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the locale of an iostream, and set a Facet at the same time.  <a href="structstr_1_1_set_locale_facet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a576148d382d024fc11d46dc0ef839cec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a576148d382d024fc11d46dc0ef839cec">VIndent</a> = <a class="el" href="structstr_1_1_variable_indentation.html">VariableIndentation</a></td></tr>
<tr class="separator:a576148d382d024fc11d46dc0ef839cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a991544f9c8b8f65720a0c7994b216bd4"><td class="memTemplParams" colspan="2">template&lt;var::Streamable... VT&gt; </td></tr>
<tr class="memitem:a991544f9c8b8f65720a0c7994b216bd4"><td class="memTemplItemLeft" align="right" valign="top">static std::stringstream&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">streamify</a> (VT... args)</td></tr>
<tr class="memdesc:a991544f9c8b8f65720a0c7994b216bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a stringstream, inserts all of the given arguments, then move-returns the resulting stringstream.  <a href="namespacestr.html#a991544f9c8b8f65720a0c7994b216bd4">More...</a><br /></td></tr>
<tr class="separator:a991544f9c8b8f65720a0c7994b216bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670a97b2121a31298814cb8e4a5d13ff"><td class="memTemplParams" colspan="2">template&lt;var::Streamable... VT&gt; </td></tr>
<tr class="memitem:a670a97b2121a31298814cb8e4a5d13ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr static const std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a670a97b2121a31298814cb8e4a5d13ff">stringify</a> (const VT &amp;... args)</td></tr>
<tr class="memdesc:a670a97b2121a31298814cb8e4a5d13ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the stringstream's str() function.  <a href="namespacestr.html#a670a97b2121a31298814cb8e4a5d13ff">More...</a><br /></td></tr>
<tr class="separator:a670a97b2121a31298814cb8e4a5d13ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cdfa929c2dbd674745f23f30f4f9f4"><td class="memTemplParams" colspan="2">template&lt;template&lt; class, class &gt; class ContainerT, class ElemT , var::Streamable... VT&gt; </td></tr>
<tr class="memitem:a76cdfa929c2dbd674745f23f30f4f9f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> constexpr static std::convertible_to&lt; ElemT, std::string &gt; const std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a76cdfa929c2dbd674745f23f30f4f9f4">stringify_container</a> (const ContainerT&lt; ElemT, std::allocator&lt; ElemT &gt;&gt; &amp;container, VT... separators)</td></tr>
<tr class="memdesc:a76cdfa929c2dbd674745f23f30f4f9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacestr.html#a670a97b2121a31298814cb8e4a5d13ff" title="Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the ...">stringify()</a> variant that accepts a vector of elements instead of variadic arguments.  <a href="namespacestr.html#a76cdfa929c2dbd674745f23f30f4f9f4">More...</a><br /></td></tr>
<tr class="separator:a76cdfa929c2dbd674745f23f30f4f9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44a61b1fed1e226ac26abe03d69adab"><td class="memTemplParams" colspan="2">template&lt;class DelimType , var::Streamable... VT&gt; </td></tr>
<tr class="memitem:ae44a61b1fed1e226ac26abe03d69adab"><td class="memTemplItemLeft" align="right" valign="top">constexpr static const std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#ae44a61b1fed1e226ac26abe03d69adab">stringify_split</a> (const DelimType &amp;delimiter, VT... args)</td></tr>
<tr class="memdesc:ae44a61b1fed1e226ac26abe03d69adab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary stringstream and inserts all of the given arguments in sequential order, then uses the given delimiter to split the resulting string into a vector of strings.  <a href="namespacestr.html#ae44a61b1fed1e226ac26abe03d69adab">More...</a><br /></td></tr>
<tr class="separator:ae44a61b1fed1e226ac26abe03d69adab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58e4fd600a73d4ffbdea3d65c5bdabd"><td class="memTemplParams" colspan="2">template&lt;var::valid_string_or_convertible T, class Pred , var::valid_string_or_convertible... Ts&gt; </td></tr>
<tr class="memitem:ab58e4fd600a73d4ffbdea3d65c5bdabd"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#ab58e4fd600a73d4ffbdea3d65c5bdabd">compare</a> (const Pred &amp;predicate, const T &amp;fst, const Ts &amp;... strings)</td></tr>
<tr class="separator:ab58e4fd600a73d4ffbdea3d65c5bdabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e29c1c2f11c9fdba7e76bb2e3327c4b"><td class="memTemplParams" colspan="2">template&lt;var::valid_string_or_convertible T, var::valid_string_or_convertible... Ts&gt; </td></tr>
<tr class="memitem:a4e29c1c2f11c9fdba7e76bb2e3327c4b"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a4e29c1c2f11c9fdba7e76bb2e3327c4b">longest</a> (const T &amp;fst, const Ts &amp;... strings)</td></tr>
<tr class="separator:a4e29c1c2f11c9fdba7e76bb2e3327c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c41dd852c1db4ba8b8f1d28e4728b5"><td class="memTemplParams" colspan="2">template&lt;var::valid_string_or_convertible T, var::valid_string_or_convertible... Ts&gt; </td></tr>
<tr class="memitem:a87c41dd852c1db4ba8b8f1d28e4728b5"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a87c41dd852c1db4ba8b8f1d28e4728b5">shortest</a> (const T &amp;fst, const Ts &amp;... strings)</td></tr>
<tr class="separator:a87c41dd852c1db4ba8b8f1d28e4728b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab273e18c3896683954b42ea222129f4"><td class="memTemplParams" colspan="2">template&lt;var::valid_string T, template&lt; class, class &gt; class Cont&gt; </td></tr>
<tr class="memitem:aab273e18c3896683954b42ea222129f4"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; T, std::allocator&lt; T &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#aab273e18c3896683954b42ea222129f4">longest</a> (const Cont&lt; T, std::allocator&lt; T &gt;&gt; &amp;strings)</td></tr>
<tr class="separator:aab273e18c3896683954b42ea222129f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0377cd612795f7313947f6b43910b032"><td class="memTemplParams" colspan="2">template&lt;var::valid_string T, template&lt; class, class &gt; class Cont&gt; </td></tr>
<tr class="memitem:a0377cd612795f7313947f6b43910b032"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; T, std::allocator&lt; T &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a0377cd612795f7313947f6b43910b032">shortest</a> (const Cont&lt; T, std::allocator&lt; T &gt;&gt; &amp;strings)</td></tr>
<tr class="separator:a0377cd612795f7313947f6b43910b032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d5f5ddec852ee6650d85fcd45c3030"><td class="memTemplParams" colspan="2">template&lt;bool index, var::valid_string T, template&lt; class... &gt; class Cont&gt; </td></tr>
<tr class="memitem:af0d5f5ddec852ee6650d85fcd45c3030"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; std::pair&lt; T, T &gt;, std::allocator&lt; std::pair&lt; T, T &gt; &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#af0d5f5ddec852ee6650d85fcd45c3030">longest</a> (const Cont&lt; std::pair&lt; T, T &gt;, std::allocator&lt; std::pair&lt; T, T &gt;&gt;&gt; &amp;strings)</td></tr>
<tr class="separator:af0d5f5ddec852ee6650d85fcd45c3030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5890626349406d682c75bf7cded557d0"><td class="memTemplParams" colspan="2">template&lt;bool index, var::valid_string T, template&lt; class... &gt; class Cont&gt; </td></tr>
<tr class="memitem:a5890626349406d682c75bf7cded557d0"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; std::pair&lt; T, T &gt;, std::allocator&lt; std::pair&lt; T, T &gt; &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a5890626349406d682c75bf7cded557d0">shortest</a> (const Cont&lt; std::pair&lt; T, T &gt;, std::allocator&lt; std::pair&lt; T, T &gt;&gt;&gt; &amp;strings)</td></tr>
<tr class="separator:a5890626349406d682c75bf7cded557d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718e93d72455a6f9af50cca592378f99"><td class="memTemplParams" colspan="2">template&lt;size_t index, var::valid_string... Ts, template&lt; class... &gt; class Cont&gt; </td></tr>
<tr class="memitem:a718e93d72455a6f9af50cca592378f99"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt; &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">longest</a> (const Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt;&gt;&gt; &amp;strings)</td></tr>
<tr class="memdesc:a718e93d72455a6f9af50cca592378f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the longest string in a container of string tuples.  <a href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">More...</a><br /></td></tr>
<tr class="separator:a718e93d72455a6f9af50cca592378f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58590dd003d9759582ee1de6d1b6dc9f"><td class="memTemplParams" colspan="2">template&lt;size_t index, var::valid_string... Ts, template&lt; class... &gt; class Cont&gt; </td></tr>
<tr class="memitem:a58590dd003d9759582ee1de6d1b6dc9f"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt; &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">shortest</a> (const Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt;&gt;&gt; &amp;strings)</td></tr>
<tr class="memdesc:a58590dd003d9759582ee1de6d1b6dc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shortest string in a container of string tuples.  <a href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">More...</a><br /></td></tr>
<tr class="separator:a58590dd003d9759582ee1de6d1b6dc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4ee543bc885f863faf20217f7142fe"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:acd4ee543bc885f863faf20217f7142fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> std::convertible_to&lt; T1, std::string &gt; &amp;&amp;static std::convertible_to&lt; T2, std::string &gt; bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#acd4ee543bc885f863faf20217f7142fe">compare</a> (T1 left, T2 right, const bool case_sensitive=true)</td></tr>
<tr class="memdesc:acd4ee543bc885f863faf20217f7142fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare 2 strings.  <a href="namespacestr.html#acd4ee543bc885f863faf20217f7142fe">More...</a><br /></td></tr>
<tr class="separator:acd4ee543bc885f863faf20217f7142fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68189011dff0dc860136f8606606169c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a68189011dff0dc860136f8606606169c">optional_find</a> (const std::string &amp;str, auto &amp;&amp;search)</td></tr>
<tr class="memdesc:a68189011dff0dc860136f8606606169c"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::string::find function that returns an optional instead of std::string::npos  <a href="namespacestr.html#a68189011dff0dc860136f8606606169c">More...</a><br /></td></tr>
<tr class="separator:a68189011dff0dc860136f8606606169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35ece5b07dfe3a18235ccc6c0f563ba"><td class="memTemplParams" colspan="2">template&lt;typename... VT&gt; </td></tr>
<tr class="memitem:ad35ece5b07dfe3a18235ccc6c0f563ba"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> (sizeof...(VT) &gt; 0) static std</td></tr>
<tr class="separator:ad35ece5b07dfe3a18235ccc6c0f563ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a9fd532000619ae079e65046214a5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> const std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a62a9fd532000619ae079e65046214a5e">split</a> (const std::string &amp;str, const size_t &amp;pos, const bool &amp;discard_pos=false)</td></tr>
<tr class="memdesc:a62a9fd532000619ae079e65046214a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a pair of strings by position. This is a simple wrapper to return a string split operation as a pair of strings.  <a href="namespacestr.html#a62a9fd532000619ae079e65046214a5e">More...</a><br /></td></tr>
<tr class="separator:a62a9fd532000619ae079e65046214a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f5017167eb58048dd646654c5943cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> const std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a63f5017167eb58048dd646654c5943cc">split</a> (const std::string &amp;str, const char &amp;delim, const unsigned &amp;occurrence=0ull)</td></tr>
<tr class="memdesc:a63f5017167eb58048dd646654c5943cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a pair of strings by finding the first occurrence of a given delimiter.  <a href="namespacestr.html#a63f5017167eb58048dd646654c5943cc">More...</a><br /></td></tr>
<tr class="separator:a63f5017167eb58048dd646654c5943cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace29034bfe12d695cf5aea81e33d4561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> const std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ace29034bfe12d695cf5aea81e33d4561">rsplit</a> (const std::string &amp;str, const char &amp;delim, const unsigned &amp;occurrence=0ull)</td></tr>
<tr class="memdesc:ace29034bfe12d695cf5aea81e33d4561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a pair of strings by finding the first occurrence of a given delimiter.  <a href="namespacestr.html#ace29034bfe12d695cf5aea81e33d4561">More...</a><br /></td></tr>
<tr class="separator:ace29034bfe12d695cf5aea81e33d4561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bfcfb51a1c131387fd6d08629aba53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sysarch_8h.html#acaa06fbc27c59926a41e7575667e5280">CONSTEXPR</a> char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ae2bfcfb51a1c131387fd6d08629aba53">tolower</a> (const char &amp;c) noexcept</td></tr>
<tr class="memdesc:ae2bfcfb51a1c131387fd6d08629aba53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character to lowercase.  <a href="namespacestr.html#ae2bfcfb51a1c131387fd6d08629aba53">More...</a><br /></td></tr>
<tr class="separator:ae2bfcfb51a1c131387fd6d08629aba53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8981700b8e845f34864ace4d4ddfcf25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a8981700b8e845f34864ace4d4ddfcf25">tolower</a> (std::string str) noexcept</td></tr>
<tr class="memdesc:a8981700b8e845f34864ace4d4ddfcf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a convertible-character to lowercase.  <a href="namespacestr.html#a8981700b8e845f34864ace4d4ddfcf25">More...</a><br /></td></tr>
<tr class="separator:a8981700b8e845f34864ace4d4ddfcf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae017529a0116f69b6d0edf9d9ea7f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sysarch_8h.html#acaa06fbc27c59926a41e7575667e5280">CONSTEXPR</a> char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aae017529a0116f69b6d0edf9d9ea7f96">toupper</a> (const char &amp;c) noexcept</td></tr>
<tr class="memdesc:aae017529a0116f69b6d0edf9d9ea7f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character to uppercase.  <a href="namespacestr.html#aae017529a0116f69b6d0edf9d9ea7f96">More...</a><br /></td></tr>
<tr class="separator:aae017529a0116f69b6d0edf9d9ea7f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dbbdf96e49e575d8b322ef8880f2f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aa8dbbdf96e49e575d8b322ef8880f2f1">toupper</a> (std::string str) noexcept</td></tr>
<tr class="memdesc:aa8dbbdf96e49e575d8b322ef8880f2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a convertible-character to uppercase.  <a href="namespacestr.html#aa8dbbdf96e49e575d8b322ef8880f2f1">More...</a><br /></td></tr>
<tr class="separator:aa8dbbdf96e49e575d8b322ef8880f2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fdfbc25414c557d8a7438d47fc71c4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a16fdfbc25414c557d8a7438d47fc71c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> std::floating_point&lt; T &gt; <a class="el" href="sysarch_8h.html#acaa06fbc27c59926a41e7575667e5280">CONSTEXPR</a> const std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a16fdfbc25414c557d8a7438d47fc71c4">to_string</a> (const T &amp;val, const std::streamsize &amp;precision=8, const bool force_decimal=false)</td></tr>
<tr class="memdesc:a16fdfbc25414c557d8a7438d47fc71c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a floating-point to a string in standard notation, with a specified amount of precision.  <a href="namespacestr.html#a16fdfbc25414c557d8a7438d47fc71c4">More...</a><br /></td></tr>
<tr class="separator:a16fdfbc25414c557d8a7438d47fc71c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fa2dd079f3b6ebd63eaffb030e980c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a11fa2dd079f3b6ebd63eaffb030e980c">bool_to_string</a> (const bool &amp;val, const bool &amp;first_upper=false)</td></tr>
<tr class="memdesc:a11fa2dd079f3b6ebd63eaffb030e980c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a boolean to a string.  <a href="namespacestr.html#a11fa2dd079f3b6ebd63eaffb030e980c">More...</a><br /></td></tr>
<tr class="separator:a11fa2dd079f3b6ebd63eaffb030e980c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b3be3bdfe64e47f3652175fa46e0d5"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType  = std::optional&lt;bool&gt;&gt; </td></tr>
<tr class="memitem:a29b3be3bdfe64e47f3652175fa46e0d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> std::same_as&lt; ReturnType, bool &gt; std::same_as&lt; ReturnType, std::optional&lt; bool &gt; &gt; ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a29b3be3bdfe64e47f3652175fa46e0d5">string_to_bool</a> (std::string str)</td></tr>
<tr class="memdesc:a29b3be3bdfe64e47f3652175fa46e0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a boolean.  <a href="namespacestr.html#a29b3be3bdfe64e47f3652175fa46e0d5">More...</a><br /></td></tr>
<tr class="separator:a29b3be3bdfe64e47f3652175fa46e0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bde2717215ef2e746a382003a8fc58"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a26bde2717215ef2e746a382003a8fc58">Placeholder</a> (std::ostream &amp;os)</td></tr>
<tr class="memdesc:a26bde2717215ef2e746a382003a8fc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder function that does nothing. Intended for use in ternary expressions.  <a href="namespacestr.html#a26bde2717215ef2e746a382003a8fc58">More...</a><br /></td></tr>
<tr class="separator:a26bde2717215ef2e746a382003a8fc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5247d873952449905ce03aca93e5661d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a5247d873952449905ce03aca93e5661d">NumberGrouping</a> (std::ostream &amp;os)</td></tr>
<tr class="memdesc:a5247d873952449905ce03aca93e5661d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically insert commas between thousands when printing numbers. <br  />
 Example: "1000000" =&gt; "1,000,000".  <a href="namespacestr.html#a5247d873952449905ce03aca93e5661d">More...</a><br /></td></tr>
<tr class="separator:a5247d873952449905ce03aca93e5661d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c6dc2d1ec575eb4f211b202f1baec0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a14c6dc2d1ec575eb4f211b202f1baec0">reverse</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a14c6dc2d1ec575eb4f211b202f1baec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bac9088e59d818dfcb958ca9fc1c673"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a5bac9088e59d818dfcb958ca9fc1c673"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; CharT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a5bac9088e59d818dfcb958ca9fc1c673">split_to_vector</a> (const std::basic_string&lt; CharT, Traits, std::allocator&lt; CharT &gt;&gt; &amp;str)</td></tr>
<tr class="memdesc:a5bac9088e59d818dfcb958ca9fc1c673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a vector of characters.  <a href="namespacestr.html#a5bac9088e59d818dfcb958ca9fc1c673">More...</a><br /></td></tr>
<tr class="separator:a5bac9088e59d818dfcb958ca9fc1c673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d96ab238bb0666c844c65b60303dbd"><td class="memItemLeft" align="right" valign="top">std::string::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a93d96ab238bb0666c844c65b60303dbd">find_any</a> (std::string ln, const std::string &amp;dels, const std::string::iterator &amp;off)</td></tr>
<tr class="memdesc:a93d96ab238bb0666c844c65b60303dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find any of a given set of delimiters in a string.  <a href="namespacestr.html#a93d96ab238bb0666c844c65b60303dbd">More...</a><br /></td></tr>
<tr class="separator:a93d96ab238bb0666c844c65b60303dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8f258dcf725866036392dc253eb48d"><td class="memItemLeft" align="right" valign="top">std::string::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#acd8f258dcf725866036392dc253eb48d">find_any</a> (std::string ln, const std::string &amp;dels)</td></tr>
<tr class="separator:acd8f258dcf725866036392dc253eb48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7346dfeb6d8d2d04a563649f4bf3cbca"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a7346dfeb6d8d2d04a563649f4bf3cbca">strip_line</a> (std::string str, const std::string &amp;comment_chars={}, const std::string &amp;whitespace_chars=&quot; \t\r\n\v&quot;)</td></tr>
<tr class="memdesc:a7346dfeb6d8d2d04a563649f4bf3cbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes comments and preceeding/trailing whitespace from a given string.  <a href="namespacestr.html#a7346dfeb6d8d2d04a563649f4bf3cbca">More...</a><br /></td></tr>
<tr class="separator:a7346dfeb6d8d2d04a563649f4bf3cbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41372d1cf755e2aa10b286aa5cc7e5b1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a41372d1cf755e2aa10b286aa5cc7e5b1">strip_line_multiCharComment</a> (std::string str, const std::vector&lt; std::string &gt; &amp;comment_del={}, const std::string &amp;whitespace_chars=&quot; \t\r\n\v&quot;)</td></tr>
<tr class="memdesc:a41372d1cf755e2aa10b286aa5cc7e5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes more complex comments ( ex. C/JSON/html comments ) and preceeding/trailing whitespace from a given string.  <a href="namespacestr.html#a41372d1cf755e2aa10b286aa5cc7e5b1">More...</a><br /></td></tr>
<tr class="separator:a41372d1cf755e2aa10b286aa5cc7e5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d0037316e84612973026c052ec0616"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a38d0037316e84612973026c052ec0616"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a38d0037316e84612973026c052ec0616">concat</a> (T &amp;&amp;... str)</td></tr>
<tr class="memdesc:a38d0037316e84612973026c052ec0616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate any number of string/char* types into a single string.  <a href="namespacestr.html#a38d0037316e84612973026c052ec0616">More...</a><br /></td></tr>
<tr class="separator:a38d0037316e84612973026c052ec0616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c9108691e6d984499341518c993787"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a61c9108691e6d984499341518c993787">align_center</a> (const std::string &amp;str, const unsigned int setw)</td></tr>
<tr class="memdesc:a61c9108691e6d984499341518c993787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centers a string in the specified number of characters by addings spaces on either side.  <a href="namespacestr.html#a61c9108691e6d984499341518c993787">More...</a><br /></td></tr>
<tr class="separator:a61c9108691e6d984499341518c993787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d6dd0849bbc57ab6970682bf0f8078"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ad1d6dd0849bbc57ab6970682bf0f8078">remove_whitespace</a> (std::string str) noexcept</td></tr>
<tr class="memdesc:ad1d6dd0849bbc57ab6970682bf0f8078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline wrapper for the erase-remove idiom that removes spaces.  <a href="namespacestr.html#ad1d6dd0849bbc57ab6970682bf0f8078">More...</a><br /></td></tr>
<tr class="separator:ad1d6dd0849bbc57ab6970682bf0f8078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea95d9955d4eaf233668351a309059db"><td class="memTemplParams" colspan="2">template&lt;class Ch , class Tr , class A , class Pred &gt; </td></tr>
<tr class="memitem:aea95d9955d4eaf233668351a309059db"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#aea95d9955d4eaf233668351a309059db">getline_pred</a> (std::basic_istream&lt; Ch, Tr &gt; &amp;is, std::basic_string&lt; Ch, Tr, A &gt; &amp;str, Pred p)</td></tr>
<tr class="memdesc:aea95d9955d4eaf233668351a309059db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative std::getline that accepts a predicate function rather than a char delimiter.  <a href="namespacestr.html#aea95d9955d4eaf233668351a309059db">More...</a><br /></td></tr>
<tr class="separator:aea95d9955d4eaf233668351a309059db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af632b5ef496a88eb6c6a50ee18385c62"><td class="memTemplParams" colspan="2">template&lt;class Ch , class Tr , class A &gt; </td></tr>
<tr class="memitem:af632b5ef496a88eb6c6a50ee18385c62"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#af632b5ef496a88eb6c6a50ee18385c62">getline</a> (std::basic_istream&lt; Ch, Tr &gt; &amp;is, std::basic_string&lt; Ch, Tr, A &gt; &amp;str, const std::string &amp;delimiters)</td></tr>
<tr class="memdesc:af632b5ef496a88eb6c6a50ee18385c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative std::getline that accepts a string of delimiters rather than a single char.  <a href="namespacestr.html#af632b5ef496a88eb6c6a50ee18385c62">More...</a><br /></td></tr>
<tr class="separator:af632b5ef496a88eb6c6a50ee18385c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bf5f1b14b776ed8c1225f5c2870a92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aa4bf5f1b14b776ed8c1225f5c2870a92">split_by_words</a> (const std::string &amp;line)</td></tr>
<tr class="memdesc:aa4bf5f1b14b776ed8c1225f5c2870a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a given string into a vector of strings, with one word per index.  <a href="namespacestr.html#aa4bf5f1b14b776ed8c1225f5c2870a92">More...</a><br /></td></tr>
<tr class="separator:aa4bf5f1b14b776ed8c1225f5c2870a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba157b4f80912e0c19b9ad7676d2c8d1"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aba157b4f80912e0c19b9ad7676d2c8d1"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#aba157b4f80912e0c19b9ad7676d2c8d1">sanitize</a> (std::string str, F pred) noexcept</td></tr>
<tr class="memdesc:aba157b4f80912e0c19b9ad7676d2c8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanitize a string with a single predicate function. This is called by <a class="el" href="namespacestr.html#a30c7ac3d05115fd618a8779045def1c7" title="Inline wrapper for the erase-remove idiom that accepts a lambda predicate.">remove_all_of()</a>.  <a href="namespacestr.html#aba157b4f80912e0c19b9ad7676d2c8d1">More...</a><br /></td></tr>
<tr class="separator:aba157b4f80912e0c19b9ad7676d2c8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c7ac3d05115fd618a8779045def1c7"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a30c7ac3d05115fd618a8779045def1c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a30c7ac3d05115fd618a8779045def1c7">remove_all_of</a> (std::string str, F pred) noexcept</td></tr>
<tr class="memdesc:a30c7ac3d05115fd618a8779045def1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline wrapper for the erase-remove idiom that accepts a lambda predicate.  <a href="namespacestr.html#a30c7ac3d05115fd618a8779045def1c7">More...</a><br /></td></tr>
<tr class="separator:a30c7ac3d05115fd618a8779045def1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f757b5761b656d6ce1d15aee26507c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a16f757b5761b656d6ce1d15aee26507c">remove_all</a> (std::string str, const std::string &amp;delims)</td></tr>
<tr class="memdesc:a16f757b5761b656d6ce1d15aee26507c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of a given list of delimiters from a given string.  <a href="namespacestr.html#a16f757b5761b656d6ce1d15aee26507c">More...</a><br /></td></tr>
<tr class="separator:a16f757b5761b656d6ce1d15aee26507c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f6e6378f1869b65cce94f28f31d665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a82f6e6378f1869b65cce94f28f31d665">apply_to_each</a> (std::string &amp;str, const std::vector&lt; std::function&lt; int(int)&gt;, std::allocator&lt; std::function&lt; int(int)&gt;&gt;&gt; &amp;funclist) noexcept</td></tr>
<tr class="memdesc:a82f6e6378f1869b65cce94f28f31d665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a given list of functions to each character in a given string.  <a href="namespacestr.html#a82f6e6378f1869b65cce94f28f31d665">More...</a><br /></td></tr>
<tr class="separator:a82f6e6378f1869b65cce94f28f31d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ad677b200aa91ac5ff1b6eda8b8ea2"><td class="memTemplParams" colspan="2">template&lt;template&lt; class, class &gt; class ContType&gt; </td></tr>
<tr class="memitem:a01ad677b200aa91ac5ff1b6eda8b8ea2"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a01ad677b200aa91ac5ff1b6eda8b8ea2">parseWithDelim</a> (std::string str, const char delim=',', std::optional&lt; ContType&lt; std::function&lt; int(int)&gt;, std::allocator&lt; std::function&lt; int(int)&gt;&gt;&gt;&gt; remove_if=std::nullopt) noexcept</td></tr>
<tr class="memdesc:a01ad677b200aa91ac5ff1b6eda8b8ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a given string with a given delimiter, and return a vector of strings.  <a href="namespacestr.html#a01ad677b200aa91ac5ff1b6eda8b8ea2">More...</a><br /></td></tr>
<tr class="separator:a01ad677b200aa91ac5ff1b6eda8b8ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9a7cdc58ff315c0dbdb4793171918f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a9f9a7cdc58ff315c0dbdb4793171918f">toVector</a> (std::stringstream data, std::optional&lt; char &gt; delim=std::nullopt)</td></tr>
<tr class="memdesc:a9f9a7cdc58ff315c0dbdb4793171918f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a stringstream to a vector of strings, where each string contains one line from the stream.  <a href="namespacestr.html#a9f9a7cdc58ff315c0dbdb4793171918f">More...</a><br /></td></tr>
<tr class="separator:a9f9a7cdc58ff315c0dbdb4793171918f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88947ca78984e05f41dd36fb221d32d6"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a88947ca78984e05f41dd36fb221d32d6">toMap</a> (std::stringstream &amp;data, const std::string &amp;delims, const char lineDelim='\n', const bool noSpace=true) noexcept</td></tr>
<tr class="memdesc:a88947ca78984e05f41dd36fb221d32d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a stringstream to a map of string keys &amp; string vars.  <a href="namespacestr.html#a88947ca78984e05f41dd36fb221d32d6">More...</a><br /></td></tr>
<tr class="separator:a88947ca78984e05f41dd36fb221d32d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2665afb44cc6e90ff1e922639ea0e528"><td class="memItemLeft" align="right" valign="top">std::stringstream::pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a2665afb44cc6e90ff1e922639ea0e528">getStreamLength</a> (std::stringstream &amp;ss) noexcept</td></tr>
<tr class="memdesc:a2665afb44cc6e90ff1e922639ea0e528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a given stringstream.  <a href="namespacestr.html#a2665afb44cc6e90ff1e922639ea0e528">More...</a><br /></td></tr>
<tr class="separator:a2665afb44cc6e90ff1e922639ea0e528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b36762bf1fb176cef1f3ab327ff2da6"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a2b36762bf1fb176cef1f3ab327ff2da6">extractString</a> (const std::string &amp;line, const std::pair&lt; std::string, std::string &gt; delims, const bool includeDelim=false) noexcept</td></tr>
<tr class="memdesc:a2b36762bf1fb176cef1f3ab327ff2da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring from the first appearance of a pair of delimiters, if no delimiter is found, uses the beginning/end of the given str.  <a href="namespacestr.html#a2b36762bf1fb176cef1f3ab327ff2da6">More...</a><br /></td></tr>
<tr class="separator:a2b36762bf1fb176cef1f3ab327ff2da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e72dddafe6ddd37de81a5368ad75f0e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a3e72dddafe6ddd37de81a5368ad75f0e">extractString</a> (const std::string &amp;line, const std::string &amp;delims, const bool includeDelim=false) noexcept</td></tr>
<tr class="memdesc:a3e72dddafe6ddd37de81a5368ad75f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a contiguous substring from the first/last 2 appearances of the given delims.  <a href="namespacestr.html#a3e72dddafe6ddd37de81a5368ad75f0e">More...</a><br /></td></tr>
<tr class="separator:a3e72dddafe6ddd37de81a5368ad75f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93442c940874127d76612c31be16f7a7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a93442c940874127d76612c31be16f7a7">extractString</a> (const std::string &amp;line, const std::pair&lt; const char, const char &gt; delim) noexcept</td></tr>
<tr class="memdesc:a93442c940874127d76612c31be16f7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring from the first appearance of a given delimiter to the last.  <a href="namespacestr.html#a93442c940874127d76612c31be16f7a7">More...</a><br /></td></tr>
<tr class="separator:a93442c940874127d76612c31be16f7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d243724dffd234a19646d7c7b13553"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#af3d243724dffd234a19646d7c7b13553">extractStringUntil</a> (const std::string &amp;line, const char delim, const bool begin=true, const bool <a class="el" href="namespacestr.html#a14c6dc2d1ec575eb4f211b202f1baec0">reverse</a>=false) noexcept</td></tr>
<tr class="memdesc:af3d243724dffd234a19646d7c7b13553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substr between the beginning/end of a given string and the first occurrence of a given delimiter.  <a href="namespacestr.html#af3d243724dffd234a19646d7c7b13553">More...</a><br /></td></tr>
<tr class="separator:af3d243724dffd234a19646d7c7b13553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2842f64da212ac392e6c3385eb54a3e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::tuple&lt; std::string, std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ad2842f64da212ac392e6c3385eb54a3e">extractAllStrings</a> (const std::string &amp;line, const std::pair&lt; const char, const char &gt; delim, const bool forward, const bool includeDelim=false) noexcept</td></tr>
<tr class="memdesc:ad2842f64da212ac392e6c3385eb54a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3 substr, the first being the string until the first delim, the second being between the given delims, and the 3rd being the remaining string after the second delim.  <a href="namespacestr.html#ad2842f64da212ac392e6c3385eb54a3e">More...</a><br /></td></tr>
<tr class="separator:ad2842f64da212ac392e6c3385eb54a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7141b95490d6fff216bb4dc520831d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a0f7141b95490d6fff216bb4dc520831d">contains</a> (const std::string &amp;str, const char ch) noexcept</td></tr>
<tr class="memdesc:a0f7141b95490d6fff216bb4dc520831d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given string exists within another string.  <a href="namespacestr.html#a0f7141b95490d6fff216bb4dc520831d">More...</a><br /></td></tr>
<tr class="separator:a0f7141b95490d6fff216bb4dc520831d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca8ec530dc360aeabadf2aa97423980"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a0ca8ec530dc360aeabadf2aa97423980">contains</a> (const std::string &amp;str, const std::string &amp;delims) noexcept</td></tr>
<tr class="memdesc:a0ca8ec530dc360aeabadf2aa97423980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any of a list of delimiters is present in a given string.  <a href="namespacestr.html#a0ca8ec530dc360aeabadf2aa97423980">More...</a><br /></td></tr>
<tr class="separator:a0ca8ec530dc360aeabadf2aa97423980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff70a0416ef1eed4ca4968378d46f9a9"><td class="memItemLeft" align="right" valign="top">std::string::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aff70a0416ef1eed4ca4968378d46f9a9">longestLength</a> (const std::vector&lt; std::string &gt; &amp;vec) noexcept</td></tr>
<tr class="memdesc:aff70a0416ef1eed4ca4968378d46f9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the longest string in a vector.  <a href="namespacestr.html#aff70a0416ef1eed4ca4968378d46f9a9">More...</a><br /></td></tr>
<tr class="separator:aff70a0416ef1eed4ca4968378d46f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e68ca74959c47dae8d126c8a9db5717"><td class="memTemplParams" colspan="2">template&lt;template&lt; class, class &gt; class cont_type&gt; </td></tr>
<tr class="memitem:a1e68ca74959c47dae8d126c8a9db5717"><td class="memTemplItemLeft" align="right" valign="top">static std::string::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a1e68ca74959c47dae8d126c8a9db5717">longestLength</a> (const cont_type&lt; std::string, std::allocator&lt; std::string &gt;&gt; &amp;container) noexcept</td></tr>
<tr class="separator:a1e68ca74959c47dae8d126c8a9db5717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bf9f8189aea4146e003477d8b7a62d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a26bf9f8189aea4146e003477d8b7a62d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">pos_valid</a> (const T &amp;pos) noexcept</td></tr>
<tr class="memdesc:a26bf9f8189aea4146e003477d8b7a62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply checks the given position value against std::string::npos.  <a href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">More...</a><br /></td></tr>
<tr class="separator:a26bf9f8189aea4146e003477d8b7a62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac833e4f5138a5dd64fb8985361215835"><td class="memTemplParams" colspan="2">template&lt;std::integral RT, template&lt; class, class &gt; class Cont&gt; </td></tr>
<tr class="memitem:ac833e4f5138a5dd64fb8985361215835"><td class="memTemplItemLeft" align="right" valign="top">RT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#ac833e4f5138a5dd64fb8985361215835">get_longest_string</a> (const Cont&lt; std::string, std::allocator&lt; std::string &gt;&gt; &amp;cont, RT offset=static_cast&lt; RT &gt;(0))</td></tr>
<tr class="memdesc:ac833e4f5138a5dd64fb8985361215835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the length of the longest string in a given STL container.  <a href="namespacestr.html#ac833e4f5138a5dd64fb8985361215835">More...</a><br /></td></tr>
<tr class="separator:ac833e4f5138a5dd64fb8985361215835"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abea510ab5719c607e5a2ce61bde9e03e"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:abea510ab5719c607e5a2ce61bde9e03e"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">ConvertibleStringT</a> = std::constructible_from&lt;std::string, T...&gt;</td></tr>
<tr class="memdesc:abea510ab5719c607e5a2ce61bde9e03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows types that are constructor-convertible to std::string.  <a href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">More...</a><br /></td></tr>
<tr class="separator:abea510ab5719c607e5a2ce61bde9e03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains various string manipulation, conversion, and parsing functions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a576148d382d024fc11d46dc0ef839cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576148d382d024fc11d46dc0ef839cec">&#9670;&nbsp;</a></span>VIndent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacestr.html#a576148d382d024fc11d46dc0ef839cec">str::VIndent</a> = typedef <a class="el" href="structstr_1_1_variable_indentation.html">VariableIndentation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00322">322</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a61c9108691e6d984499341518c993787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c9108691e6d984499341518c993787">&#9670;&nbsp;</a></span>align_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::align_center </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>setw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Centers a string in the specified number of characters by addings spaces on either side. </p>
<p>@function align_center(string&amp;, unsigned int) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Input String, must be shorter in length than param setw. </td></tr>
    <tr><td class="paramname">setw</td><td>- Number of characters in the returned string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00133">133</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a82f6e6378f1869b65cce94f28f31d665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f6e6378f1869b65cce94f28f31d665">&#9670;&nbsp;</a></span>apply_to_each()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void str::apply_to_each </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::function&lt; int(int)&gt;, std::allocator&lt; std::function&lt; int(int)&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>funclist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a given list of functions to each character in a given string. </p>
<p>@function apply_to_each(string&amp;, ) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String ref to modify </td></tr>
    <tr><td class="paramname">funclist</td><td>- List of functions to apply </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00301">301</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a11fa2dd079f3b6ebd63eaffb030e980c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fa2dd079f3b6ebd63eaffb030e980c">&#9670;&nbsp;</a></span>bool_to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::bool_to_string </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>first_upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a boolean to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Target boolean to convert. </td></tr>
    <tr><td class="paramname">first_upper</td><td>When true, returns a string where the first letter is uppercase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00145">145</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="ab58e4fd600a73d4ffbdea3d65c5bdabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58e4fd600a73d4ffbdea3d65c5bdabd">&#9670;&nbsp;</a></span>compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::valid_string_or_convertible T, class Pred , var::valid_string_or_convertible... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T str::compare </td>
          <td>(</td>
          <td class="paramtype">const Pred &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>strings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00131">131</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="acd4ee543bc885f863faf20217f7142fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4ee543bc885f863faf20217f7142fe">&#9670;&nbsp;</a></span>compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> std::convertible_to&lt;T1, std::string&gt;&amp;&amp; static std::convertible_to&lt;T2, std::string&gt; bool str::compare </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>case_sensitive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare 2 strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>- Convertible to string type. </td></tr>
    <tr><td class="paramname">T2</td><td>- Convertible to string type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- Comparison target 1 </td></tr>
    <tr><td class="paramname">right</td><td>- Comparison target 2 </td></tr>
    <tr><td class="paramname">case_sensitive</td><td>- When false, both strings are first converted to lowercase, then compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00230">230</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a38d0037316e84612973026c052ec0616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d0037316e84612973026c052ec0616">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string str::concat </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate any number of string/char* types into a single string. </p>
<p>@function concat(T&amp;&amp;...) </p><ul>
<li>...T - Variadic String Types <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- An arbitrary number of strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00116">116</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a0f7141b95490d6fff216bb4dc520831d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7141b95490d6fff216bb4dc520831d">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool str::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a given string exists within another string. </p>
<p>@function contains(char) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to search in </td></tr>
    <tr><td class="paramname">ch</td><td>- Char to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00485">485</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a0ca8ec530dc360aeabadf2aa97423980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca8ec530dc360aeabadf2aa97423980">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool str::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if any of a list of delimiters is present in a given string. </p>
<p>@function contains(char) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to search in </td></tr>
    <tr><td class="paramname">delims</td><td>- String of delimiters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - ( true = At least one delimiter was found ) ( false = None of the given delimiters exist in the string ) </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00497">497</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ad2842f64da212ac392e6c3385eb54a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2842f64da212ac392e6c3385eb54a3e">&#9670;&nbsp;</a></span>extractAllStrings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::tuple&lt;std::string, std::string, std::string&gt; &gt; str::extractAllStrings </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; const char, const char &gt;&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeDelim</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 3 substr, the first being the string until the first delim, the second being between the given delims, and the 3rd being the remaining string after the second delim. </p>
<p>@function extractString(string&amp;, pair&lt;char, char&gt;, bool, bool) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- The string to extract from. </td></tr>
    <tr><td class="paramname">delim</td><td>- ( first = opening delim ) ( second = closing delim ) </td></tr>
    <tr><td class="paramname">forward</td><td>- ( true = forward search ) ( false = reverse search ) </td></tr>
    <tr><td class="paramname">includeDelim</td><td>- (Default: false) When true, the returned string will contain first &amp; last delims. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;tuple&lt;string, string, string&gt;&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00467">467</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a93442c940874127d76612c31be16f7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93442c940874127d76612c31be16f7a7">&#9670;&nbsp;</a></span>extractString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; str::extractString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; const char, const char &gt;&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring from the first appearance of a given delimiter to the last. </p>
<p>@function extractString(string&amp;, pair&lt;char, char&gt;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- The string to extract from. </td></tr>
    <tr><td class="paramname">delim</td><td>- ( first = opening delim ) ( second = closing delim ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00431">431</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a2b36762bf1fb176cef1f3ab327ff2da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b36762bf1fb176cef1f3ab327ff2da6">&#9670;&nbsp;</a></span>extractString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; str::extractString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::string, std::string &gt;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeDelim</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring from the first appearance of a pair of delimiters, if no delimiter is found, uses the beginning/end of the given str. </p>
<p>@function extractString(string&amp;, pair&lt;char, char&gt;, bool, bool) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- The string to extract from. </td></tr>
    <tr><td class="paramname">delims</td><td>- ( first = opening delim ) ( second = closing delim ) </td></tr>
    <tr><td class="paramname">includeDelim</td><td>- (Default: false) When true, the returned string will contain first &amp; last delims. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00390">390</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a3e72dddafe6ddd37de81a5368ad75f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e72dddafe6ddd37de81a5368ad75f0e">&#9670;&nbsp;</a></span>extractString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; str::extractString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeDelim</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a contiguous substring from the first/last 2 appearances of the given delims. </p>
<p>@function extractString(string&amp;, char, char, bool, bool) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- The string to extract from. </td></tr>
    <tr><td class="paramname">delims</td><td>- String of delims used to determine the open/close delim </td></tr>
    <tr><td class="paramname">includeDelim</td><td>- (Default: false) When true, the returned string will contain first &amp; last delims. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00419">419</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="af3d243724dffd234a19646d7c7b13553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d243724dffd234a19646d7c7b13553">&#9670;&nbsp;</a></span>extractStringUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; str::extractStringUntil </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>begin</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substr between the beginning/end of a given string and the first occurrence of a given delimiter. </p>
<p>@function extractStringUntil(string&amp;, char) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- The string to extract from </td></tr>
    <tr><td class="paramname">delim</td><td>- Character used to determine the end of the substr </td></tr>
    <tr><td class="paramname">begin</td><td>- (Default: true) When true, extracts from the start of the string, else the back. </td></tr>
    <tr><td class="paramname">reverse</td><td>- (Default: false) When true, searches for the delim from the opposite side first </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00449">449</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="acd8f258dcf725866036392dc253eb48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8f258dcf725866036392dc253eb48d">&#9670;&nbsp;</a></span>find_any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string::iterator str::find_any </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00062">62</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a93d96ab238bb0666c844c65b60303dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d96ab238bb0666c844c65b60303dbd">&#9670;&nbsp;</a></span>find_any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string::iterator str::find_any </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string::iterator &amp;&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find any of a given set of delimiters in a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ln</td><td>- String to search. </td></tr>
    <tr><td class="paramname">dels</td><td>- Delimiters to search for. </td></tr>
    <tr><td class="paramname">off</td><td>- Position to begin searching at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string::iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00058">58</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ac833e4f5138a5dd64fb8985361215835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac833e4f5138a5dd64fb8985361215835">&#9670;&nbsp;</a></span>get_longest_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral RT, template&lt; class, class &gt; class Cont&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RT str::get_longest_string </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; std::string, std::allocator&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT&#160;</td>
          <td class="paramname"><em>offset</em> = <code>static_cast&lt;RT&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the length of the longest string in a given STL container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RT</td><td>- Return Type. Must be an integral value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>- Container to check. </td></tr>
    <tr><td class="paramname">offset</td><td>- Add this number to the returned value. Including this allows template auto-deduction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RT </dd></dl>

<p class="definition">Definition at line <a class="el" href="strutility_8hpp_source.html#l00055">55</a> of file <a class="el" href="strutility_8hpp_source.html">strutility.hpp</a>.</p>

</div>
</div>
<a id="af632b5ef496a88eb6c6a50ee18385c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af632b5ef496a88eb6c6a50ee18385c62">&#9670;&nbsp;</a></span>getline()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch , class Tr , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;Ch, Tr&gt;&amp; str::getline </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative std::getline that accepts a string of delimiters rather than a single char. </p>
<p>@function getline(basic_istream&lt;Ch, Tr&gt;&amp;, basic_string&lt;Ch, Tr, A&gt;&amp;, string&amp;) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ch</td><td>- Char Type </td></tr>
    <tr><td class="paramname">Tr</td><td>- Char Traits </td></tr>
    <tr><td class="paramname">A</td><td>- Allocator Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>- Input Stream </td></tr>
    <tr><td class="paramname">str</td><td>- Output String </td></tr>
    <tr><td class="paramname">delims</td><td>- String of Delimiters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basic_istream&lt;Ch, Tr&gt;&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00210">210</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="aea95d9955d4eaf233668351a309059db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea95d9955d4eaf233668351a309059db">&#9670;&nbsp;</a></span>getline_pred()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch , class Tr , class A , class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;Ch, Tr&gt;&amp; str::getline_pred </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative std::getline that accepts a predicate function rather than a char delimiter. </p>
<p>@function getline(basic_istream&lt;Ch, Tr&gt;&amp;, basic_string&lt;Ch, Tr, A&gt;&amp;, Pred) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ch</td><td>- Char Type </td></tr>
    <tr><td class="paramname">Tr</td><td>- Char Traits </td></tr>
    <tr><td class="paramname">A</td><td>- Allocator type </td></tr>
    <tr><td class="paramname">Pred</td><td>- Predicate type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>- Input stream </td></tr>
    <tr><td class="paramname">str</td><td>- Output string </td></tr>
    <tr><td class="paramname">p</td><td>- Predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basic_istream&lt;Ch, Tr&gt;&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00175">175</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a2665afb44cc6e90ff1e922639ea0e528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2665afb44cc6e90ff1e922639ea0e528">&#9670;&nbsp;</a></span>getStreamLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream::pos_type str::getStreamLength </td>
          <td>(</td>
          <td class="paramtype">std::stringstream &amp;&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of a given stringstream. </p>
<p>@function getLength(stringstream) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>- Ref to target stringstream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stringstream::pos_type </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00371">371</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="af0d5f5ddec852ee6650d85fcd45c3030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d5f5ddec852ee6650d85fcd45c3030">&#9670;&nbsp;</a></span>longest() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool index, var::valid_string T, template&lt; class... &gt; class Cont&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Cont&lt;std::pair&lt;T, T&gt;, std::allocator&lt;std::pair&lt;T, T&gt; &gt; &gt;::const_iterator str::longest </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; std::pair&lt; T, T &gt;, std::allocator&lt; std::pair&lt; T, T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00164">164</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a718e93d72455a6f9af50cca592378f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718e93d72455a6f9af50cca592378f99">&#9670;&nbsp;</a></span>longest() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t index, var::valid_string... Ts, template&lt; class... &gt; class Cont&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Cont&lt;std::tuple&lt;Ts...&gt;, std::allocator&lt;std::tuple&lt;Ts...&gt; &gt; &gt;::const_iterator str::longest </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the longest string in a container of string tuples. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index</td><td>Which index to call std::get on each time. Ex: 0 will compare the first string in each tuple. </td></tr>
    <tr><td class="paramname">...vT</td><td>Variadic type contained by the tuple. </td></tr>
    <tr><td class="paramname">Cont</td><td>Container type containing std::tuples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cont::const_iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00191">191</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="aab273e18c3896683954b42ea222129f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab273e18c3896683954b42ea222129f4">&#9670;&nbsp;</a></span>longest() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::valid_string T, template&lt; class, class &gt; class Cont&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Cont&lt;T, std::allocator&lt;T&gt; &gt;::const_iterator str::longest </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; T, std::allocator&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00145">145</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a4e29c1c2f11c9fdba7e76bb2e3327c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e29c1c2f11c9fdba7e76bb2e3327c4b">&#9670;&nbsp;</a></span>longest() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::valid_string_or_convertible T, var::valid_string_or_convertible... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T str::longest </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>strings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00140">140</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a1e68ca74959c47dae8d126c8a9db5717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e68ca74959c47dae8d126c8a9db5717">&#9670;&nbsp;</a></span>longestLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class, class &gt; class cont_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string::size_type str::longestLength </td>
          <td>(</td>
          <td class="paramtype">const cont_type&lt; std::string, std::allocator&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00518">518</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="aff70a0416ef1eed4ca4968378d46f9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff70a0416ef1eed4ca4968378d46f9a9">&#9670;&nbsp;</a></span>longestLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string::size_type str::longestLength </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the longest string in a vector. </p>
<p>@function longestLength(vector&lt;string&gt;&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>- A vector of strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string::size_type </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00509">509</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a5247d873952449905ce03aca93e5661d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5247d873952449905ce03aca93e5661d">&#9670;&nbsp;</a></span>NumberGrouping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; str::NumberGrouping </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatically insert commas between thousands when printing numbers. <br  />
 Example: "1000000" =&gt; "1,000,000". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>- (implicit) Target Output Stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strlocale_8hpp_source.html#l00120">120</a> of file <a class="el" href="strlocale_8hpp_source.html">strlocale.hpp</a>.</p>

</div>
</div>
<a id="a68189011dff0dc860136f8606606169c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68189011dff0dc860136f8606606169c">&#9670;&nbsp;</a></span>optional_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;size_t&gt; str::optional_find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::string::find function that returns an optional instead of std::string::npos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to search within. </td></tr>
    <tr><td class="paramname">search</td><td>- Character(s) to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;size_t&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00279">279</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a01ad677b200aa91ac5ff1b6eda8b8ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ad677b200aa91ac5ff1b6eda8b8ea2">&#9670;&nbsp;</a></span>parseWithDelim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class, class &gt; class ContType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt; str::parseWithDelim </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delim</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; ContType&lt; std::function&lt; int(int)&gt;, std::allocator&lt; std::function&lt; int(int)&gt;&gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>remove_if</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a given string with a given delimiter, and return a vector of strings. </p>
<p>@function parseWithDelim(string&amp;, char, optional&lt;vector&lt;function&lt;int(int)&gt;&gt;&gt;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to parse </td></tr>
    <tr><td class="paramname">delim</td><td>- Delimiter to split string with </td></tr>
    <tr><td class="paramname">remove_if</td><td>- (Default: nullopt) When defined, applies the erase-remove idiom with the given functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00319">319</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a26bde2717215ef2e746a382003a8fc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bde2717215ef2e746a382003a8fc58">&#9670;&nbsp;</a></span>Placeholder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; str::Placeholder </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placeholder function that does nothing. Intended for use in ternary expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>- Target Output Stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strlocale_8hpp_source.html#l00109">109</a> of file <a class="el" href="strlocale_8hpp_source.html">strlocale.hpp</a>.</p>

</div>
</div>
<a id="a26bf9f8189aea4146e003477d8b7a62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bf9f8189aea4146e003477d8b7a62d">&#9670;&nbsp;</a></span>pos_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool str::pos_valid </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simply checks the given position value against std::string::npos. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Position value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- Position to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <br  />
 true - The given position is NOT equal to std::string::npos <br  />
 false - The given position is equal to std::string::npos, and is invalid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="strutility_8hpp_source.html#l00041">41</a> of file <a class="el" href="strutility_8hpp_source.html">strutility.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a26bf9f8189aea4146e003477d8b7a62d_icgraph.svg" width="478" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a16f757b5761b656d6ce1d15aee26507c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f757b5761b656d6ce1d15aee26507c">&#9670;&nbsp;</a></span>remove_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::remove_all </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all occurrences of a given list of delimiters from a given string. </p>
<p>@function remove_all(string&amp;, string&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to remove delimiters from. </td></tr>
    <tr><td class="paramname">delims</td><td>- Delimiter list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00285">285</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a30c7ac3d05115fd618a8779045def1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c7ac3d05115fd618a8779045def1c7">&#9670;&nbsp;</a></span>remove_all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string str::remove_all_of </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline wrapper for the erase-remove idiom that accepts a lambda predicate. </p>
<p>@function remove_all_of(string, F) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Input string. </td></tr>
    <tr><td class="paramname">pred</td><td>- Valid predicate functions for std::remove_if. (Accepts 1 int/char, returns 1 int/char). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00276">276</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ad1d6dd0849bbc57ab6970682bf0f8078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d6dd0849bbc57ab6970682bf0f8078">&#9670;&nbsp;</a></span>remove_whitespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::remove_whitespace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline wrapper for the erase-remove idiom that removes spaces. </p>
<p>@function remove_whitespace(string) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Pass-by-value string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00153">153</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ad35ece5b07dfe3a18235ccc6c0f563ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35ece5b07dfe3a18235ccc6c0f563ba">&#9670;&nbsp;</a></span>requires()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... VT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">str::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...&#160;</td>
          <td class="paramname">VT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00286">286</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a14c6dc2d1ec575eb4f211b202f1baec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c6dc2d1ec575eb4f211b202f1baec0">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::reverse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00023">23</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ace29034bfe12d695cf5aea81e33d4561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace29034bfe12d695cf5aea81e33d4561">&#9670;&nbsp;</a></span>rsplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> const std::pair&lt;std::string, std::string&gt; str::rsplit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0ull</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into a pair of strings by finding the first occurrence of a given delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String to Split. </td></tr>
    <tr><td class="paramname">delim</td><td>Delimiter to search for. The delimiter is discarded from the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::string, std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00357">357</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="aba157b4f80912e0c19b9ad7676d2c8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba157b4f80912e0c19b9ad7676d2c8d1">&#9670;&nbsp;</a></span>sanitize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string str::sanitize </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sanitize a string with a single predicate function. This is called by <a class="el" href="namespacestr.html#a30c7ac3d05115fd618a8779045def1c7" title="Inline wrapper for the erase-remove idiom that accepts a lambda predicate.">remove_all_of()</a>. </p>
<p>@function sanitize(string, F) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- Type returned by predicate function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Input string. </td></tr>
    <tr><td class="paramname">pred</td><td>- Input predicate function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00260">260</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a5890626349406d682c75bf7cded557d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5890626349406d682c75bf7cded557d0">&#9670;&nbsp;</a></span>shortest() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool index, var::valid_string T, template&lt; class... &gt; class Cont&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Cont&lt;std::pair&lt;T, T&gt;, std::allocator&lt;std::pair&lt;T, T&gt; &gt; &gt;::const_iterator str::shortest </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; std::pair&lt; T, T &gt;, std::allocator&lt; std::pair&lt; T, T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00173">173</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a58590dd003d9759582ee1de6d1b6dc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58590dd003d9759582ee1de6d1b6dc9f">&#9670;&nbsp;</a></span>shortest() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t index, var::valid_string... Ts, template&lt; class... &gt; class Cont&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Cont&lt;std::tuple&lt;Ts...&gt;, std::allocator&lt;std::tuple&lt;Ts...&gt; &gt; &gt;::const_iterator str::shortest </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the shortest string in a container of string tuples. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index</td><td>Which index to call std::get on each time. Ex: 0 will compare the first string in each tuple. </td></tr>
    <tr><td class="paramname">...vT</td><td>Variadic type contained by the tuple. </td></tr>
    <tr><td class="paramname">Cont</td><td>Container type containing std::tuples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cont::const_iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00209">209</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a0377cd612795f7313947f6b43910b032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0377cd612795f7313947f6b43910b032">&#9670;&nbsp;</a></span>shortest() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::valid_string T, template&lt; class, class &gt; class Cont&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Cont&lt;T, std::allocator&lt;T&gt; &gt;::const_iterator str::shortest </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; T, std::allocator&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00154">154</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a87c41dd852c1db4ba8b8f1d28e4728b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c41dd852c1db4ba8b8f1d28e4728b5">&#9670;&nbsp;</a></span>shortest() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::valid_string_or_convertible T, var::valid_string_or_convertible... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T str::shortest </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>strings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00142">142</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a63f5017167eb58048dd646654c5943cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f5017167eb58048dd646654c5943cc">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> const std::pair&lt;std::string, std::string&gt; str::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0ull</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into a pair of strings by finding the first occurrence of a given delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String to Split. </td></tr>
    <tr><td class="paramname">delim</td><td>Delimiter to search for. The delimiter is discarded from the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::string, std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00342">342</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a62a9fd532000619ae079e65046214a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a9fd532000619ae079e65046214a5e">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> const std::pair&lt;std::string, std::string&gt; str::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>discard_pos</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into a pair of strings by position. This is a simple wrapper to return a string split operation as a pair of strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String to Split. </td></tr>
    <tr><td class="paramname">pos</td><td>Position in the string to split. </td></tr>
    <tr><td class="paramname">discard_pos</td><td>When true, the character at the given position is discarded, otherwise the character is the first character of the second return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::string, std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00331">331</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="aa4bf5f1b14b776ed8c1225f5c2870a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bf5f1b14b776ed8c1225f5c2870a92">&#9670;&nbsp;</a></span>split_by_words()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; str::split_by_words </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a given string into a vector of strings, with one word per index. </p>
<p>@function split_by_words(string&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- Input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00241">241</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a5bac9088e59d818dfcb958ca9fc1c673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bac9088e59d818dfcb958ca9fc1c673">&#9670;&nbsp;</a></span>split_to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;CharT&gt; str::split_to_vector </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, std::allocator&lt; CharT &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into a vector of characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character Type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character Traits </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;CharT&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00041">41</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a991544f9c8b8f65720a0c7994b216bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991544f9c8b8f65720a0c7994b216bd4">&#9670;&nbsp;</a></span>streamify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable... VT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::stringstream str::streamify </td>
          <td>(</td>
          <td class="paramtype">VT...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a stringstream, inserts all of the given arguments, then move-returns the resulting stringstream. </p>
<p>disable "use of a moved from object 'buffer'", speed comparison testing shows a major performance increase when using return-move() for these functions. (~300000ns) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...VT</td><td>- Variadic Templated Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>- Arguments to insert into the stream, in order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::stringstream </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00067">67</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a29b3be3bdfe64e47f3652175fa46e0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b3be3bdfe64e47f3652175fa46e0d5">&#9670;&nbsp;</a></span>string_to_bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType  = std::optional&lt;bool&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> std::same_as&lt;ReturnType, bool&gt; std::same_as&lt;ReturnType, std::optional&lt;bool&gt; &gt; ReturnType str::string_to_bool </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to a boolean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert to boolean. Must contain ONLY the words "true" or "false". (case-insensitive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;bool&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00158">158</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="a670a97b2121a31298814cb8e4a5d13ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670a97b2121a31298814cb8e4a5d13ff">&#9670;&nbsp;</a></span>stringify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable... VT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static const std::string str::stringify </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the stringstream's str() function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...VT</td><td>- Variadic Templated Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>- Arguments to insert into the stream, in order. Nearly anything can be included here, so long as it has an operator&lt;&lt; stream insertion operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00081">81</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a76cdfa929c2dbd674745f23f30f4f9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cdfa929c2dbd674745f23f30f4f9f4">&#9670;&nbsp;</a></span>stringify_container()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class, class &gt; class ContainerT, class ElemT , var::Streamable... VT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> constexpr static std::convertible_to&lt;ElemT, std::string&gt; const std::string str::stringify_container </td>
          <td>(</td>
          <td class="paramtype">const ContainerT&lt; ElemT, std::allocator&lt; ElemT &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT...&#160;</td>
          <td class="paramname"><em>separators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacestr.html#a670a97b2121a31298814cb8e4a5d13ff" title="Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the ...">stringify()</a> variant that accepts a vector of elements instead of variadic arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>- Container Type. Accepts most STL containers that hold a single type, such as: std::vector, std::set, etc. </td></tr>
    <tr><td class="paramname">ElemT</td><td>- Templated Element Type. Must be compatible with ostream::operator&lt;&lt;. </td></tr>
    <tr><td class="paramname">...VT</td><td>- Variadic Templated Separators. These are inserted in order between every element in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>- Input Container. Element type must have an overload for operator&lt;&lt; to allow insertion into an ostream. </td></tr>
    <tr><td class="paramname">...separators</td><td>- Any number of separators. These are inserted in order between every element. This can be used to apply formatting, insert spaces, or anything else. Note that separators are only inserted BETWEEN elements, and will never be trailing! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00100">100</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="ae44a61b1fed1e226ac26abe03d69adab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44a61b1fed1e226ac26abe03d69adab">&#9670;&nbsp;</a></span>stringify_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DelimType , var::Streamable... VT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static const std::vector&lt;std::string&gt; str::stringify_split </td>
          <td>(</td>
          <td class="paramtype">const DelimType &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a temporary stringstream and inserts all of the given arguments in sequential order, then uses the given delimiter to split the resulting string into a vector of strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DelimType</td><td>- Input Delimiter Type </td></tr>
    <tr><td class="paramname">...VT</td><td>- Variadic Templated Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- Delimiter to use when splitting the result. </td></tr>
    <tr><td class="paramname">...args</td><td>- Arguments to insert into the stream in sequential order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00120">120</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a7346dfeb6d8d2d04a563649f4bf3cbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7346dfeb6d8d2d04a563649f4bf3cbca">&#9670;&nbsp;</a></span>strip_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::strip_line </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment_chars</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>whitespace_chars</em> = <code>&quot;&#160;\t\r\n\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes comments and preceeding/trailing whitespace from a given string. </p>
<p>@function strip_line(std::string, const Param&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Input string. </td></tr>
    <tr><td class="paramname">comment_chars</td><td>- Characters that should be treated as line comments, everything that appears after one of these characters is removed. </td></tr>
    <tr><td class="paramname">whitespace_chars</td><td>- Characters that should be treated as whitespace, trailing/preceeding whitespace is removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00075">75</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a41372d1cf755e2aa10b286aa5cc7e5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41372d1cf755e2aa10b286aa5cc7e5b1">&#9670;&nbsp;</a></span>strip_line_multiCharComment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::strip_line_multiCharComment </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>comment_del</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>whitespace_chars</em> = <code>&quot;&#160;\t\r\n\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes more complex comments ( ex. C/JSON/html comments ) and preceeding/trailing whitespace from a given string. </p>
<p>@function strip_line(std::string, const Param&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Input string. </td></tr>
    <tr><td class="paramname">comment_del</td><td>- String that should be treated as a comment. </td></tr>
    <tr><td class="paramname">whitespace_chars</td><td>- Characters that should be treated as whitespace, trailing/preceeding whitespace is removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00095">95</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a16fdfbc25414c557d8a7438d47fc71c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fdfbc25414c557d8a7438d47fc71c4">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestr.html#ad35ece5b07dfe3a18235ccc6c0f563ba">requires</a> std::floating_point&lt;T&gt; <a class="el" href="sysarch_8h.html#acaa06fbc27c59926a41e7575667e5280">CONSTEXPR</a> const std::string str::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::streamsize &amp;&#160;</td>
          <td class="paramname"><em>precision</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force_decimal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a floating-point to a string in standard notation, with a specified amount of precision. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating Point Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Target double to convert. </td></tr>
    <tr><td class="paramname">precision</td><td>Number of digits after the decimal point to include. </td></tr>
    <tr><td class="paramname">force_decimal</td><td>When true, always includes the decimal point even when there are no significant digits following it. (Ex: true:"1.0" | false:"1") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00119">119</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a16fdfbc25414c557d8a7438d47fc71c4_icgraph.svg" width="490" height="227"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae2bfcfb51a1c131387fd6d08629aba53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bfcfb51a1c131387fd6d08629aba53">&#9670;&nbsp;</a></span>tolower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sysarch_8h.html#acaa06fbc27c59926a41e7575667e5280">CONSTEXPR</a> char str::tolower </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a character to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- Char to convert. If the character is not an uppercase letter, it will be returned unmodified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00024">24</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="a8981700b8e845f34864ace4d4ddfcf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8981700b8e845f34864ace4d4ddfcf25">&#9670;&nbsp;</a></span>tolower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> const std::string str::tolower </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a convertible-character to lowercase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type that is convertible to char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- Value to convert. If the value does not resolve to an uppercase letter, it will be returned as a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char</dd></dl>
<p>Convert a whole string to lowercase. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00056">56</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a8981700b8e845f34864ace4d4ddfcf25_icgraph.svg" width="282" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a88947ca78984e05f41dd36fb221d32d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88947ca78984e05f41dd36fb221d32d6">&#9670;&nbsp;</a></span>toMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; str::toMap </td>
          <td>(</td>
          <td class="paramtype">std::stringstream &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>lineDelim</em> = <code>'\n'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>noSpace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a stringstream to a map of string keys &amp; string vars. </p>
<p>@function toMap(stringstream&amp;, string&amp;, char) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- Stringstream ref </td></tr>
    <tr><td class="paramname">delims</td><td>- String containing delimiter chars </td></tr>
    <tr><td class="paramname">lineDelim</td><td>- (Default: '\n') Character to use as delimiter between map entries </td></tr>
    <tr><td class="paramname">noSpace</td><td>- (Default: true) When true, removes all whitespace after parsing each value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map&lt;string, string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00355">355</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="aae017529a0116f69b6d0edf9d9ea7f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae017529a0116f69b6d0edf9d9ea7f96">&#9670;&nbsp;</a></span>toupper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sysarch_8h.html#acaa06fbc27c59926a41e7575667e5280">CONSTEXPR</a> char str::toupper </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a character to uppercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- Char to convert. If the character is not a lowercase letter, it will be returned unmodified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00069">69</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="aa8dbbdf96e49e575d8b322ef8880f2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dbbdf96e49e575d8b322ef8880f2f1">&#9670;&nbsp;</a></span>toupper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sysarch_8h.html#a2fbf9b2640da245c6473f91b18781960">WINCONSTEXPR</a> const std::string str::toupper </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a convertible-character to uppercase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type that is convertible to char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- Value to convert. If the value does not resolve to a lowercase letter, it will be returned as a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char</dd></dl>
<p>Convert a whole string to lowercase. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00101">101</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_aa8dbbdf96e49e575d8b322ef8880f2f1_icgraph.svg" width="280" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9f9a7cdc58ff315c0dbdb4793171918f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9a7cdc58ff315c0dbdb4793171918f">&#9670;&nbsp;</a></span>toVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; str::toVector </td>
          <td>(</td>
          <td class="paramtype">std::stringstream&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; char &gt;&#160;</td>
          <td class="paramname"><em>delim</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a stringstream to a vector of strings, where each string contains one line from the stream. </p>
<p>@function toVector(stringstream&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- Stringstream ref to convert. </td></tr>
    <tr><td class="paramname">delim</td><td>- Optional char delimiter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00339">339</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abea510ab5719c607e5a2ce61bde9e03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea510ab5719c607e5a2ce61bde9e03e">&#9670;&nbsp;</a></span>ConvertibleStringT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept str::ConvertibleStringT = std::constructible_from&lt;std::string, T...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows types that are constructor-convertible to std::string. </p>
<p>@concept ConvertibleStringT </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Input Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00242">242</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacestr.html">str</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
