<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>307Lib: str Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gear-2.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">307Lib
   </div>
   <div id="projectbrief">C++ Libraries made by radj307</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacestr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">str Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains various string manipulation, conversion, and parsing functions.  
<a href="namespacestr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstr_1_1_floating_base.html">FloatingBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstr_1_1_printable.html">Printable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic wrapper for any number of any types. Allows functions to return an inline-printable value so the function can be used in an output stream operator&lt;&lt; statement.  <a href="structstr_1_1_printable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstr_1_1_set_locale.html">SetLocale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the locale of a stream. If you want to apply a locale Facet, use struct SetLocaleFacet&lt;&gt; instead.  <a href="structstr_1_1_set_locale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstr_1_1_set_locale_facet.html">SetLocaleFacet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the locale of an iostream, and set a Facet at the same time.  <a href="structstr_1_1_set_locale_facet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae18803e8fa7864102754552a83b08887"><td class="memItemLeft" align="right" valign="top"><a id="ae18803e8fa7864102754552a83b08887"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>decimal</b> = long long</td></tr>
<tr class="separator:ae18803e8fa7864102754552a83b08887"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a026f55497d251c5acccef7dd42148138"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a026f55497d251c5acccef7dd42148138">align_center</a> (const std::string_view &amp;str, const unsigned int setw)</td></tr>
<tr class="memdesc:a026f55497d251c5acccef7dd42148138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centers a string in the specified number of characters by addings spaces on either side.  <a href="namespacestr.html#a026f55497d251c5acccef7dd42148138">More...</a><br /></td></tr>
<tr class="separator:a026f55497d251c5acccef7dd42148138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f6e6378f1869b65cce94f28f31d665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a82f6e6378f1869b65cce94f28f31d665">apply_to_each</a> (std::string &amp;str, const std::vector&lt; std::function&lt; int(int)&gt;, std::allocator&lt; std::function&lt; int(int)&gt;&gt;&gt; &amp;funclist) noexcept</td></tr>
<tr class="memdesc:a82f6e6378f1869b65cce94f28f31d665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a given list of functions to each character in a given string.  <a href="namespacestr.html#a82f6e6378f1869b65cce94f28f31d665">More...</a><br /></td></tr>
<tr class="separator:a82f6e6378f1869b65cce94f28f31d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f82a58e884afa2d7f6dcbe3ad884bab"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a1f82a58e884afa2d7f6dcbe3ad884bab">binaryToDecimal</a> (const std::string &amp;binary) noexcept(false)</td></tr>
<tr class="memdesc:a1f82a58e884afa2d7f6dcbe3ad884bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a binary number to its decimal equivalent.  <a href="namespacestr.html#a1f82a58e884afa2d7f6dcbe3ad884bab">More...</a><br /></td></tr>
<tr class="separator:a1f82a58e884afa2d7f6dcbe3ad884bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58e4fd600a73d4ffbdea3d65c5bdabd"><td class="memTemplParams" colspan="2"><a id="ab58e4fd600a73d4ffbdea3d65c5bdabd"></a>
template&lt;var::valid_string_or_convertible T, class Pred , var::valid_string_or_convertible... Ts&gt; </td></tr>
<tr class="memitem:ab58e4fd600a73d4ffbdea3d65c5bdabd"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compare</b> (const Pred &amp;predicate, const T &amp;fst, const Ts &amp;... strings)</td></tr>
<tr class="separator:ab58e4fd600a73d4ffbdea3d65c5bdabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4ee543bc885f863faf20217f7142fe"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:acd4ee543bc885f863faf20217f7142fe"><td class="memTemplItemLeft" align="right" valign="top">requires std::convertible_to&lt; T1, std::string &gt; &amp;&amp;static std::convertible_to&lt; T2, std::string &gt; bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#acd4ee543bc885f863faf20217f7142fe">compare</a> (T1 left, T2 right, const bool case_sensitive=true)</td></tr>
<tr class="memdesc:acd4ee543bc885f863faf20217f7142fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare 2 strings.  <a href="namespacestr.html#acd4ee543bc885f863faf20217f7142fe">More...</a><br /></td></tr>
<tr class="separator:acd4ee543bc885f863faf20217f7142fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d0037316e84612973026c052ec0616"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a38d0037316e84612973026c052ec0616"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a38d0037316e84612973026c052ec0616">concat</a> (T &amp;&amp;... str)</td></tr>
<tr class="memdesc:a38d0037316e84612973026c052ec0616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate any number of string/char* types into a single string.  <a href="namespacestr.html#a38d0037316e84612973026c052ec0616">More...</a><br /></td></tr>
<tr class="separator:a38d0037316e84612973026c052ec0616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7141b95490d6fff216bb4dc520831d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a0f7141b95490d6fff216bb4dc520831d">contains</a> (const std::string &amp;str, const char ch) noexcept</td></tr>
<tr class="memdesc:a0f7141b95490d6fff216bb4dc520831d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given string exists within another string.  <a href="namespacestr.html#a0f7141b95490d6fff216bb4dc520831d">More...</a><br /></td></tr>
<tr class="separator:a0f7141b95490d6fff216bb4dc520831d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca8ec530dc360aeabadf2aa97423980"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a0ca8ec530dc360aeabadf2aa97423980">contains</a> (const std::string &amp;str, const std::string &amp;delims) noexcept</td></tr>
<tr class="memdesc:a0ca8ec530dc360aeabadf2aa97423980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any of a list of delimiters is present in a given string.  <a href="namespacestr.html#a0ca8ec530dc360aeabadf2aa97423980">More...</a><br /></td></tr>
<tr class="separator:a0ca8ec530dc360aeabadf2aa97423980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8c67ed7c199414fca456eef77b60e7"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a8a8c67ed7c199414fca456eef77b60e7">count</a> (std::stringstream &amp;ss, char delim)</td></tr>
<tr class="memdesc:a8a8c67ed7c199414fca456eef77b60e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of delimiters that occur within a given stringstream.  <a href="namespacestr.html#a8a8c67ed7c199414fca456eef77b60e7">More...</a><br /></td></tr>
<tr class="separator:a8a8c67ed7c199414fca456eef77b60e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4713722f92ec455251092937a2540b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#afc4713722f92ec455251092937a2540b">decimalToBinary</a> (long long const &amp;decimal) noexcept</td></tr>
<tr class="memdesc:afc4713722f92ec455251092937a2540b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integral number to its binary equivalent.  <a href="namespacestr.html#afc4713722f92ec455251092937a2540b">More...</a><br /></td></tr>
<tr class="separator:afc4713722f92ec455251092937a2540b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8059cb6dea85450291ef813056734a8e"><td class="memTemplParams" colspan="2">template&lt;var::Streamable&lt; std::stringstream &gt;... Ts&gt; </td></tr>
<tr class="memitem:a8059cb6dea85450291ef813056734a8e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a8059cb6dea85450291ef813056734a8e">decimalToHex</a> (long long const &amp;dec, Ts &amp;&amp;... fmt) noexcept</td></tr>
<tr class="memdesc:a8059cb6dea85450291ef813056734a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from decimal to hexadecimal.  <a href="namespacestr.html#a8059cb6dea85450291ef813056734a8e">More...</a><br /></td></tr>
<tr class="separator:a8059cb6dea85450291ef813056734a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64641d820fe5e4997387b75be9df3b97"><td class="memTemplParams" colspan="2">template&lt;var::Streamable&lt; std::stringstream &gt;... Ts&gt; </td></tr>
<tr class="memitem:a64641d820fe5e4997387b75be9df3b97"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a64641d820fe5e4997387b75be9df3b97">decimalToHex</a> (std::string const &amp;dec, Ts &amp;&amp;... fmt) noexcept</td></tr>
<tr class="memdesc:a64641d820fe5e4997387b75be9df3b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from decimal to hexadecimal.  <a href="namespacestr.html#a64641d820fe5e4997387b75be9df3b97">More...</a><br /></td></tr>
<tr class="separator:a64641d820fe5e4997387b75be9df3b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dcad1131572f82cbb30a06c81006b0"><td class="memTemplParams" colspan="2">template&lt;var::Streamable&lt; std::ostream &gt;... Ts&gt; </td></tr>
<tr class="memitem:a25dcad1131572f82cbb30a06c81006b0"><td class="memTemplItemLeft" align="right" valign="top">WINCONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a25dcad1131572f82cbb30a06c81006b0">endsWith</a> (const std::string &amp;str, Ts &amp;&amp;... suffix)</td></tr>
<tr class="memdesc:a25dcad1131572f82cbb30a06c81006b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given string ends with the given characters.  <a href="namespacestr.html#a25dcad1131572f82cbb30a06c81006b0">More...</a><br /></td></tr>
<tr class="separator:a25dcad1131572f82cbb30a06c81006b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1efa734a2a1e8106138ce3b5995874"><td class="memTemplParams" colspan="2">template&lt;var::Streamable&lt; std::ostream &gt;... Ts&gt; </td></tr>
<tr class="memitem:afe1efa734a2a1e8106138ce3b5995874"><td class="memTemplItemLeft" align="right" valign="top">WINCONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#afe1efa734a2a1e8106138ce3b5995874">endsWithAny</a> (const std::string &amp;str, Ts &amp;&amp;... suffixes)</td></tr>
<tr class="memdesc:afe1efa734a2a1e8106138ce3b5995874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given string ends with any of the given character sequences.  <a href="namespacestr.html#afe1efa734a2a1e8106138ce3b5995874">More...</a><br /></td></tr>
<tr class="separator:afe1efa734a2a1e8106138ce3b5995874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0941f8566d99a99085690ce06c8eec1"><td class="memTemplParams" colspan="2">template&lt;bool IGNORE_CASE = false, var::all_same_or_convertible&lt; std::string &gt;... Ts&gt; </td></tr>
<tr class="memitem:ac0941f8566d99a99085690ce06c8eec1"><td class="memTemplItemLeft" align="right" valign="top">WINCONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#ac0941f8566d99a99085690ce06c8eec1">equalsAny</a> (const std::string &amp;str, Ts &amp;&amp;... compare)</td></tr>
<tr class="memdesc:ac0941f8566d99a99085690ce06c8eec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given string is equal to at least one other string.  <a href="namespacestr.html#ac0941f8566d99a99085690ce06c8eec1">More...</a><br /></td></tr>
<tr class="separator:ac0941f8566d99a99085690ce06c8eec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a0bf2d97851e9b37bad14d9ed8d224"><td class="memTemplParams" colspan="2">template&lt;bool IGNORE_CASE = false, var::all_same_or_convertible&lt; std::wstring, char &gt;... Ts&gt; </td></tr>
<tr class="memitem:ad5a0bf2d97851e9b37bad14d9ed8d224"><td class="memTemplItemLeft" align="right" valign="top">WINCONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#ad5a0bf2d97851e9b37bad14d9ed8d224">equalsAny</a> (const std::wstring &amp;str, Ts &amp;&amp;... compare)</td></tr>
<tr class="memdesc:ad5a0bf2d97851e9b37bad14d9ed8d224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given string is equal to at least one other string.  <a href="namespacestr.html#ad5a0bf2d97851e9b37bad14d9ed8d224">More...</a><br /></td></tr>
<tr class="separator:ad5a0bf2d97851e9b37bad14d9ed8d224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2842f64da212ac392e6c3385eb54a3e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::tuple&lt; std::string, std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ad2842f64da212ac392e6c3385eb54a3e">extractAllStrings</a> (const std::string &amp;line, const std::pair&lt; const char, const char &gt; delim, const bool forward, const bool includeDelim=false) noexcept</td></tr>
<tr class="memdesc:ad2842f64da212ac392e6c3385eb54a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3 substr, the first being the string until the first delim, the second being between the given delims, and the 3rd being the remaining string after the second delim.  <a href="namespacestr.html#ad2842f64da212ac392e6c3385eb54a3e">More...</a><br /></td></tr>
<tr class="separator:ad2842f64da212ac392e6c3385eb54a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93442c940874127d76612c31be16f7a7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a93442c940874127d76612c31be16f7a7">extractString</a> (const std::string &amp;line, const std::pair&lt; const char, const char &gt; delim) noexcept</td></tr>
<tr class="memdesc:a93442c940874127d76612c31be16f7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring from the first appearance of a given delimiter to the last.  <a href="namespacestr.html#a93442c940874127d76612c31be16f7a7">More...</a><br /></td></tr>
<tr class="separator:a93442c940874127d76612c31be16f7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b36762bf1fb176cef1f3ab327ff2da6"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a2b36762bf1fb176cef1f3ab327ff2da6">extractString</a> (const std::string &amp;line, const std::pair&lt; std::string, std::string &gt; delims, const bool includeDelim=false) noexcept</td></tr>
<tr class="memdesc:a2b36762bf1fb176cef1f3ab327ff2da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring from the first appearance of a pair of delimiters, if no delimiter is found, uses the beginning/end of the given str.  <a href="namespacestr.html#a2b36762bf1fb176cef1f3ab327ff2da6">More...</a><br /></td></tr>
<tr class="separator:a2b36762bf1fb176cef1f3ab327ff2da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e72dddafe6ddd37de81a5368ad75f0e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a3e72dddafe6ddd37de81a5368ad75f0e">extractString</a> (const std::string &amp;line, const std::string &amp;delims, const bool includeDelim=false) noexcept</td></tr>
<tr class="memdesc:a3e72dddafe6ddd37de81a5368ad75f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a contiguous substring from the first/last 2 appearances of the given delims.  <a href="namespacestr.html#a3e72dddafe6ddd37de81a5368ad75f0e">More...</a><br /></td></tr>
<tr class="separator:a3e72dddafe6ddd37de81a5368ad75f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d243724dffd234a19646d7c7b13553"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#af3d243724dffd234a19646d7c7b13553">extractStringUntil</a> (const std::string &amp;line, const char delim, const bool begin=true, const bool <a class="el" href="namespacestr.html#a9ef656ed2d8e17d0f1e68df1770058bc">reverse</a>=false) noexcept</td></tr>
<tr class="memdesc:af3d243724dffd234a19646d7c7b13553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substr between the beginning/end of a given string and the first occurrence of a given delimiter.  <a href="namespacestr.html#af3d243724dffd234a19646d7c7b13553">More...</a><br /></td></tr>
<tr class="separator:af3d243724dffd234a19646d7c7b13553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4712ba59b2780def08bcddcca090fe6"><td class="memItemLeft" align="right" valign="top">std::string::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ad4712ba59b2780def08bcddcca090fe6">find_any</a> (std::string ln, const std::string_view &amp;dels)</td></tr>
<tr class="memdesc:ad4712ba59b2780def08bcddcca090fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find any of a given set of delimiters in a string.  <a href="namespacestr.html#ad4712ba59b2780def08bcddcca090fe6">More...</a><br /></td></tr>
<tr class="separator:ad4712ba59b2780def08bcddcca090fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d8523d5d709baa8186137694899ac7"><td class="memItemLeft" align="right" valign="top">std::string::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a37d8523d5d709baa8186137694899ac7">find_any</a> (std::string ln, const std::string_view &amp;dels, const std::string::iterator &amp;off)</td></tr>
<tr class="memdesc:a37d8523d5d709baa8186137694899ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find any of a given set of delimiters in a string.  <a href="namespacestr.html#a37d8523d5d709baa8186137694899ac7">More...</a><br /></td></tr>
<tr class="separator:a37d8523d5d709baa8186137694899ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fe51c1830b934a4ee82e7a6f6e9571"><td class="memItemLeft" align="right" valign="top">constexpr decimal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ab6fe51c1830b934a4ee82e7a6f6e9571">fromAlphaNumeric</a> (const char &amp;ch) noexcept(false)</td></tr>
<tr class="memdesc:ab6fe51c1830b934a4ee82e7a6f6e9571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an alphanumeric representation of a number to its decimal equivalent.  <a href="namespacestr.html#ab6fe51c1830b934a4ee82e7a6f6e9571">More...</a><br /></td></tr>
<tr class="separator:ab6fe51c1830b934a4ee82e7a6f6e9571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02e5c31bf205b9b08d87b3c3c946baf"><td class="memItemLeft" align="right" valign="top">WINCONSTEXPR std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ac02e5c31bf205b9b08d87b3c3c946baf">fromBase10</a> (const decimal &amp;number, const int &amp;toBase) noexcept(false)</td></tr>
<tr class="memdesc:ac02e5c31bf205b9b08d87b3c3c946baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a number from base 10 (decimal) to an arbitrary base.  <a href="namespacestr.html#ac02e5c31bf205b9b08d87b3c3c946baf">More...</a><br /></td></tr>
<tr class="separator:ac02e5c31bf205b9b08d87b3c3c946baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041f49f2d8f911fcb5e47ed6ff691ab0"><td class="memItemLeft" align="right" valign="top">WINCONSTEXPR std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a041f49f2d8f911fcb5e47ed6ff691ab0">fromBase10</a> (const std::string &amp;number, const int &amp;toBase) noexcept(false)</td></tr>
<tr class="memdesc:a041f49f2d8f911fcb5e47ed6ff691ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a number from base 10 (decimal) to an arbitrary base.  <a href="namespacestr.html#a041f49f2d8f911fcb5e47ed6ff691ab0">More...</a><br /></td></tr>
<tr class="separator:a041f49f2d8f911fcb5e47ed6ff691ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac833e4f5138a5dd64fb8985361215835"><td class="memTemplParams" colspan="2">template&lt;std::integral RT, template&lt; class, class &gt; class Cont&gt; </td></tr>
<tr class="memitem:ac833e4f5138a5dd64fb8985361215835"><td class="memTemplItemLeft" align="right" valign="top">RT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#ac833e4f5138a5dd64fb8985361215835">get_longest_string</a> (const Cont&lt; std::string, std::allocator&lt; std::string &gt;&gt; &amp;cont, RT offset=static_cast&lt; RT &gt;(0))</td></tr>
<tr class="memdesc:ac833e4f5138a5dd64fb8985361215835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the length of the longest string in a given STL container.  <a href="namespacestr.html#ac833e4f5138a5dd64fb8985361215835">More...</a><br /></td></tr>
<tr class="separator:ac833e4f5138a5dd64fb8985361215835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a5ecaec1b7efa91322b8b79949f551"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a51a5ecaec1b7efa91322b8b79949f551"><td class="memTemplItemLeft" align="right" valign="top">constexpr static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a51a5ecaec1b7efa91322b8b79949f551">getLength</a> (T integral) noexcept</td></tr>
<tr class="memdesc:a51a5ecaec1b7efa91322b8b79949f551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the given integral number in digits.  <a href="namespacestr.html#a51a5ecaec1b7efa91322b8b79949f551">More...</a><br /></td></tr>
<tr class="separator:a51a5ecaec1b7efa91322b8b79949f551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af632b5ef496a88eb6c6a50ee18385c62"><td class="memTemplParams" colspan="2">template&lt;class Ch , class Tr , class A &gt; </td></tr>
<tr class="memitem:af632b5ef496a88eb6c6a50ee18385c62"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#af632b5ef496a88eb6c6a50ee18385c62">getline</a> (std::basic_istream&lt; Ch, Tr &gt; &amp;is, std::basic_string&lt; Ch, Tr, A &gt; &amp;str, const std::string &amp;delimiters)</td></tr>
<tr class="memdesc:af632b5ef496a88eb6c6a50ee18385c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative to std::getline that accepts a string of delimiters rather than a single char.  <a href="namespacestr.html#af632b5ef496a88eb6c6a50ee18385c62">More...</a><br /></td></tr>
<tr class="separator:af632b5ef496a88eb6c6a50ee18385c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae828e40bdc8eec39773e1a4dac9d7ed3"><td class="memTemplParams" colspan="2">template&lt;class Ch , class Tr , class A , var::same_or_convertible&lt; Ch &gt;... DelimT&gt; </td></tr>
<tr class="memitem:ae828e40bdc8eec39773e1a4dac9d7ed3"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#ae828e40bdc8eec39773e1a4dac9d7ed3">getline</a> (std::basic_istream&lt; Ch, Tr &gt; &amp;is, std::basic_string&lt; Ch, Tr, A &gt; &amp;str, DelimT const &amp;... delims)</td></tr>
<tr class="memdesc:ae828e40bdc8eec39773e1a4dac9d7ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic variant of the getline function.  <a href="namespacestr.html#ae828e40bdc8eec39773e1a4dac9d7ed3">More...</a><br /></td></tr>
<tr class="separator:ae828e40bdc8eec39773e1a4dac9d7ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea95d9955d4eaf233668351a309059db"><td class="memTemplParams" colspan="2">template&lt;class Ch , class Tr , class A , class Pred &gt; </td></tr>
<tr class="memitem:aea95d9955d4eaf233668351a309059db"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#aea95d9955d4eaf233668351a309059db">getline_pred</a> (std::basic_istream&lt; Ch, Tr &gt; &amp;is, std::basic_string&lt; Ch, Tr, A &gt; &amp;str, Pred p)</td></tr>
<tr class="memdesc:aea95d9955d4eaf233668351a309059db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative std::getline that accepts a predicate function rather than a char delimiter.  <a href="namespacestr.html#aea95d9955d4eaf233668351a309059db">More...</a><br /></td></tr>
<tr class="separator:aea95d9955d4eaf233668351a309059db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b165f72dcf094c144c89e27861888a"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a47b165f72dcf094c144c89e27861888a"><td class="memTemplItemLeft" align="right" valign="top">constexpr static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a47b165f72dcf094c144c89e27861888a">getNumberLength</a> (const T &amp;integral)</td></tr>
<tr class="memdesc:a47b165f72dcf094c144c89e27861888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the given integral number in digits.  <a href="namespacestr.html#a47b165f72dcf094c144c89e27861888a">More...</a><br /></td></tr>
<tr class="separator:a47b165f72dcf094c144c89e27861888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2665afb44cc6e90ff1e922639ea0e528"><td class="memItemLeft" align="right" valign="top">std::stringstream::pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a2665afb44cc6e90ff1e922639ea0e528">getStreamLength</a> (std::stringstream &amp;ss) noexcept</td></tr>
<tr class="memdesc:a2665afb44cc6e90ff1e922639ea0e528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a given stringstream.  <a href="namespacestr.html#a2665afb44cc6e90ff1e922639ea0e528">More...</a><br /></td></tr>
<tr class="separator:a2665afb44cc6e90ff1e922639ea0e528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afb39cb933e8727cfe4a84dbdad41c2"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a7afb39cb933e8727cfe4a84dbdad41c2">hexToDecimal</a> (const char ch) noexcept(false)</td></tr>
<tr class="memdesc:a7afb39cb933e8727cfe4a84dbdad41c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a given hexadecimal character to its decimal equivalent.  <a href="namespacestr.html#a7afb39cb933e8727cfe4a84dbdad41c2">More...</a><br /></td></tr>
<tr class="separator:a7afb39cb933e8727cfe4a84dbdad41c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c6b6a3bd47743a574df997a0bb8c65"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a42c6b6a3bd47743a574df997a0bb8c65">hexToDecimal</a> (std::string const &amp;hex) noexcept(false)</td></tr>
<tr class="memdesc:a42c6b6a3bd47743a574df997a0bb8c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from hexadecimal to decimal.  <a href="namespacestr.html#a42c6b6a3bd47743a574df997a0bb8c65">More...</a><br /></td></tr>
<tr class="separator:a42c6b6a3bd47743a574df997a0bb8c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e5ba0568ee7667816d0ec5535adcb6"><td class="memItemLeft" align="right" valign="top">WINCONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ae6e5ba0568ee7667816d0ec5535adcb6">isbinary</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:ae6e5ba0568ee7667816d0ec5535adcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given ASCII string is entirely composed of valid binary digits.  <a href="namespacestr.html#ae6e5ba0568ee7667816d0ec5535adcb6">More...</a><br /></td></tr>
<tr class="separator:ae6e5ba0568ee7667816d0ec5535adcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae198f739f9fe6a95ba3d19dd14194031"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ae198f739f9fe6a95ba3d19dd14194031">isbinarydigit</a> (const char &amp;ch) noexcept</td></tr>
<tr class="memdesc:ae198f739f9fe6a95ba3d19dd14194031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given ASCII character is a valid binary digit.  <a href="namespacestr.html#ae198f739f9fe6a95ba3d19dd14194031">More...</a><br /></td></tr>
<tr class="separator:ae198f739f9fe6a95ba3d19dd14194031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043ca9b134b11dde323fbda2dc5992ae"><td class="memItemLeft" align="right" valign="top">WINCONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a043ca9b134b11dde323fbda2dc5992ae">isdecimal</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:a043ca9b134b11dde323fbda2dc5992ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given ASCII string is entirely composed of valid decimal digits.  <a href="namespacestr.html#a043ca9b134b11dde323fbda2dc5992ae">More...</a><br /></td></tr>
<tr class="separator:a043ca9b134b11dde323fbda2dc5992ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa292888850b3b32095c1e48d65b9c645"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aa292888850b3b32095c1e48d65b9c645">isdecimaldigit</a> (const char &amp;ch)</td></tr>
<tr class="memdesc:aa292888850b3b32095c1e48d65b9c645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given ASCII string is entirely composed of valid decimal digits.  <a href="namespacestr.html#aa292888850b3b32095c1e48d65b9c645">More...</a><br /></td></tr>
<tr class="separator:aa292888850b3b32095c1e48d65b9c645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8150d7f427d4bf2eeccc7e56dfd35107"><td class="memItemLeft" align="right" valign="top">WINCONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a8150d7f427d4bf2eeccc7e56dfd35107">ishex</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:a8150d7f427d4bf2eeccc7e56dfd35107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given ASCII string is entirely composed of valid hexadecimal digits.  <a href="namespacestr.html#a8150d7f427d4bf2eeccc7e56dfd35107">More...</a><br /></td></tr>
<tr class="separator:a8150d7f427d4bf2eeccc7e56dfd35107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c0401e167ff247a2ed60e76c99e959"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aa1c0401e167ff247a2ed60e76c99e959">ishexdigit</a> (const char &amp;ch) noexcept</td></tr>
<tr class="memdesc:aa1c0401e167ff247a2ed60e76c99e959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given ASCII character is a valid hexadecimal digit.  <a href="namespacestr.html#aa1c0401e167ff247a2ed60e76c99e959">More...</a><br /></td></tr>
<tr class="separator:aa1c0401e167ff247a2ed60e76c99e959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd79fa931f1d21cb03de4642d230d11"><td class="memItemLeft" align="right" valign="top">WINCONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a0bd79fa931f1d21cb03de4642d230d11">isoctal</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:a0bd79fa931f1d21cb03de4642d230d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given ASCII string is entirely composed of valid octal digits.  <a href="namespacestr.html#a0bd79fa931f1d21cb03de4642d230d11">More...</a><br /></td></tr>
<tr class="separator:a0bd79fa931f1d21cb03de4642d230d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f1cfbd61cff5c1c0975e2bc65c24e8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a50f1cfbd61cff5c1c0975e2bc65c24e8">isoctaldigit</a> (const char &amp;ch) noexcept</td></tr>
<tr class="memdesc:a50f1cfbd61cff5c1c0975e2bc65c24e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given ASCII character is a valid octal digit.  <a href="namespacestr.html#a50f1cfbd61cff5c1c0975e2bc65c24e8">More...</a><br /></td></tr>
<tr class="separator:a50f1cfbd61cff5c1c0975e2bc65c24e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee442fd63b5198985d3bd6a126f1d399"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aee442fd63b5198985d3bd6a126f1d399">isquote</a> (const char c)</td></tr>
<tr class="memdesc:aee442fd63b5198985d3bd6a126f1d399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that checks if a given char is a quotation mark. (Accepts single or double quotes.)  <a href="namespacestr.html#aee442fd63b5198985d3bd6a126f1d399">More...</a><br /></td></tr>
<tr class="separator:aee442fd63b5198985d3bd6a126f1d399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8be91baa116c4582e66f6278db959f"><td class="memTemplParams" colspan="2">template&lt;template&lt; class, class &gt; class ContainerT, class ElemT , var::Streamable... VT&gt; </td></tr>
<tr class="memitem:acf8be91baa116c4582e66f6278db959f"><td class="memTemplItemLeft" align="right" valign="top">requires constexpr static const std::convertible_to&lt; ElemT, std::string &gt; std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#acf8be91baa116c4582e66f6278db959f">join</a> (const ContainerT&lt; ElemT, std::allocator&lt; ElemT &gt;&gt; &amp;container, VT... separators)</td></tr>
<tr class="separator:acf8be91baa116c4582e66f6278db959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d5f5ddec852ee6650d85fcd45c3030"><td class="memTemplParams" colspan="2"><a id="af0d5f5ddec852ee6650d85fcd45c3030"></a>
template&lt;bool index, var::valid_string T, template&lt; class... &gt; class Cont&gt; </td></tr>
<tr class="memitem:af0d5f5ddec852ee6650d85fcd45c3030"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; std::pair&lt; T, T &gt;, std::allocator&lt; std::pair&lt; T, T &gt; &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>longest</b> (const Cont&lt; std::pair&lt; T, T &gt;, std::allocator&lt; std::pair&lt; T, T &gt;&gt;&gt; &amp;strings)</td></tr>
<tr class="separator:af0d5f5ddec852ee6650d85fcd45c3030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718e93d72455a6f9af50cca592378f99"><td class="memTemplParams" colspan="2">template&lt;size_t index, var::valid_string... Ts, template&lt; class... &gt; class Cont&gt; </td></tr>
<tr class="memitem:a718e93d72455a6f9af50cca592378f99"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt; &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">longest</a> (const Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt;&gt;&gt; &amp;strings)</td></tr>
<tr class="memdesc:a718e93d72455a6f9af50cca592378f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the longest string in a container of string tuples.  <a href="namespacestr.html#a718e93d72455a6f9af50cca592378f99">More...</a><br /></td></tr>
<tr class="separator:a718e93d72455a6f9af50cca592378f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab273e18c3896683954b42ea222129f4"><td class="memTemplParams" colspan="2"><a id="aab273e18c3896683954b42ea222129f4"></a>
template&lt;var::valid_string T, template&lt; class, class &gt; class Cont&gt; </td></tr>
<tr class="memitem:aab273e18c3896683954b42ea222129f4"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; T, std::allocator&lt; T &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>longest</b> (const Cont&lt; T, std::allocator&lt; T &gt;&gt; &amp;strings)</td></tr>
<tr class="separator:aab273e18c3896683954b42ea222129f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e29c1c2f11c9fdba7e76bb2e3327c4b"><td class="memTemplParams" colspan="2"><a id="a4e29c1c2f11c9fdba7e76bb2e3327c4b"></a>
template&lt;var::valid_string_or_convertible T, var::valid_string_or_convertible... Ts&gt; </td></tr>
<tr class="memitem:a4e29c1c2f11c9fdba7e76bb2e3327c4b"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>longest</b> (const T &amp;fst, const Ts &amp;... strings)</td></tr>
<tr class="separator:a4e29c1c2f11c9fdba7e76bb2e3327c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e68ca74959c47dae8d126c8a9db5717"><td class="memTemplParams" colspan="2"><a id="a1e68ca74959c47dae8d126c8a9db5717"></a>
template&lt;template&lt; class, class &gt; class cont_type&gt; </td></tr>
<tr class="memitem:a1e68ca74959c47dae8d126c8a9db5717"><td class="memTemplItemLeft" align="right" valign="top">static std::string::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>longestLength</b> (const cont_type&lt; std::string, std::allocator&lt; std::string &gt;&gt; &amp;container) noexcept</td></tr>
<tr class="separator:a1e68ca74959c47dae8d126c8a9db5717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff70a0416ef1eed4ca4968378d46f9a9"><td class="memItemLeft" align="right" valign="top">std::string::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aff70a0416ef1eed4ca4968378d46f9a9">longestLength</a> (const std::vector&lt; std::string &gt; &amp;vec) noexcept</td></tr>
<tr class="memdesc:aff70a0416ef1eed4ca4968378d46f9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the longest string in a vector.  <a href="namespacestr.html#aff70a0416ef1eed4ca4968378d46f9a9">More...</a><br /></td></tr>
<tr class="separator:aff70a0416ef1eed4ca4968378d46f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99874f5b703e388240420d5bec8557a3"><td class="memTemplParams" colspan="2">template&lt;bool MatchCase = true, var::valid_string StrT, var::same_or_convertible&lt; StrT &gt;... Ts&gt; </td></tr>
<tr class="memitem:a99874f5b703e388240420d5bec8557a3"><td class="memTemplItemLeft" align="right" valign="top">requires var::at_least_one&lt; Ts... &gt; WINCONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a99874f5b703e388240420d5bec8557a3">matches_any</a> (const StrT &amp;str, const Ts &amp;... matches)</td></tr>
<tr class="memdesc:a99874f5b703e388240420d5bec8557a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given string matches any of a list of strings.  <a href="namespacestr.html#a99874f5b703e388240420d5bec8557a3">More...</a><br /></td></tr>
<tr class="separator:a99874f5b703e388240420d5bec8557a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5247d873952449905ce03aca93e5661d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a5247d873952449905ce03aca93e5661d">NumberGrouping</a> (std::ostream &amp;os)</td></tr>
<tr class="memdesc:a5247d873952449905ce03aca93e5661d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically insert commas between thousands when printing numbers. <br  />
 Example: "1000000" =&gt; "1,000,000".  <a href="namespacestr.html#a5247d873952449905ce03aca93e5661d">More...</a><br /></td></tr>
<tr class="separator:a5247d873952449905ce03aca93e5661d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68189011dff0dc860136f8606606169c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a68189011dff0dc860136f8606606169c">optional_find</a> (const std::string &amp;str, auto &amp;&amp;search)</td></tr>
<tr class="memdesc:a68189011dff0dc860136f8606606169c"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::string::find function that returns an optional instead of std::string::npos  <a href="namespacestr.html#a68189011dff0dc860136f8606606169c">More...</a><br /></td></tr>
<tr class="separator:a68189011dff0dc860136f8606606169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ad677b200aa91ac5ff1b6eda8b8ea2"><td class="memTemplParams" colspan="2">template&lt;template&lt; class, class &gt; class ContType&gt; </td></tr>
<tr class="memitem:a01ad677b200aa91ac5ff1b6eda8b8ea2"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a01ad677b200aa91ac5ff1b6eda8b8ea2">parseWithDelim</a> (std::string str, const char delim=',', std::optional&lt; ContType&lt; std::function&lt; int(int)&gt;, std::allocator&lt; std::function&lt; int(int)&gt;&gt;&gt;&gt; remove_if=std::nullopt) noexcept</td></tr>
<tr class="memdesc:a01ad677b200aa91ac5ff1b6eda8b8ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a given string with a given delimiter, and return a vector of strings.  <a href="namespacestr.html#a01ad677b200aa91ac5ff1b6eda8b8ea2">More...</a><br /></td></tr>
<tr class="separator:a01ad677b200aa91ac5ff1b6eda8b8ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bde2717215ef2e746a382003a8fc58"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a26bde2717215ef2e746a382003a8fc58">Placeholder</a> (std::ostream &amp;os)</td></tr>
<tr class="memdesc:a26bde2717215ef2e746a382003a8fc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder function that does nothing. Intended for use in ternary expressions.  <a href="namespacestr.html#a26bde2717215ef2e746a382003a8fc58">More...</a><br /></td></tr>
<tr class="separator:a26bde2717215ef2e746a382003a8fc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bf9f8189aea4146e003477d8b7a62d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a26bf9f8189aea4146e003477d8b7a62d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">pos_valid</a> (const T &amp;pos) noexcept</td></tr>
<tr class="memdesc:a26bf9f8189aea4146e003477d8b7a62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply checks the given position value against std::string::npos.  <a href="namespacestr.html#a26bf9f8189aea4146e003477d8b7a62d">More...</a><br /></td></tr>
<tr class="separator:a26bf9f8189aea4146e003477d8b7a62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f757b5761b656d6ce1d15aee26507c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a16f757b5761b656d6ce1d15aee26507c">remove_all</a> (std::string str, const std::string &amp;delims)</td></tr>
<tr class="memdesc:a16f757b5761b656d6ce1d15aee26507c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of a given list of delimiters from a given string.  <a href="namespacestr.html#a16f757b5761b656d6ce1d15aee26507c">More...</a><br /></td></tr>
<tr class="separator:a16f757b5761b656d6ce1d15aee26507c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c7ac3d05115fd618a8779045def1c7"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a30c7ac3d05115fd618a8779045def1c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a30c7ac3d05115fd618a8779045def1c7">remove_all_of</a> (std::string str, F pred) noexcept</td></tr>
<tr class="memdesc:a30c7ac3d05115fd618a8779045def1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline wrapper for the erase-remove idiom that accepts a lambda predicate.  <a href="namespacestr.html#a30c7ac3d05115fd618a8779045def1c7">More...</a><br /></td></tr>
<tr class="separator:a30c7ac3d05115fd618a8779045def1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d6dd0849bbc57ab6970682bf0f8078"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ad1d6dd0849bbc57ab6970682bf0f8078">remove_whitespace</a> (std::string str) noexcept</td></tr>
<tr class="memdesc:ad1d6dd0849bbc57ab6970682bf0f8078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline wrapper for the erase-remove idiom that removes spaces.  <a href="namespacestr.html#ad1d6dd0849bbc57ab6970682bf0f8078">More...</a><br /></td></tr>
<tr class="separator:ad1d6dd0849bbc57ab6970682bf0f8078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35ece5b07dfe3a18235ccc6c0f563ba"><td class="memTemplParams" colspan="2"><a id="ad35ece5b07dfe3a18235ccc6c0f563ba"></a>
template&lt;typename... VT&gt; </td></tr>
<tr class="memitem:ad35ece5b07dfe3a18235ccc6c0f563ba"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>requires</b> (sizeof...(VT) &gt; 0) static std</td></tr>
<tr class="separator:ad35ece5b07dfe3a18235ccc6c0f563ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef656ed2d8e17d0f1e68df1770058bc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a9ef656ed2d8e17d0f1e68df1770058bc">reverse</a> (const std::string_view &amp;str)</td></tr>
<tr class="memdesc:a9ef656ed2d8e17d0f1e68df1770058bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the characters of a given string.  <a href="namespacestr.html#a9ef656ed2d8e17d0f1e68df1770058bc">More...</a><br /></td></tr>
<tr class="separator:a9ef656ed2d8e17d0f1e68df1770058bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b4c7c470963c0be1a41227ccf6f86e"><td class="memItemLeft" align="right" valign="top">const WINCONSTEXPR std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a69b4c7c470963c0be1a41227ccf6f86e">rsplit</a> (const std::string &amp;str, const char &amp;delim, const unsigned &amp;occurrence=0ull)</td></tr>
<tr class="memdesc:a69b4c7c470963c0be1a41227ccf6f86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a pair of strings by finding the first occurrence of a given delimiter.  <a href="namespacestr.html#a69b4c7c470963c0be1a41227ccf6f86e">More...</a><br /></td></tr>
<tr class="separator:a69b4c7c470963c0be1a41227ccf6f86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba157b4f80912e0c19b9ad7676d2c8d1"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aba157b4f80912e0c19b9ad7676d2c8d1"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#aba157b4f80912e0c19b9ad7676d2c8d1">sanitize</a> (std::string str, F pred) noexcept</td></tr>
<tr class="memdesc:aba157b4f80912e0c19b9ad7676d2c8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanitize a string with a single predicate function. This is called by <a class="el" href="namespacestr.html#a30c7ac3d05115fd618a8779045def1c7" title="Inline wrapper for the erase-remove idiom that accepts a lambda predicate.">remove_all_of()</a>.  <a href="namespacestr.html#aba157b4f80912e0c19b9ad7676d2c8d1">More...</a><br /></td></tr>
<tr class="separator:aba157b4f80912e0c19b9ad7676d2c8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5890626349406d682c75bf7cded557d0"><td class="memTemplParams" colspan="2"><a id="a5890626349406d682c75bf7cded557d0"></a>
template&lt;bool index, var::valid_string T, template&lt; class... &gt; class Cont&gt; </td></tr>
<tr class="memitem:a5890626349406d682c75bf7cded557d0"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; std::pair&lt; T, T &gt;, std::allocator&lt; std::pair&lt; T, T &gt; &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shortest</b> (const Cont&lt; std::pair&lt; T, T &gt;, std::allocator&lt; std::pair&lt; T, T &gt;&gt;&gt; &amp;strings)</td></tr>
<tr class="separator:a5890626349406d682c75bf7cded557d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58590dd003d9759582ee1de6d1b6dc9f"><td class="memTemplParams" colspan="2">template&lt;size_t index, var::valid_string... Ts, template&lt; class... &gt; class Cont&gt; </td></tr>
<tr class="memitem:a58590dd003d9759582ee1de6d1b6dc9f"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt; &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">shortest</a> (const Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt;&gt;&gt; &amp;strings)</td></tr>
<tr class="memdesc:a58590dd003d9759582ee1de6d1b6dc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shortest string in a container of string tuples.  <a href="namespacestr.html#a58590dd003d9759582ee1de6d1b6dc9f">More...</a><br /></td></tr>
<tr class="separator:a58590dd003d9759582ee1de6d1b6dc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0377cd612795f7313947f6b43910b032"><td class="memTemplParams" colspan="2"><a id="a0377cd612795f7313947f6b43910b032"></a>
template&lt;var::valid_string T, template&lt; class, class &gt; class Cont&gt; </td></tr>
<tr class="memitem:a0377cd612795f7313947f6b43910b032"><td class="memTemplItemLeft" align="right" valign="top">static Cont&lt; T, std::allocator&lt; T &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shortest</b> (const Cont&lt; T, std::allocator&lt; T &gt;&gt; &amp;strings)</td></tr>
<tr class="separator:a0377cd612795f7313947f6b43910b032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c41dd852c1db4ba8b8f1d28e4728b5"><td class="memTemplParams" colspan="2"><a id="a87c41dd852c1db4ba8b8f1d28e4728b5"></a>
template&lt;var::valid_string_or_convertible T, var::valid_string_or_convertible... Ts&gt; </td></tr>
<tr class="memitem:a87c41dd852c1db4ba8b8f1d28e4728b5"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shortest</b> (const T &amp;fst, const Ts &amp;... strings)</td></tr>
<tr class="separator:a87c41dd852c1db4ba8b8f1d28e4728b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81d06e112031542961adc0b38bd0b2b"><td class="memItemLeft" align="right" valign="top">const WINCONSTEXPR std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ab81d06e112031542961adc0b38bd0b2b">split</a> (const std::string &amp;str, const char &amp;delim, const unsigned &amp;occurrence=0ull)</td></tr>
<tr class="memdesc:ab81d06e112031542961adc0b38bd0b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a pair of strings by finding the first occurrence of a given delimiter.  <a href="namespacestr.html#ab81d06e112031542961adc0b38bd0b2b">More...</a><br /></td></tr>
<tr class="separator:ab81d06e112031542961adc0b38bd0b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba03dcb83941ed1d96f1ae269db82fc0"><td class="memItemLeft" align="right" valign="top">const WINCONSTEXPR std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aba03dcb83941ed1d96f1ae269db82fc0">split</a> (const std::string &amp;str, const size_t &amp;pos, const bool &amp;discard_pos=false)</td></tr>
<tr class="memdesc:aba03dcb83941ed1d96f1ae269db82fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a pair of strings by position. This is a simple wrapper to return a string split operation as a pair of strings.  <a href="namespacestr.html#aba03dcb83941ed1d96f1ae269db82fc0">More...</a><br /></td></tr>
<tr class="separator:aba03dcb83941ed1d96f1ae269db82fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f17d783f53a8761d44c3304753da96"><td class="memItemLeft" align="right" valign="top">const WINCONSTEXPR std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ab8f17d783f53a8761d44c3304753da96">split</a> (const std::string &amp;str, const std::string &amp;delims, const unsigned &amp;occurrence=0ull)</td></tr>
<tr class="memdesc:ab8f17d783f53a8761d44c3304753da96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a pair of strings by finding the first occurrence of a given delimiter.  <a href="namespacestr.html#ab8f17d783f53a8761d44c3304753da96">More...</a><br /></td></tr>
<tr class="separator:ab8f17d783f53a8761d44c3304753da96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bf5f1b14b776ed8c1225f5c2870a92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aa4bf5f1b14b776ed8c1225f5c2870a92">split_by_words</a> (const std::string &amp;line)</td></tr>
<tr class="memdesc:aa4bf5f1b14b776ed8c1225f5c2870a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a given string into a vector of strings, with one word per index.  <a href="namespacestr.html#aa4bf5f1b14b776ed8c1225f5c2870a92">More...</a><br /></td></tr>
<tr class="separator:aa4bf5f1b14b776ed8c1225f5c2870a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bac9088e59d818dfcb958ca9fc1c673"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a5bac9088e59d818dfcb958ca9fc1c673"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; CharT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a5bac9088e59d818dfcb958ca9fc1c673">split_to_vector</a> (const std::basic_string&lt; CharT, Traits, std::allocator&lt; CharT &gt;&gt; &amp;str)</td></tr>
<tr class="memdesc:a5bac9088e59d818dfcb958ca9fc1c673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a vector of characters.  <a href="namespacestr.html#a5bac9088e59d818dfcb958ca9fc1c673">More...</a><br /></td></tr>
<tr class="separator:a5bac9088e59d818dfcb958ca9fc1c673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50e9ee8aa4a8666ec47aefff8fa4bca"><td class="memTemplParams" colspan="2">template&lt;var::Streamable&lt; std::ostream &gt;... Ts&gt; </td></tr>
<tr class="memitem:ad50e9ee8aa4a8666ec47aefff8fa4bca"><td class="memTemplItemLeft" align="right" valign="top">WINCONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#ad50e9ee8aa4a8666ec47aefff8fa4bca">startsWith</a> (const std::string &amp;str, Ts &amp;&amp;... prefix)</td></tr>
<tr class="memdesc:ad50e9ee8aa4a8666ec47aefff8fa4bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given string starts with the given characters.  <a href="namespacestr.html#ad50e9ee8aa4a8666ec47aefff8fa4bca">More...</a><br /></td></tr>
<tr class="separator:ad50e9ee8aa4a8666ec47aefff8fa4bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccb7cb4dfd45bb24e56b297a5cbe276"><td class="memTemplParams" colspan="2">template&lt;var::Streamable&lt; std::ostream &gt;... Ts&gt; </td></tr>
<tr class="memitem:a6ccb7cb4dfd45bb24e56b297a5cbe276"><td class="memTemplItemLeft" align="right" valign="top">WINCONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a6ccb7cb4dfd45bb24e56b297a5cbe276">startsWithAny</a> (const std::string &amp;str, Ts &amp;&amp;... prefixes)</td></tr>
<tr class="memdesc:a6ccb7cb4dfd45bb24e56b297a5cbe276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given string starts with any of the given character sequences.  <a href="namespacestr.html#a6ccb7cb4dfd45bb24e56b297a5cbe276">More...</a><br /></td></tr>
<tr class="separator:a6ccb7cb4dfd45bb24e56b297a5cbe276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5f7adb1945d04eb55b0910ca01d09f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a1c5f7adb1945d04eb55b0910ca01d09f">stod</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:a1c5f7adb1945d04eb55b0910ca01d09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to double. Wrapper for std::stod that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#a1c5f7adb1945d04eb55b0910ca01d09f">More...</a><br /></td></tr>
<tr class="separator:a1c5f7adb1945d04eb55b0910ca01d09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47e8a6851499957d48fdef435cd982a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ae47e8a6851499957d48fdef435cd982a">stof</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:ae47e8a6851499957d48fdef435cd982a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to float. Wrapper for std::stof that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#ae47e8a6851499957d48fdef435cd982a">More...</a><br /></td></tr>
<tr class="separator:ae47e8a6851499957d48fdef435cd982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15a09e1f1896bc59792a58fe8e1fbe9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ad15a09e1f1896bc59792a58fe8e1fbe9">stoi</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:ad15a09e1f1896bc59792a58fe8e1fbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to int. Wrapper for std::stoi that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#ad15a09e1f1896bc59792a58fe8e1fbe9">More...</a><br /></td></tr>
<tr class="separator:ad15a09e1f1896bc59792a58fe8e1fbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4cc36f0f7fbc735d3a7a282b8d9684"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#abf4cc36f0f7fbc735d3a7a282b8d9684">stol</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:abf4cc36f0f7fbc735d3a7a282b8d9684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to long. Wrapper for std::stol that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#abf4cc36f0f7fbc735d3a7a282b8d9684">More...</a><br /></td></tr>
<tr class="separator:abf4cc36f0f7fbc735d3a7a282b8d9684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ddec4fea92d79d63cd6caa33d084e5"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#af3ddec4fea92d79d63cd6caa33d084e5">stold</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:af3ddec4fea92d79d63cd6caa33d084e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to double. Wrapper for std::stod that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#af3ddec4fea92d79d63cd6caa33d084e5">More...</a><br /></td></tr>
<tr class="separator:af3ddec4fea92d79d63cd6caa33d084e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb07fec74c9d4fc331166f5c7320aa0"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a2eb07fec74c9d4fc331166f5c7320aa0">stoll</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:a2eb07fec74c9d4fc331166f5c7320aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to long long. Wrapper for std::stol that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#a2eb07fec74c9d4fc331166f5c7320aa0">More...</a><br /></td></tr>
<tr class="separator:a2eb07fec74c9d4fc331166f5c7320aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faa23ca70522123e1c17746265b4c40"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a8faa23ca70522123e1c17746265b4c40">stos</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:a8faa23ca70522123e1c17746265b4c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to short. Wrapper for std::stoi that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#a8faa23ca70522123e1c17746265b4c40">More...</a><br /></td></tr>
<tr class="separator:a8faa23ca70522123e1c17746265b4c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff81b4fb51f25b185a6e0f219023631b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aff81b4fb51f25b185a6e0f219023631b">stoui</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:aff81b4fb51f25b185a6e0f219023631b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to unsigned int. Wrapper for static_cast&lt;unsigned&gt;(std::stoi) that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#aff81b4fb51f25b185a6e0f219023631b">More...</a><br /></td></tr>
<tr class="separator:aff81b4fb51f25b185a6e0f219023631b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad150ce9485904ee33e3593e783324b09"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ad150ce9485904ee33e3593e783324b09">stoul</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:ad150ce9485904ee33e3593e783324b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to unsigned long. Wrapper for std::stoul that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#ad150ce9485904ee33e3593e783324b09">More...</a><br /></td></tr>
<tr class="separator:ad150ce9485904ee33e3593e783324b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424d7e0db015c773dd069f863c2742e0"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a424d7e0db015c773dd069f863c2742e0">stoull</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:a424d7e0db015c773dd069f863c2742e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to unsigned long. Wrapper for std::stoul that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#a424d7e0db015c773dd069f863c2742e0">More...</a><br /></td></tr>
<tr class="separator:a424d7e0db015c773dd069f863c2742e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abdc3487fffb1c2b871bf5b609081c8"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a9abdc3487fffb1c2b871bf5b609081c8">stous</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:a9abdc3487fffb1c2b871bf5b609081c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string to unsigned short. Wrapper for static_cast&lt;unsigned short&gt;(std::stoi) that can be passed as std::function. Does not throw exceptions.  <a href="namespacestr.html#a9abdc3487fffb1c2b871bf5b609081c8">More...</a><br /></td></tr>
<tr class="separator:a9abdc3487fffb1c2b871bf5b609081c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18758598172725d265bdab25d48f5836"><td class="memTemplParams" colspan="2">template&lt;var::Streamable... Ts&gt; </td></tr>
<tr class="memitem:a18758598172725d265bdab25d48f5836"><td class="memTemplItemLeft" align="right" valign="top">static std::stringstream&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a18758598172725d265bdab25d48f5836">streamify</a> (Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a18758598172725d265bdab25d48f5836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a stringstream, inserts all of the given arguments, then move-returns the resulting stringstream.  <a href="namespacestr.html#a18758598172725d265bdab25d48f5836">More...</a><br /></td></tr>
<tr class="separator:a18758598172725d265bdab25d48f5836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724f84184c0c1cd75e91b4ac95f40768"><td class="memTemplParams" colspan="2">template&lt;var::Streamable... Ts&gt; </td></tr>
<tr class="memitem:a724f84184c0c1cd75e91b4ac95f40768"><td class="memTemplItemLeft" align="right" valign="top">constexpr static const std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">stringify</a> (Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a724f84184c0c1cd75e91b4ac95f40768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the stringstream's str() function.  <a href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768">More...</a><br /></td></tr>
<tr class="separator:a724f84184c0c1cd75e91b4ac95f40768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac564c68f61fc9cb1018753365dfd9e7b"><td class="memTemplParams" colspan="2">template&lt;var::Streamable T&gt; </td></tr>
<tr class="memitem:ac564c68f61fc9cb1018753365dfd9e7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr static const std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#ac564c68f61fc9cb1018753365dfd9e7b">stringify_split</a> (const char &amp;delimiter, const std::vector&lt; T &gt; &amp;args)</td></tr>
<tr class="memdesc:ac564c68f61fc9cb1018753365dfd9e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary stringstream and inserts all of the given arguments in sequential order, then uses the given delimiter to split the resulting string into a vector of strings.  <a href="namespacestr.html#ac564c68f61fc9cb1018753365dfd9e7b">More...</a><br /></td></tr>
<tr class="separator:ac564c68f61fc9cb1018753365dfd9e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d969c8ad087fcf6a701f1241503eab"><td class="memTemplParams" colspan="2">template&lt;var::Streamable... Ts&gt; </td></tr>
<tr class="memitem:a30d969c8ad087fcf6a701f1241503eab"><td class="memTemplItemLeft" align="right" valign="top">constexpr static const std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a30d969c8ad087fcf6a701f1241503eab">stringify_split</a> (const char &amp;delimiter, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a30d969c8ad087fcf6a701f1241503eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary stringstream and inserts all of the given arguments in sequential order, then uses the given delimiter to split the resulting string into a vector of strings.  <a href="namespacestr.html#a30d969c8ad087fcf6a701f1241503eab">More...</a><br /></td></tr>
<tr class="separator:a30d969c8ad087fcf6a701f1241503eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333afe30699add89dd4b33e8f8e965af"><td class="memTemplParams" colspan="2">template&lt;std::same_as&lt; char &gt;... DelimT&gt; </td></tr>
<tr class="memitem:a333afe30699add89dd4b33e8f8e965af"><td class="memTemplItemLeft" align="right" valign="top">static WINCONSTEXPR std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a333afe30699add89dd4b33e8f8e965af">strip</a> (std::string s, const DelimT &amp;... delims)</td></tr>
<tr class="memdesc:a333afe30699add89dd4b33e8f8e965af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all specified characters from the given string.  <a href="namespacestr.html#a333afe30699add89dd4b33e8f8e965af">More...</a><br /></td></tr>
<tr class="separator:a333afe30699add89dd4b33e8f8e965af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf63c00706c91be7da3f18b08a088224"><td class="memItemLeft" align="right" valign="top">static WINCONSTEXPR std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#acf63c00706c91be7da3f18b08a088224">strip</a> (std::string s, const std::string_view &amp;delims)</td></tr>
<tr class="memdesc:acf63c00706c91be7da3f18b08a088224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all specified characters from the given string.  <a href="namespacestr.html#acf63c00706c91be7da3f18b08a088224">More...</a><br /></td></tr>
<tr class="separator:acf63c00706c91be7da3f18b08a088224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7346dfeb6d8d2d04a563649f4bf3cbca"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a7346dfeb6d8d2d04a563649f4bf3cbca">strip_line</a> (std::string str, const std::string &amp;comment_chars={}, const std::string &amp;whitespace_chars=&quot; \t\r\n\v&quot;)</td></tr>
<tr class="memdesc:a7346dfeb6d8d2d04a563649f4bf3cbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes comments and preceeding/trailing whitespace from a given string.  <a href="namespacestr.html#a7346dfeb6d8d2d04a563649f4bf3cbca">More...</a><br /></td></tr>
<tr class="separator:a7346dfeb6d8d2d04a563649f4bf3cbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d3b4fc0b12749a6a027d5b0e58be81"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ab3d3b4fc0b12749a6a027d5b0e58be81">strip_line_multiCharComment</a> (std::string str, const std::vector&lt; std::string &gt; &amp;comment_del={}, const std::string_view &amp;whitespace_chars=&quot; \t\r\n\v&quot;)</td></tr>
<tr class="memdesc:ab3d3b4fc0b12749a6a027d5b0e58be81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes more complex comments ( ex. C/JSON/html comments ) and preceeding/trailing whitespace from a given string.  <a href="namespacestr.html#ab3d3b4fc0b12749a6a027d5b0e58be81">More...</a><br /></td></tr>
<tr class="separator:ab3d3b4fc0b12749a6a027d5b0e58be81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7fab88e397cd6251944c3d01a7438d"><td class="memTemplParams" colspan="2">template&lt;std::same_as&lt; char &gt;... DelimT&gt; </td></tr>
<tr class="memitem:a4a7fab88e397cd6251944c3d01a7438d"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a4a7fab88e397cd6251944c3d01a7438d">strip_preceeding</a> (const std::string &amp;str, const DelimT &amp;... delims)</td></tr>
<tr class="memdesc:a4a7fab88e397cd6251944c3d01a7438d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove preceeding characters from a string.  <a href="namespacestr.html#a4a7fab88e397cd6251944c3d01a7438d">More...</a><br /></td></tr>
<tr class="separator:a4a7fab88e397cd6251944c3d01a7438d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c1b11a2e282a4fc8d38548eaf45f3c"><td class="memTemplParams" colspan="2">template&lt;std::same_as&lt; char &gt;... DelimT&gt; </td></tr>
<tr class="memitem:a45c1b11a2e282a4fc8d38548eaf45f3c"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a45c1b11a2e282a4fc8d38548eaf45f3c">strip_trailing</a> (const std::string &amp;str, const DelimT &amp;... delims)</td></tr>
<tr class="memdesc:a45c1b11a2e282a4fc8d38548eaf45f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove trailing characters from a string.  <a href="namespacestr.html#a45c1b11a2e282a4fc8d38548eaf45f3c">More...</a><br /></td></tr>
<tr class="separator:a45c1b11a2e282a4fc8d38548eaf45f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7b7e4aa9a634e2c97fda1bacf22e9b"><td class="memTemplParams" colspan="2">template&lt;var::Streamable&lt; std::stringstream &gt; T, var::Streamable&lt; std::stringstream &gt;... Ts&gt; </td></tr>
<tr class="memitem:a0d7b7e4aa9a634e2c97fda1bacf22e9b"><td class="memTemplItemLeft" align="right" valign="top">const CONSTEXPR std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a0d7b7e4aa9a634e2c97fda1bacf22e9b">to_string</a> (const T &amp;value, const std::ios_base::fmtflags &amp;fmt, Ts &amp;&amp;... additionalFmt)</td></tr>
<tr class="memdesc:a0d7b7e4aa9a634e2c97fda1bacf22e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from any valid streamable type to a string. <br  />
 This function is a wrapper around <a class="el" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768" title="Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the ...">stringify()</a>, with a focus on (numeric) =&gt; (string) conversions.  <a href="namespacestr.html#a0d7b7e4aa9a634e2c97fda1bacf22e9b">More...</a><br /></td></tr>
<tr class="separator:a0d7b7e4aa9a634e2c97fda1bacf22e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3d6c1b751e80fb651cf8f2fa2f7c32"><td class="memTemplParams" colspan="2">template&lt;var::numeric T&gt; </td></tr>
<tr class="memitem:abf3d6c1b751e80fb651cf8f2fa2f7c32"><td class="memTemplItemLeft" align="right" valign="top">const CONSTEXPR std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#abf3d6c1b751e80fb651cf8f2fa2f7c32">to_string</a> (const T &amp;value, const std::ios_base::fmtflags &amp;fmt=std::ios_base::fixed)</td></tr>
<tr class="memdesc:abf3d6c1b751e80fb651cf8f2fa2f7c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert numeric types to string.  <a href="namespacestr.html#abf3d6c1b751e80fb651cf8f2fa2f7c32">More...</a><br /></td></tr>
<tr class="separator:abf3d6c1b751e80fb651cf8f2fa2f7c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa560642b42f72dd03b56c5b60f918d43"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:aa560642b42f72dd03b56c5b60f918d43"><td class="memTemplItemLeft" align="right" valign="top">const CONSTEXPR std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#aa560642b42f72dd03b56c5b60f918d43">to_string</a> (const T &amp;value, const std::streamsize &amp;precision=8, const bool &amp;force_decimal=false)</td></tr>
<tr class="memdesc:aa560642b42f72dd03b56c5b60f918d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a floating-point number to a string, with variable precision and automatic truncation. <br  />
 This is a legacy support function.  <a href="namespacestr.html#aa560642b42f72dd03b56c5b60f918d43">More...</a><br /></td></tr>
<tr class="separator:aa560642b42f72dd03b56c5b60f918d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6def114db6fedf6a5d8334dc6e48ca"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a4e6def114db6fedf6a5d8334dc6e48ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#a4e6def114db6fedf6a5d8334dc6e48ca">toAlphaNumeric</a> (const T &amp;n, const bool &amp;upper=true) noexcept(false)</td></tr>
<tr class="memdesc:a4e6def114db6fedf6a5d8334dc6e48ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert any number between 0(0) to 36(Z) to its alphanumeric representation.  <a href="namespacestr.html#a4e6def114db6fedf6a5d8334dc6e48ca">More...</a><br /></td></tr>
<tr class="separator:a4e6def114db6fedf6a5d8334dc6e48ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462bac8b0d85ac958ab97f4e140d55ef"><td class="memItemLeft" align="right" valign="top">WINCONSTEXPR decimal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a462bac8b0d85ac958ab97f4e140d55ef">toBase10</a> (std::string number, const int &amp;fromBase) noexcept(false)</td></tr>
<tr class="memdesc:a462bac8b0d85ac958ab97f4e140d55ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a number from an arbitrary base to base 10 (decimal).  <a href="namespacestr.html#a462bac8b0d85ac958ab97f4e140d55ef">More...</a><br /></td></tr>
<tr class="separator:a462bac8b0d85ac958ab97f4e140d55ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bfcfb51a1c131387fd6d08629aba53"><td class="memItemLeft" align="right" valign="top">CONSTEXPR char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ae2bfcfb51a1c131387fd6d08629aba53">tolower</a> (const char &amp;c) noexcept</td></tr>
<tr class="memdesc:ae2bfcfb51a1c131387fd6d08629aba53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character to lowercase.  <a href="namespacestr.html#ae2bfcfb51a1c131387fd6d08629aba53">More...</a><br /></td></tr>
<tr class="separator:ae2bfcfb51a1c131387fd6d08629aba53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93882029690e5c1836bd3c4678da2003"><td class="memItemLeft" align="right" valign="top">CONSTEXPR int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a93882029690e5c1836bd3c4678da2003">tolower</a> (const int &amp;c) noexcept</td></tr>
<tr class="memdesc:a93882029690e5c1836bd3c4678da2003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character stored in an int to lowercase.  <a href="namespacestr.html#a93882029690e5c1836bd3c4678da2003">More...</a><br /></td></tr>
<tr class="separator:a93882029690e5c1836bd3c4678da2003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a231522683b17634fae04118974b559"><td class="memItemLeft" align="right" valign="top">CONSTEXPR wchar_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a5a231522683b17634fae04118974b559">tolower</a> (const wchar_t &amp;c) noexcept</td></tr>
<tr class="memdesc:a5a231522683b17634fae04118974b559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character to lowercase.  <a href="namespacestr.html#a5a231522683b17634fae04118974b559">More...</a><br /></td></tr>
<tr class="separator:a5a231522683b17634fae04118974b559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8411c2e7a2695f935f975cc9abcbc783"><td class="memItemLeft" align="right" valign="top">const WINCONSTEXPR std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a8411c2e7a2695f935f975cc9abcbc783">tolower</a> (std::string str) noexcept</td></tr>
<tr class="memdesc:a8411c2e7a2695f935f975cc9abcbc783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a convertible-character to lowercase.  <a href="namespacestr.html#a8411c2e7a2695f935f975cc9abcbc783">More...</a><br /></td></tr>
<tr class="separator:a8411c2e7a2695f935f975cc9abcbc783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f102d5131f381c87ed58a37b12a477e"><td class="memItemLeft" align="right" valign="top">const WINCONSTEXPR std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a3f102d5131f381c87ed58a37b12a477e">tolower</a> (std::wstring str) noexcept</td></tr>
<tr class="memdesc:a3f102d5131f381c87ed58a37b12a477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a convertible-character to lowercase.  <a href="namespacestr.html#a3f102d5131f381c87ed58a37b12a477e">More...</a><br /></td></tr>
<tr class="separator:a3f102d5131f381c87ed58a37b12a477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88947ca78984e05f41dd36fb221d32d6"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a88947ca78984e05f41dd36fb221d32d6">toMap</a> (std::stringstream &amp;data, const std::string &amp;delims, const char lineDelim='\n', const bool noSpace=true) noexcept</td></tr>
<tr class="memdesc:a88947ca78984e05f41dd36fb221d32d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a stringstream to a map of string keys &amp; string vars.  <a href="namespacestr.html#a88947ca78984e05f41dd36fb221d32d6">More...</a><br /></td></tr>
<tr class="separator:a88947ca78984e05f41dd36fb221d32d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae017529a0116f69b6d0edf9d9ea7f96"><td class="memItemLeft" align="right" valign="top">CONSTEXPR char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#aae017529a0116f69b6d0edf9d9ea7f96">toupper</a> (const char &amp;c) noexcept</td></tr>
<tr class="memdesc:aae017529a0116f69b6d0edf9d9ea7f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character to uppercase.  <a href="namespacestr.html#aae017529a0116f69b6d0edf9d9ea7f96">More...</a><br /></td></tr>
<tr class="separator:aae017529a0116f69b6d0edf9d9ea7f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fb669c01ac6edd91ed062f90069635"><td class="memItemLeft" align="right" valign="top">CONSTEXPR int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a16fb669c01ac6edd91ed062f90069635">toupper</a> (const int &amp;c) noexcept</td></tr>
<tr class="memdesc:a16fb669c01ac6edd91ed062f90069635"><td class="mdescLeft">&#160;</td><td class="mdescRight">TOUPPER.  <a href="namespacestr.html#a16fb669c01ac6edd91ed062f90069635">More...</a><br /></td></tr>
<tr class="separator:a16fb669c01ac6edd91ed062f90069635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfbac05c04a1a2028714d8e1674ef71"><td class="memItemLeft" align="right" valign="top">CONSTEXPR wchar_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a4cfbac05c04a1a2028714d8e1674ef71">toupper</a> (const wchar_t &amp;c) noexcept</td></tr>
<tr class="memdesc:a4cfbac05c04a1a2028714d8e1674ef71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character to lowercase.  <a href="namespacestr.html#a4cfbac05c04a1a2028714d8e1674ef71">More...</a><br /></td></tr>
<tr class="separator:a4cfbac05c04a1a2028714d8e1674ef71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d1751d71d4ad832f648e305c9e3b40"><td class="memItemLeft" align="right" valign="top">const WINCONSTEXPR std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a37d1751d71d4ad832f648e305c9e3b40">toupper</a> (std::string str) noexcept</td></tr>
<tr class="memdesc:a37d1751d71d4ad832f648e305c9e3b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a convertible-character to uppercase.  <a href="namespacestr.html#a37d1751d71d4ad832f648e305c9e3b40">More...</a><br /></td></tr>
<tr class="separator:a37d1751d71d4ad832f648e305c9e3b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae294fab98bc23e2063bda2780ea9ab55"><td class="memItemLeft" align="right" valign="top">const WINCONSTEXPR std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ae294fab98bc23e2063bda2780ea9ab55">toupper</a> (std::wstring str) noexcept</td></tr>
<tr class="memdesc:ae294fab98bc23e2063bda2780ea9ab55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a convertible-character to lowercase.  <a href="namespacestr.html#ae294fab98bc23e2063bda2780ea9ab55">More...</a><br /></td></tr>
<tr class="separator:ae294fab98bc23e2063bda2780ea9ab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9a7cdc58ff315c0dbdb4793171918f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#a9f9a7cdc58ff315c0dbdb4793171918f">toVector</a> (std::stringstream data, std::optional&lt; char &gt; delim=std::nullopt)</td></tr>
<tr class="memdesc:a9f9a7cdc58ff315c0dbdb4793171918f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a stringstream to a vector of strings, where each string contains one line from the stream.  <a href="namespacestr.html#a9f9a7cdc58ff315c0dbdb4793171918f">More...</a><br /></td></tr>
<tr class="separator:a9f9a7cdc58ff315c0dbdb4793171918f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d285a144a4f72cc7ac9fd1dd928f4e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestr.html#ae1d285a144a4f72cc7ac9fd1dd928f4e">trim</a> (std::string str, const std::string &amp;chars=&quot; \t\r\n\v&quot;)</td></tr>
<tr class="memdesc:ae1d285a144a4f72cc7ac9fd1dd928f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove preceeding &amp; trailing characters from a given string.  <a href="namespacestr.html#ae1d285a144a4f72cc7ac9fd1dd928f4e">More...</a><br /></td></tr>
<tr class="separator:ae1d285a144a4f72cc7ac9fd1dd928f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abea510ab5719c607e5a2ce61bde9e03e"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:abea510ab5719c607e5a2ce61bde9e03e"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">ConvertibleStringT</a> = std::constructible_from&lt;std::string, T...&gt;</td></tr>
<tr class="memdesc:abea510ab5719c607e5a2ce61bde9e03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows types that are constructor-convertible to std::string.  <a href="namespacestr.html#abea510ab5719c607e5a2ce61bde9e03e">More...</a><br /></td></tr>
<tr class="separator:abea510ab5719c607e5a2ce61bde9e03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains various string manipulation, conversion, and parsing functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a026f55497d251c5acccef7dd42148138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026f55497d251c5acccef7dd42148138">&#9670;&nbsp;</a></span>align_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::align_center </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>setw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Centers a string in the specified number of characters by addings spaces on either side. </p>
<p>@function align_center(string&amp;, unsigned int) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Input String, must be shorter in length than param setw. </td></tr>
    <tr><td class="paramname">setw</td><td>- Number of characters in the returned string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00157">157</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a82f6e6378f1869b65cce94f28f31d665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f6e6378f1869b65cce94f28f31d665">&#9670;&nbsp;</a></span>apply_to_each()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void str::apply_to_each </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::function&lt; int(int)&gt;, std::allocator&lt; std::function&lt; int(int)&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>funclist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a given list of functions to each character in a given string. </p>
<p>@function apply_to_each(string&amp;, ) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String ref to modify </td></tr>
    <tr><td class="paramname">funclist</td><td>- List of functions to apply </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00316">316</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a1f82a58e884afa2d7f6dcbe3ad884bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f82a58e884afa2d7f6dcbe3ad884bab">&#9670;&nbsp;</a></span>binaryToDecimal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long str::binaryToDecimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a binary number to its decimal equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary</td><td>Binary number contained within a string. This must NOT include any additional characters or prefixes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long long </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00218">218</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>

</div>
</div>
<a id="acd4ee543bc885f863faf20217f7142fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4ee543bc885f863faf20217f7142fe">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires std::convertible_to&lt;T1, std::string&gt;&amp;&amp; static std::convertible_to&lt;T2, std::string&gt; bool str::compare </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>case_sensitive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare 2 strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>- Convertible to string type. </td></tr>
    <tr><td class="paramname">T2</td><td>- Convertible to string type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- Comparison target 1 </td></tr>
    <tr><td class="paramname">right</td><td>- Comparison target 2 </td></tr>
    <tr><td class="paramname">case_sensitive</td><td>- When false, both strings are first converted to lowercase, then compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00140">140</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_acd4ee543bc885f863faf20217f7142fe_cgraph.svg" width="298" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a38d0037316e84612973026c052ec0616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d0037316e84612973026c052ec0616">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string str::concat </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate any number of string/char* types into a single string. </p>
<p>@function concat(T&amp;&amp;...) </p><ul>
<li>...T - Variadic String Types <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- An arbitrary number of strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00140">140</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a0f7141b95490d6fff216bb4dc520831d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7141b95490d6fff216bb4dc520831d">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool str::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a given string exists within another string. </p>
<p>@function contains(char) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to search in </td></tr>
    <tr><td class="paramname">ch</td><td>- Char to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00500">500</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a0ca8ec530dc360aeabadf2aa97423980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca8ec530dc360aeabadf2aa97423980">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool str::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if any of a list of delimiters is present in a given string. </p>
<p>@function contains(char) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to search in </td></tr>
    <tr><td class="paramname">delims</td><td>- String of delimiters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - ( true = At least one delimiter was found ) ( false = None of the given delimiters exist in the string ) </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00512">512</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a8a8c67ed7c199414fca456eef77b60e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8c67ed7c199414fca456eef77b60e7">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t str::count </td>
          <td>(</td>
          <td class="paramtype">std::stringstream &amp;&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of delimiters that occur within a given stringstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>Input Stringstream </td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="strutility_8hpp_source.html#l00090">90</a> of file <a class="el" href="strutility_8hpp_source.html">strutility.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a8a8c67ed7c199414fca456eef77b60e7_icgraph.svg" width="276" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="afc4713722f92ec455251092937a2540b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4713722f92ec455251092937a2540b">&#9670;&nbsp;</a></span>decimalToBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::decimalToBinary </td>
          <td>(</td>
          <td class="paramtype">long long const &amp;&#160;</td>
          <td class="paramname"><em>decimal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an integral number to its binary equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decimal</td><td>Decimal number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00236">236</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>

</div>
</div>
<a id="a8059cb6dea85450291ef813056734a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8059cb6dea85450291ef813056734a8e">&#9670;&nbsp;</a></span>decimalToHex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable&lt; std::stringstream &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::decimalToHex </td>
          <td>(</td>
          <td class="paramtype">long long const &amp;&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from decimal to hexadecimal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>Input decimal value. </td></tr>
    <tr><td class="paramname">...fmt</td><td>(Optional) Additional stream formatting objects to include before printing the value. <br  />
 Ex: std::uppercase, std::nouppercase, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00293">293</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>

</div>
</div>
<a id="a64641d820fe5e4997387b75be9df3b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64641d820fe5e4997387b75be9df3b97">&#9670;&nbsp;</a></span>decimalToHex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable&lt; std::stringstream &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::decimalToHex </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from decimal to hexadecimal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>Input decimal value as a string. </td></tr>
    <tr><td class="paramname">...fmt</td><td>(Optional) Additional stream formatting objects to include before printing the value. <br  />
 Ex: std::uppercase, std::nouppercase, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00310">310</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>

</div>
</div>
<a id="a25dcad1131572f82cbb30a06c81006b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dcad1131572f82cbb30a06c81006b0">&#9670;&nbsp;</a></span>endsWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable&lt; std::ostream &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR bool str::endsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given string ends with the given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String. </td></tr>
    <tr><td class="paramname">...suffix</td><td>Any number of types that can be represented with a string to check for. <br  />
 The resolved strings are checked in reverse sequential order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00064">64</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>

</div>
</div>
<a id="afe1efa734a2a1e8106138ce3b5995874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1efa734a2a1e8106138ce3b5995874">&#9670;&nbsp;</a></span>endsWithAny()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable&lt; std::ostream &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR bool str::endsWithAny </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>suffixes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given string ends with any of the given character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String. </td></tr>
    <tr><td class="paramname">...suffixes</td><td>Any number of independent suffixes to check. Each variable is checked independently of the others. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00092">92</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>

</div>
</div>
<a id="ac0941f8566d99a99085690ce06c8eec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0941f8566d99a99085690ce06c8eec1">&#9670;&nbsp;</a></span>equalsAny() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IGNORE_CASE = false, var::all_same_or_convertible&lt; std::string &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR bool str::equalsAny </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given string is equal to at least one other string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input string to compare. </td></tr>
    <tr><td class="paramname">...compare</td><td>Comparison Strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00104">104</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>

</div>
</div>
<a id="ad5a0bf2d97851e9b37bad14d9ed8d224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a0bf2d97851e9b37bad14d9ed8d224">&#9670;&nbsp;</a></span>equalsAny() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IGNORE_CASE = false, var::all_same_or_convertible&lt; std::wstring, char &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR bool str::equalsAny </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given string is equal to at least one other string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input string to compare. </td></tr>
    <tr><td class="paramname">...compare</td><td>Comparison Strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00119">119</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>

</div>
</div>
<a id="ad2842f64da212ac392e6c3385eb54a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2842f64da212ac392e6c3385eb54a3e">&#9670;&nbsp;</a></span>extractAllStrings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::tuple&lt;std::string, std::string, std::string&gt; &gt; str::extractAllStrings </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; const char, const char &gt;&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeDelim</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 3 substr, the first being the string until the first delim, the second being between the given delims, and the 3rd being the remaining string after the second delim. </p>
<p>@function extractString(string&amp;, pair&lt;char, char&gt;, bool, bool) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- The string to extract from. </td></tr>
    <tr><td class="paramname">delim</td><td>- ( first = opening delim ) ( second = closing delim ) </td></tr>
    <tr><td class="paramname">forward</td><td>- ( true = forward search ) ( false = reverse search ) </td></tr>
    <tr><td class="paramname">includeDelim</td><td>- (Default: false) When true, the returned string will contain first &amp; last delims. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;tuple&lt;string, string, string&gt;&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00482">482</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a93442c940874127d76612c31be16f7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93442c940874127d76612c31be16f7a7">&#9670;&nbsp;</a></span>extractString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; str::extractString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; const char, const char &gt;&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring from the first appearance of a given delimiter to the last. </p>
<p>@function extractString(string&amp;, pair&lt;char, char&gt;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- The string to extract from. </td></tr>
    <tr><td class="paramname">delim</td><td>- ( first = opening delim ) ( second = closing delim ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00446">446</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a2b36762bf1fb176cef1f3ab327ff2da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b36762bf1fb176cef1f3ab327ff2da6">&#9670;&nbsp;</a></span>extractString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; str::extractString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::string, std::string &gt;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeDelim</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring from the first appearance of a pair of delimiters, if no delimiter is found, uses the beginning/end of the given str. </p>
<p>@function extractString(string&amp;, pair&lt;char, char&gt;, bool, bool) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- The string to extract from. </td></tr>
    <tr><td class="paramname">delims</td><td>- ( first = opening delim ) ( second = closing delim ) </td></tr>
    <tr><td class="paramname">includeDelim</td><td>- (Default: false) When true, the returned string will contain first &amp; last delims. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00405">405</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a3e72dddafe6ddd37de81a5368ad75f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e72dddafe6ddd37de81a5368ad75f0e">&#9670;&nbsp;</a></span>extractString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; str::extractString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeDelim</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a contiguous substring from the first/last 2 appearances of the given delims. </p>
<p>@function extractString(string&amp;, char, char, bool, bool) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- The string to extract from. </td></tr>
    <tr><td class="paramname">delims</td><td>- String of delims used to determine the open/close delim </td></tr>
    <tr><td class="paramname">includeDelim</td><td>- (Default: false) When true, the returned string will contain first &amp; last delims. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00434">434</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="af3d243724dffd234a19646d7c7b13553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d243724dffd234a19646d7c7b13553">&#9670;&nbsp;</a></span>extractStringUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; str::extractStringUntil </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>begin</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substr between the beginning/end of a given string and the first occurrence of a given delimiter. </p>
<p>@function extractStringUntil(string&amp;, char) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- The string to extract from </td></tr>
    <tr><td class="paramname">delim</td><td>- Character used to determine the end of the substr </td></tr>
    <tr><td class="paramname">begin</td><td>- (Default: true) When true, extracts from the start of the string, else the back. </td></tr>
    <tr><td class="paramname">reverse</td><td>- (Default: false) When true, searches for the delim from the opposite side first </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00464">464</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ad4712ba59b2780def08bcddcca090fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4712ba59b2780def08bcddcca090fe6">&#9670;&nbsp;</a></span>find_any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string::iterator str::find_any </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>dels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find any of a given set of delimiters in a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ln</td><td>String to search. </td></tr>
    <tr><td class="paramname">dels</td><td>Delimiters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string::iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00076">76</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a37d8523d5d709baa8186137694899ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d8523d5d709baa8186137694899ac7">&#9670;&nbsp;</a></span>find_any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string::iterator str::find_any </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>dels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string::iterator &amp;&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find any of a given set of delimiters in a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ln</td><td>- String to search. </td></tr>
    <tr><td class="paramname">dels</td><td>- Delimiters to search for. </td></tr>
    <tr><td class="paramname">off</td><td>- Position to begin searching at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string::iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00066">66</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ab6fe51c1830b934a4ee82e7a6f6e9571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fe51c1830b934a4ee82e7a6f6e9571">&#9670;&nbsp;</a></span>fromAlphaNumeric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decimal str::fromAlphaNumeric </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an alphanumeric representation of a number to its decimal equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Any alphanumeric number representation from 0(0) to Z(36). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decimal </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00047">47</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_ab6fe51c1830b934a4ee82e7a6f6e9571_icgraph.svg" width="338" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ac02e5c31bf205b9b08d87b3c3c946baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02e5c31bf205b9b08d87b3c3c946baf">&#9670;&nbsp;</a></span>fromBase10() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR std::string str::fromBase10 </td>
          <td>(</td>
          <td class="paramtype">const decimal &amp;&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>toBase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a number from base 10 (decimal) to an arbitrary base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Input decimal number. </td></tr>
    <tr><td class="paramname">toBase</td><td>The target number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00115">115</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_ac02e5c31bf205b9b08d87b3c3c946baf_icgraph.svg" width="312" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a041f49f2d8f911fcb5e47ed6ff691ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041f49f2d8f911fcb5e47ed6ff691ab0">&#9670;&nbsp;</a></span>fromBase10() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR std::string str::fromBase10 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>toBase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a number from base 10 (decimal) to an arbitrary base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Input decimal number. </td></tr>
    <tr><td class="paramname">toBase</td><td>The target number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00149">149</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a041f49f2d8f911fcb5e47ed6ff691ab0_cgraph.svg" width="320" height="163"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ac833e4f5138a5dd64fb8985361215835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac833e4f5138a5dd64fb8985361215835">&#9670;&nbsp;</a></span>get_longest_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral RT, template&lt; class, class &gt; class Cont&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RT str::get_longest_string </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; std::string, std::allocator&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT&#160;</td>
          <td class="paramname"><em>offset</em> = <code>static_cast&lt;RT&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the length of the longest string in a given STL container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RT</td><td>- Return Type. Must be an integral value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>- Container to check. </td></tr>
    <tr><td class="paramname">offset</td><td>- Add this number to the returned value. Including this allows template auto-deduction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RT </dd></dl>

<p class="definition">Definition at line <a class="el" href="strutility_8hpp_source.html#l00075">75</a> of file <a class="el" href="strutility_8hpp_source.html">strutility.hpp</a>.</p>

</div>
</div>
<a id="a51a5ecaec1b7efa91322b8b79949f551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a5ecaec1b7efa91322b8b79949f551">&#9670;&nbsp;</a></span>getLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static size_t str::getLength </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>integral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the given integral number in digits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">integral</td><td>Input number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00024">24</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>

</div>
</div>
<a id="af632b5ef496a88eb6c6a50ee18385c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af632b5ef496a88eb6c6a50ee18385c62">&#9670;&nbsp;</a></span>getline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch , class Tr , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;Ch, Tr&gt;&amp; str::getline </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative to std::getline that accepts a string of delimiters rather than a single char. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ch</td><td>Char Type </td></tr>
    <tr><td class="paramname">Tr</td><td>Char Traits </td></tr>
    <tr><td class="paramname">A</td><td>Allocator Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Input Stream </td></tr>
    <tr><td class="paramname">str</td><td>Output String </td></tr>
    <tr><td class="paramname">delimiters</td><td>Delimiters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basic_istream&lt;Ch, Tr&gt;&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00229">229</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ae828e40bdc8eec39773e1a4dac9d7ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae828e40bdc8eec39773e1a4dac9d7ed3">&#9670;&nbsp;</a></span>getline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch , class Tr , class A , var::same_or_convertible&lt; Ch &gt;... DelimT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;Ch, Tr&gt;&amp; str::getline </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DelimT const &amp;...&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic variant of the getline function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ch</td><td>Char Type </td></tr>
    <tr><td class="paramname">Tr</td><td>Char Traits </td></tr>
    <tr><td class="paramname">A</td><td>Allocator Type </td></tr>
    <tr><td class="paramname">DelimT...</td><td>Any number of types that are the same or convertible to Ch </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Input stream ref </td></tr>
    <tr><td class="paramname">str</td><td>Output string ref </td></tr>
    <tr><td class="paramname">delimiters</td><td>Any number of characters to use as delimiters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basic_istream&lt;Ch, Tr&gt;&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strutility_8hpp_source.html#l00109">109</a> of file <a class="el" href="strutility_8hpp_source.html">strutility.hpp</a>.</p>

</div>
</div>
<a id="aea95d9955d4eaf233668351a309059db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea95d9955d4eaf233668351a309059db">&#9670;&nbsp;</a></span>getline_pred()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch , class Tr , class A , class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;Ch, Tr&gt;&amp; str::getline_pred </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative std::getline that accepts a predicate function rather than a char delimiter. </p>
<p>@function getline(basic_istream&lt;Ch, Tr&gt;&amp;, basic_string&lt;Ch, Tr, A&gt;&amp;, Pred) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ch</td><td>- Char Type </td></tr>
    <tr><td class="paramname">Tr</td><td>- Char Traits </td></tr>
    <tr><td class="paramname">A</td><td>- Allocator type </td></tr>
    <tr><td class="paramname">Pred</td><td>- Predicate type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>- Input stream </td></tr>
    <tr><td class="paramname">str</td><td>- Output string </td></tr>
    <tr><td class="paramname">p</td><td>- Predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basic_istream&lt;Ch, Tr&gt;&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00195">195</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_aea95d9955d4eaf233668351a309059db_icgraph.svg" width="304" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a47b165f72dcf094c144c89e27861888a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b165f72dcf094c144c89e27861888a">&#9670;&nbsp;</a></span>getNumberLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static size_t str::getNumberLength </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>integral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the given integral number in digits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">integral</td><td>Input number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00034">34</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>

</div>
</div>
<a id="a2665afb44cc6e90ff1e922639ea0e528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2665afb44cc6e90ff1e922639ea0e528">&#9670;&nbsp;</a></span>getStreamLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream::pos_type str::getStreamLength </td>
          <td>(</td>
          <td class="paramtype">std::stringstream &amp;&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of a given stringstream. </p>
<p>@function getLength(stringstream) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>- Ref to target stringstream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stringstream::pos_type </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00386">386</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a7afb39cb933e8727cfe4a84dbdad41c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afb39cb933e8727cfe4a84dbdad41c2">&#9670;&nbsp;</a></span>hexToDecimal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long str::hexToDecimal </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a given hexadecimal character to its decimal equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Input character. 1-9, A=10, B=11, C=12, D=13, E=14, F=15. Any character outside of this range will throw an exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long long </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00252">252</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a7afb39cb933e8727cfe4a84dbdad41c2_icgraph.svg" width="336" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a42c6b6a3bd47743a574df997a0bb8c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c6b6a3bd47743a574df997a0bb8c65">&#9670;&nbsp;</a></span>hexToDecimal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long str::hexToDecimal </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from hexadecimal to decimal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hex</td><td>Input hexadecimal value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00266">266</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a42c6b6a3bd47743a574df997a0bb8c65_cgraph.svg" width="336" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae6e5ba0568ee7667816d0ec5535adcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e5ba0568ee7667816d0ec5535adcb6">&#9670;&nbsp;</a></span>isbinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR bool str::isbinary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given ASCII string is entirely composed of valid binary digits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Any ASCII string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00154">154</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>

</div>
</div>
<a id="ae198f739f9fe6a95ba3d19dd14194031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae198f739f9fe6a95ba3d19dd14194031">&#9670;&nbsp;</a></span>isbinarydigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool str::isbinarydigit </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given ASCII character is a valid binary digit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Any ASCII character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="charcompare_8hpp_source.html#l00034">34</a> of file <a class="el" href="charcompare_8hpp_source.html">charcompare.hpp</a>.</p>

</div>
</div>
<a id="a043ca9b134b11dde323fbda2dc5992ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043ca9b134b11dde323fbda2dc5992ae">&#9670;&nbsp;</a></span>isdecimal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR bool str::isdecimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given ASCII string is entirely composed of valid decimal digits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Any ASCII string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00180">180</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a043ca9b134b11dde323fbda2dc5992ae_cgraph.svg" width="308" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa292888850b3b32095c1e48d65b9c645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa292888850b3b32095c1e48d65b9c645">&#9670;&nbsp;</a></span>isdecimaldigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool str::isdecimaldigit </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given ASCII string is entirely composed of valid decimal digits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Any ASCII character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="charcompare_8hpp_source.html#l00054">54</a> of file <a class="el" href="charcompare_8hpp_source.html">charcompare.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_aa292888850b3b32095c1e48d65b9c645_icgraph.svg" width="308" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a8150d7f427d4bf2eeccc7e56dfd35107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8150d7f427d4bf2eeccc7e56dfd35107">&#9670;&nbsp;</a></span>ishex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR bool str::ishex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given ASCII string is entirely composed of valid hexadecimal digits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Any ASCII string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00193">193</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>

</div>
</div>
<a id="aa1c0401e167ff247a2ed60e76c99e959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c0401e167ff247a2ed60e76c99e959">&#9670;&nbsp;</a></span>ishexdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool str::ishexdigit </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given ASCII character is a valid hexadecimal digit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Any ASCII character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="charcompare_8hpp_source.html#l00064">64</a> of file <a class="el" href="charcompare_8hpp_source.html">charcompare.hpp</a>.</p>

</div>
</div>
<a id="a0bd79fa931f1d21cb03de4642d230d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd79fa931f1d21cb03de4642d230d11">&#9670;&nbsp;</a></span>isoctal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR bool str::isoctal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given ASCII string is entirely composed of valid octal digits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Any ASCII string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00167">167</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>

</div>
</div>
<a id="a50f1cfbd61cff5c1c0975e2bc65c24e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f1cfbd61cff5c1c0975e2bc65c24e8">&#9670;&nbsp;</a></span>isoctaldigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool str::isoctaldigit </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given ASCII character is a valid octal digit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Any ASCII character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="charcompare_8hpp_source.html#l00044">44</a> of file <a class="el" href="charcompare_8hpp_source.html">charcompare.hpp</a>.</p>

</div>
</div>
<a id="aee442fd63b5198985d3bd6a126f1d399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee442fd63b5198985d3bd6a126f1d399">&#9670;&nbsp;</a></span>isquote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool str::isquote </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that checks if a given char is a quotation mark. (Accepts single or double quotes.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- Input char </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="charcompare_8hpp_source.html#l00018">18</a> of file <a class="el" href="charcompare_8hpp_source.html">charcompare.hpp</a>.</p>

</div>
</div>
<a id="acf8be91baa116c4582e66f6278db959f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8be91baa116c4582e66f6278db959f">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class, class &gt; class ContainerT, class ElemT , var::Streamable... VT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires constexpr static const std::convertible_to&lt;ElemT, std::string&gt; std::string str::join </td>
          <td>(</td>
          <td class="paramtype">const ContainerT&lt; ElemT, std::allocator&lt; ElemT &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT...&#160;</td>
          <td class="paramname"><em>separators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>- Container Type. Accepts most STL containers that hold a single type, such as: std::vector, std::set, etc. </td></tr>
    <tr><td class="paramname">ElemT</td><td>- Templated Element Type. Must be compatible with ostream::operator&lt;&lt;. </td></tr>
    <tr><td class="paramname">...VT</td><td>- Variadic Templated Separators. These are inserted in order between every element in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>- Input Container. Element type must have an overload for operator&lt;&lt; to allow insertion into an ostream. </td></tr>
    <tr><td class="paramname">...separators</td><td>- Any number of separators. These are inserted in order between every element. This can be used to apply formatting, insert spaces, or anything else. Note that separators are only inserted BETWEEN elements, and will never be trailing! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00031">31</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_acf8be91baa116c4582e66f6278db959f_cgraph.svg" width="264" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a718e93d72455a6f9af50cca592378f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718e93d72455a6f9af50cca592378f99">&#9670;&nbsp;</a></span>longest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t index, var::valid_string... Ts, template&lt; class... &gt; class Cont&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Cont&lt;std::tuple&lt;Ts...&gt;, std::allocator&lt;std::tuple&lt;Ts...&gt; &gt; &gt;::const_iterator str::longest </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the longest string in a container of string tuples. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index</td><td>Which index to call std::get on each time. Ex: 0 will compare the first string in each tuple. </td></tr>
    <tr><td class="paramname">...vT</td><td>Variadic type contained by the tuple. </td></tr>
    <tr><td class="paramname">Cont</td><td>Container type containing std::tuples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cont::const_iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00102">102</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="aff70a0416ef1eed4ca4968378d46f9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff70a0416ef1eed4ca4968378d46f9a9">&#9670;&nbsp;</a></span>longestLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string::size_type str::longestLength </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the longest string in a vector. </p>
<p>@function longestLength(vector&lt;string&gt;&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>- A vector of strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string::size_type </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00524">524</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a99874f5b703e388240420d5bec8557a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99874f5b703e388240420d5bec8557a3">&#9670;&nbsp;</a></span>matches_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool MatchCase = true, var::valid_string StrT, var::same_or_convertible&lt; StrT &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires var::at_least_one&lt;Ts...&gt; WINCONSTEXPR bool str::matches_any </td>
          <td>(</td>
          <td class="paramtype">const StrT &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>matches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a given string matches any of a list of strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatchCase</td><td>When true, matches are case sensitive, otherwise they are case insensitive. </td></tr>
    <tr><td class="paramname">StrT</td><td>String Type. </td></tr>
    <tr><td class="paramname">Ts...</td><td>Variadic number of types that are the same as StrT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String </td></tr>
    <tr><td class="paramname">matches</td><td>At least one string to compare to str. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00138">138</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a99874f5b703e388240420d5bec8557a3_cgraph.svg" width="146" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a99874f5b703e388240420d5bec8557a3_icgraph.svg" width="360" height="510"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5247d873952449905ce03aca93e5661d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5247d873952449905ce03aca93e5661d">&#9670;&nbsp;</a></span>NumberGrouping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; str::NumberGrouping </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatically insert commas between thousands when printing numbers. <br  />
 Example: "1000000" =&gt; "1,000,000". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>- (implicit) Target Output Stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strlocale_8hpp_source.html#l00120">120</a> of file <a class="el" href="strlocale_8hpp_source.html">strlocale.hpp</a>.</p>

</div>
</div>
<a id="a68189011dff0dc860136f8606606169c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68189011dff0dc860136f8606606169c">&#9670;&nbsp;</a></span>optional_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;size_t&gt; str::optional_find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::string::find function that returns an optional instead of std::string::npos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to search within. </td></tr>
    <tr><td class="paramname">search</td><td>- Character(s) to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;size_t&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00189">189</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="a01ad677b200aa91ac5ff1b6eda8b8ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ad677b200aa91ac5ff1b6eda8b8ea2">&#9670;&nbsp;</a></span>parseWithDelim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class, class &gt; class ContType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt; str::parseWithDelim </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delim</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; ContType&lt; std::function&lt; int(int)&gt;, std::allocator&lt; std::function&lt; int(int)&gt;&gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>remove_if</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a given string with a given delimiter, and return a vector of strings. </p>
<p>@function parseWithDelim(string&amp;, char, optional&lt;vector&lt;function&lt;int(int)&gt;&gt;&gt;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to parse </td></tr>
    <tr><td class="paramname">delim</td><td>- Delimiter to split string with </td></tr>
    <tr><td class="paramname">remove_if</td><td>- (Default: nullopt) When defined, applies the erase-remove idiom with the given functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00334">334</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a26bde2717215ef2e746a382003a8fc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bde2717215ef2e746a382003a8fc58">&#9670;&nbsp;</a></span>Placeholder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; str::Placeholder </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placeholder function that does nothing. Intended for use in ternary expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>- Target Output Stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strlocale_8hpp_source.html#l00109">109</a> of file <a class="el" href="strlocale_8hpp_source.html">strlocale.hpp</a>.</p>

</div>
</div>
<a id="a26bf9f8189aea4146e003477d8b7a62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bf9f8189aea4146e003477d8b7a62d">&#9670;&nbsp;</a></span>pos_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool str::pos_valid </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simply checks the given position value against std::string::npos. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Position value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- Position to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <br  />
 true - The given position is NOT equal to std::string::npos <br  />
 false - The given position is equal to std::string::npos, and is invalid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="strutility_8hpp_source.html#l00061">61</a> of file <a class="el" href="strutility_8hpp_source.html">strutility.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a26bf9f8189aea4146e003477d8b7a62d_icgraph.svg" width="463" height="147"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a16f757b5761b656d6ce1d15aee26507c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f757b5761b656d6ce1d15aee26507c">&#9670;&nbsp;</a></span>remove_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::remove_all </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all occurrences of a given list of delimiters from a given string. </p>
<p>@function remove_all(string&amp;, string&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to remove delimiters from. </td></tr>
    <tr><td class="paramname">delims</td><td>- Delimiter list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00304">304</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a30c7ac3d05115fd618a8779045def1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c7ac3d05115fd618a8779045def1c7">&#9670;&nbsp;</a></span>remove_all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string str::remove_all_of </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline wrapper for the erase-remove idiom that accepts a lambda predicate. </p>
<p>@function remove_all_of(string, F) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Input string. </td></tr>
    <tr><td class="paramname">pred</td><td>- Valid predicate functions for std::remove_if. (Accepts 1 int/char, returns 1 int/char). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00295">295</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ad1d6dd0849bbc57ab6970682bf0f8078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d6dd0849bbc57ab6970682bf0f8078">&#9670;&nbsp;</a></span>remove_whitespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::remove_whitespace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline wrapper for the erase-remove idiom that removes spaces. </p>
<p>@function remove_whitespace(string) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Pass-by-value string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00177">177</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_ad1d6dd0849bbc57ab6970682bf0f8078_icgraph.svg" width="326" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a9ef656ed2d8e17d0f1e68df1770058bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef656ed2d8e17d0f1e68df1770058bc">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::reverse </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse the characters of a given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00031">31</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a69b4c7c470963c0be1a41227ccf6f86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b4c7c470963c0be1a41227ccf6f86e">&#9670;&nbsp;</a></span>rsplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const WINCONSTEXPR std::pair&lt;std::string, std::string&gt; str::rsplit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0ull</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into a pair of strings by finding the first occurrence of a given delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String to Split. </td></tr>
    <tr><td class="paramname">delim</td><td>Delimiter to search for. The delimiter is discarded from the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::string, std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00590">590</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a69b4c7c470963c0be1a41227ccf6f86e_cgraph.svg" width="248" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aba157b4f80912e0c19b9ad7676d2c8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba157b4f80912e0c19b9ad7676d2c8d1">&#9670;&nbsp;</a></span>sanitize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string str::sanitize </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sanitize a string with a single predicate function. This is called by <a class="el" href="namespacestr.html#a30c7ac3d05115fd618a8779045def1c7" title="Inline wrapper for the erase-remove idiom that accepts a lambda predicate.">remove_all_of()</a>. </p>
<p>@function sanitize(string, F) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- Type returned by predicate function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Input string. </td></tr>
    <tr><td class="paramname">pred</td><td>- Input predicate function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00279">279</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a58590dd003d9759582ee1de6d1b6dc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58590dd003d9759582ee1de6d1b6dc9f">&#9670;&nbsp;</a></span>shortest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t index, var::valid_string... Ts, template&lt; class... &gt; class Cont&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Cont&lt;std::tuple&lt;Ts...&gt;, std::allocator&lt;std::tuple&lt;Ts...&gt; &gt; &gt;::const_iterator str::shortest </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; std::tuple&lt; Ts... &gt;, std::allocator&lt; std::tuple&lt; Ts... &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the shortest string in a container of string tuples. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index</td><td>Which index to call std::get on each time. Ex: 0 will compare the first string in each tuple. </td></tr>
    <tr><td class="paramname">...vT</td><td>Variadic type contained by the tuple. </td></tr>
    <tr><td class="paramname">Cont</td><td>Container type containing std::tuples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cont::const_iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00120">120</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
<a id="ab81d06e112031542961adc0b38bd0b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81d06e112031542961adc0b38bd0b2b">&#9670;&nbsp;</a></span>split() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const WINCONSTEXPR std::pair&lt;std::string, std::string&gt; str::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0ull</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into a pair of strings by finding the first occurrence of a given delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String to Split. </td></tr>
    <tr><td class="paramname">delim</td><td>Delimiter to search for. The delimiter is discarded from the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::string, std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00560">560</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_ab81d06e112031542961adc0b38bd0b2b_cgraph.svg" width="243" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aba03dcb83941ed1d96f1ae269db82fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba03dcb83941ed1d96f1ae269db82fc0">&#9670;&nbsp;</a></span>split() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const WINCONSTEXPR std::pair&lt;std::string, std::string&gt; str::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>discard_pos</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into a pair of strings by position. This is a simple wrapper to return a string split operation as a pair of strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String to Split. </td></tr>
    <tr><td class="paramname">pos</td><td>Position in the string to split. </td></tr>
    <tr><td class="paramname">discard_pos</td><td>When true, the character at the given position is discarded, otherwise the character is the first character of the second return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::string, std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00549">549</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ab8f17d783f53a8761d44c3304753da96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f17d783f53a8761d44c3304753da96">&#9670;&nbsp;</a></span>split() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const WINCONSTEXPR std::pair&lt;std::string, std::string&gt; str::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0ull</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into a pair of strings by finding the first occurrence of a given delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String to Split. </td></tr>
    <tr><td class="paramname">delim</td><td>List of delimiters to search for. Note that any character in the string may be used as the delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::string, std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00575">575</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_ab8f17d783f53a8761d44c3304753da96_cgraph.svg" width="243" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa4bf5f1b14b776ed8c1225f5c2870a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bf5f1b14b776ed8c1225f5c2870a92">&#9670;&nbsp;</a></span>split_by_words()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; str::split_by_words </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a given string into a vector of strings, with one word per index. </p>
<p>@function split_by_words(string&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>- Input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00260">260</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_aa4bf5f1b14b776ed8c1225f5c2870a92_cgraph.svg" width="304" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5bac9088e59d818dfcb958ca9fc1c673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bac9088e59d818dfcb958ca9fc1c673">&#9670;&nbsp;</a></span>split_to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;CharT&gt; str::split_to_vector </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, std::allocator&lt; CharT &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into a vector of characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character Type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character Traits </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;CharT&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00049">49</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ad50e9ee8aa4a8666ec47aefff8fa4bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50e9ee8aa4a8666ec47aefff8fa4bca">&#9670;&nbsp;</a></span>startsWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable&lt; std::ostream &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR bool str::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given string starts with the given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String. </td></tr>
    <tr><td class="paramname">...prefix</td><td>Any number of types that can be represented with a string to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00023">23</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>

</div>
</div>
<a id="a6ccb7cb4dfd45bb24e56b297a5cbe276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccb7cb4dfd45bb24e56b297a5cbe276">&#9670;&nbsp;</a></span>startsWithAny()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable&lt; std::ostream &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR bool str::startsWithAny </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>prefixes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given string starts with any of the given character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String. </td></tr>
    <tr><td class="paramname">...suffixes</td><td>Any number of independent suffixes to check. Each variable is checked independently of the others. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="strcompare_8hpp_source.html#l00051">51</a> of file <a class="el" href="strcompare_8hpp_source.html">strcompare.hpp</a>.</p>

</div>
</div>
<a id="a1c5f7adb1945d04eb55b0910ca01d09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5f7adb1945d04eb55b0910ca01d09f">&#9670;&nbsp;</a></span>stod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double str::stod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to double. Wrapper for std::stod that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00732">732</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="ae47e8a6851499957d48fdef435cd982a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47e8a6851499957d48fdef435cd982a">&#9670;&nbsp;</a></span>stof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float str::stof </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to float. Wrapper for std::stof that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00722">722</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="ad15a09e1f1896bc59792a58fe8e1fbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15a09e1f1896bc59792a58fe8e1fbe9">&#9670;&nbsp;</a></span>stoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int str::stoi </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to int. Wrapper for std::stoi that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00642">642</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="abf4cc36f0f7fbc735d3a7a282b8d9684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4cc36f0f7fbc735d3a7a282b8d9684">&#9670;&nbsp;</a></span>stol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long str::stol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to long. Wrapper for std::stol that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00672">672</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="af3ddec4fea92d79d63cd6caa33d084e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ddec4fea92d79d63cd6caa33d084e5">&#9670;&nbsp;</a></span>stold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double str::stold </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to double. Wrapper for std::stod that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00742">742</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="a2eb07fec74c9d4fc331166f5c7320aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb07fec74c9d4fc331166f5c7320aa0">&#9670;&nbsp;</a></span>stoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long str::stoll </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to long long. Wrapper for std::stol that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long long </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00682">682</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a2eb07fec74c9d4fc331166f5c7320aa0_icgraph.svg" width="260" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a8faa23ca70522123e1c17746265b4c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faa23ca70522123e1c17746265b4c40">&#9670;&nbsp;</a></span>stos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short str::stos </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to short. Wrapper for std::stoi that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>short </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00652">652</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="aff81b4fb51f25b185a6e0f219023631b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff81b4fb51f25b185a6e0f219023631b">&#9670;&nbsp;</a></span>stoui()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int str::stoui </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to unsigned int. Wrapper for static_cast&lt;unsigned&gt;(std::stoi) that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned int </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00662">662</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="ad150ce9485904ee33e3593e783324b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad150ce9485904ee33e3593e783324b09">&#9670;&nbsp;</a></span>stoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long str::stoul </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to unsigned long. Wrapper for std::stoul that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned long </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00692">692</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="a424d7e0db015c773dd069f863c2742e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424d7e0db015c773dd069f863c2742e0">&#9670;&nbsp;</a></span>stoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long str::stoull </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to unsigned long. Wrapper for std::stoul that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned long </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00702">702</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="a9abdc3487fffb1c2b871bf5b609081c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abdc3487fffb1c2b871bf5b609081c8">&#9670;&nbsp;</a></span>stous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short str::stous </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string to unsigned short. Wrapper for static_cast&lt;unsigned short&gt;(std::stoi) that can be passed as std::function. Does not throw exceptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
    <tr><td class="paramname">nextCh</td><td>Optional pointer that is set to the index of the next character in the string after the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned int </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00712">712</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="a18758598172725d265bdab25d48f5836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18758598172725d265bdab25d48f5836">&#9670;&nbsp;</a></span>streamify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::stringstream str::streamify </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a stringstream, inserts all of the given arguments, then move-returns the resulting stringstream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Ts</td><td>Variadic Templated Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>Arguments to insert into the stream, in order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::stringstream </dd></dl>

<p class="definition">Definition at line <a class="el" href="stringify_8hpp_source.html#l00024">24</a> of file <a class="el" href="stringify_8hpp_source.html">stringify.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a18758598172725d265bdab25d48f5836_cgraph.svg" width="303" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a724f84184c0c1cd75e91b4ac95f40768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724f84184c0c1cd75e91b4ac95f40768">&#9670;&nbsp;</a></span>stringify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static const std::string str::stringify </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the stringstream's str() function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Ts</td><td>- Variadic Templated Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>- Arguments to insert into the stream, in order. Nearly anything can be included here, so long as it has an operator&lt;&lt; stream insertion operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="stringify_8hpp_source.html#l00038">38</a> of file <a class="el" href="stringify_8hpp_source.html">stringify.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a724f84184c0c1cd75e91b4ac95f40768_cgraph.svg" width="294" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ac564c68f61fc9cb1018753365dfd9e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac564c68f61fc9cb1018753365dfd9e7b">&#9670;&nbsp;</a></span>stringify_split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static const std::vector&lt;std::string&gt; str::stringify_split </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a temporary stringstream and inserts all of the given arguments in sequential order, then uses the given delimiter to split the resulting string into a vector of strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DelimType</td><td>- Input Delimiter Type </td></tr>
    <tr><td class="paramname">...VT</td><td>- Variadic Templated Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- Delimiter to use when splitting the result. </td></tr>
    <tr><td class="paramname">...args</td><td>- Arguments to insert into the stream in sequential order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="stringify_8hpp_source.html#l00077">77</a> of file <a class="el" href="stringify_8hpp_source.html">stringify.hpp</a>.</p>

</div>
</div>
<a id="a30d969c8ad087fcf6a701f1241503eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d969c8ad087fcf6a701f1241503eab">&#9670;&nbsp;</a></span>stringify_split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static const std::vector&lt;std::string&gt; str::stringify_split </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a temporary stringstream and inserts all of the given arguments in sequential order, then uses the given delimiter to split the resulting string into a vector of strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DelimType</td><td>- Input Delimiter Type </td></tr>
    <tr><td class="paramname">...VT</td><td>- Variadic Templated Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- Delimiter to use when splitting the result. </td></tr>
    <tr><td class="paramname">...args</td><td>- Arguments to insert into the stream in sequential order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="stringify_8hpp_source.html#l00057">57</a> of file <a class="el" href="stringify_8hpp_source.html">stringify.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a30d969c8ad087fcf6a701f1241503eab_cgraph.svg" width="276" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a333afe30699add89dd4b33e8f8e965af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333afe30699add89dd4b33e8f8e965af">&#9670;&nbsp;</a></span>strip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::same_as&lt; char &gt;... DelimT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static WINCONSTEXPR std::string str::strip </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DelimT &amp;...&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all specified characters from the given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String </td></tr>
    <tr><td class="paramname">...delims</td><td>Any number of characters to remove from the given string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00658">658</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="acf63c00706c91be7da3f18b08a088224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf63c00706c91be7da3f18b08a088224">&#9670;&nbsp;</a></span>strip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static WINCONSTEXPR std::string str::strip </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all specified characters from the given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String </td></tr>
    <tr><td class="paramname">delims</td><td>A string containing all of the blacklisted characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00644">644</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a7346dfeb6d8d2d04a563649f4bf3cbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7346dfeb6d8d2d04a563649f4bf3cbca">&#9670;&nbsp;</a></span>strip_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::strip_line </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment_chars</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>whitespace_chars</em> = <code>&quot;&#160;\t\r\n\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes comments and preceeding/trailing whitespace from a given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input string. </td></tr>
    <tr><td class="paramname">comment_chars</td><td>Characters that should be treated as line comments, everything that appears after one of these characters is removed. </td></tr>
    <tr><td class="paramname">whitespace_chars</td><td>Characters that should be treated as whitespace, trailing/preceeding whitespace is removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00105">105</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ab3d3b4fc0b12749a6a027d5b0e58be81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d3b4fc0b12749a6a027d5b0e58be81">&#9670;&nbsp;</a></span>strip_line_multiCharComment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::strip_line_multiCharComment </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>comment_del</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>whitespace_chars</em> = <code>&quot;&#160;\t\r\n\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes more complex comments ( ex. C/JSON/html comments ) and preceeding/trailing whitespace from a given string. </p>
<p>@function strip_line(std::string, const Param&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- Input string. </td></tr>
    <tr><td class="paramname">comment_del</td><td>- String that should be treated as a comment. </td></tr>
    <tr><td class="paramname">whitespace_chars</td><td>- Characters that should be treated as whitespace, trailing/preceeding whitespace is removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00119">119</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a4a7fab88e397cd6251944c3d01a7438d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7fab88e397cd6251944c3d01a7438d">&#9670;&nbsp;</a></span>strip_preceeding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::same_as&lt; char &gt;... DelimT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string str::strip_preceeding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DelimT &amp;...&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove preceeding characters from a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DelimT</td><td>Variadic Input Types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float_str</td><td>Input String. </td></tr>
    <tr><td class="paramname">delims...</td><td>At least one character to remove from the beginning of the string. These are casted to char before comparing! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string_view </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00626">626</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a45c1b11a2e282a4fc8d38548eaf45f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c1b11a2e282a4fc8d38548eaf45f3c">&#9670;&nbsp;</a></span>strip_trailing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::same_as&lt; char &gt;... DelimT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string str::strip_trailing </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DelimT &amp;...&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove trailing characters from a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DelimT</td><td>Variadic Input Types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float_str</td><td>Input String. </td></tr>
    <tr><td class="paramname">delims...</td><td>At least one character to remove from the end of the string. These are casted to char before comparing! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string_view </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00607">607</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="a0d7b7e4aa9a634e2c97fda1bacf22e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7b7e4aa9a634e2c97fda1bacf22e9b">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::Streamable&lt; std::stringstream &gt; T, var::Streamable&lt; std::stringstream &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CONSTEXPR std::string str::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios_base::fmtflags &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>additionalFmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from any valid streamable type to a string. <br  />
 This function is a wrapper around <a class="el" href="namespacestr.html#a724f84184c0c1cd75e91b4ac95f40768" title="Creates a temporary stringstream, inserts all of the given arguments, then returns the result of the ...">stringify()</a>, with a focus on (numeric) =&gt; (string) conversions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A streamable input type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input value. </td></tr>
    <tr><td class="paramname">fmt</td><td>Format flags to apply to the stream. </td></tr>
    <tr><td class="paramname">...additionalFmt</td><td>Additional stream formatting functions to apply after the given fmtflags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00757">757</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="abf3d6c1b751e80fb651cf8f2fa2f7c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3d6c1b751e80fb651cf8f2fa2f7c32">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::numeric T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CONSTEXPR std::string str::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios_base::fmtflags &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>std::ios_base::fixed</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert numeric types to string. </p>
<p>Convert a boolean to a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input value. </td></tr>
    <tr><td class="paramname">fmt</td><td>Format flags to apply to the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00773">773</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="aa560642b42f72dd03b56c5b60f918d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa560642b42f72dd03b56c5b60f918d43">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CONSTEXPR std::string str::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::streamsize &amp;&#160;</td>
          <td class="paramname"><em>precision</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>force_decimal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a floating-point number to a string, with variable precision and automatic truncation. <br  />
 This is a legacy support function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input value. </td></tr>
    <tr><td class="paramname">precision</td><td>The number of digits to set the floating-point precision field to. </td></tr>
    <tr><td class="paramname">force_decimal</td><td>When true, the returned string will end with ".0" if there are no non-zero digits after the decimal point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00787">787</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="a4e6def114db6fedf6a5d8334dc6e48ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6def114db6fedf6a5d8334dc6e48ca">&#9670;&nbsp;</a></span>toAlphaNumeric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char str::toAlphaNumeric </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>upper</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert any number between 0(0) to 36(Z) to its alphanumeric representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Input number between 0 - 36. </td></tr>
    <tr><td class="paramname">upper</td><td>When true, the returned character is uppercase instead of lowercase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00065">65</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>

</div>
</div>
<a id="a462bac8b0d85ac958ab97f4e140d55ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462bac8b0d85ac958ab97f4e140d55ef">&#9670;&nbsp;</a></span>toBase10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR decimal str::toBase10 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>fromBase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a number from an arbitrary base to base 10 (decimal). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Input number as a string. </td></tr>
    <tr><td class="paramname">fromBase</td><td>The base of the input number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decimal </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmath_8hpp_source.html#l00081">81</a> of file <a class="el" href="strmath_8hpp_source.html">strmath.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a462bac8b0d85ac958ab97f4e140d55ef_cgraph.svg" width="338" height="163"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae2bfcfb51a1c131387fd6d08629aba53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bfcfb51a1c131387fd6d08629aba53">&#9670;&nbsp;</a></span>tolower() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONSTEXPR char str::tolower </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a character to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Char to convert. If the character is not an uppercase letter, it will be returned unmodified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00048">48</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="a93882029690e5c1836bd3c4678da2003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93882029690e5c1836bd3c4678da2003">&#9670;&nbsp;</a></span>tolower() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONSTEXPR int str::tolower </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a character stored in an int to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Input character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00035">35</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>

</div>
</div>
<a id="a5a231522683b17634fae04118974b559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a231522683b17634fae04118974b559">&#9670;&nbsp;</a></span>tolower() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONSTEXPR wchar_t str::tolower </td>
          <td>(</td>
          <td class="paramtype">const wchar_t &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a character to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Wide-char to convert. If the character is not an uppercase letter, it will be returned unmodified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>wchar_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00095">95</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a5a231522683b17634fae04118974b559_cgraph.svg" width="290" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a8411c2e7a2695f935f975cc9abcbc783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8411c2e7a2695f935f975cc9abcbc783">&#9670;&nbsp;</a></span>tolower() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const WINCONSTEXPR std::string str::tolower </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a convertible-character to lowercase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type that is convertible to char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Value to convert. If the value does not resolve to an uppercase letter, it will be returned as a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char</dd></dl>
<p>Convert a whole string to lowercase. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00080">80</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a8411c2e7a2695f935f975cc9abcbc783_cgraph.svg" width="290" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3f102d5131f381c87ed58a37b12a477e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f102d5131f381c87ed58a37b12a477e">&#9670;&nbsp;</a></span>tolower() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const WINCONSTEXPR std::wstring str::tolower </td>
          <td>(</td>
          <td class="paramtype">std::wstring&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a convertible-character to lowercase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type that is convertible to char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Value to convert. If the value does not resolve to an uppercase letter, it will be returned as a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char</dd></dl>
<p>Convert a whole string to lowercase. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00127">127</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a3f102d5131f381c87ed58a37b12a477e_cgraph.svg" width="290" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a88947ca78984e05f41dd36fb221d32d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88947ca78984e05f41dd36fb221d32d6">&#9670;&nbsp;</a></span>toMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; str::toMap </td>
          <td>(</td>
          <td class="paramtype">std::stringstream &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>lineDelim</em> = <code>'\n'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>noSpace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a stringstream to a map of string keys &amp; string vars. </p>
<p>@function toMap(stringstream&amp;, string&amp;, char) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- Stringstream ref </td></tr>
    <tr><td class="paramname">delims</td><td>- String containing delimiter chars </td></tr>
    <tr><td class="paramname">lineDelim</td><td>- (Default: '\n') Character to use as delimiter between map entries </td></tr>
    <tr><td class="paramname">noSpace</td><td>- (Default: true) When true, removes all whitespace after parsing each value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map&lt;string, string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00370">370</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a88947ca78984e05f41dd36fb221d32d6_cgraph.svg" width="326" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aae017529a0116f69b6d0edf9d9ea7f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae017529a0116f69b6d0edf9d9ea7f96">&#9670;&nbsp;</a></span>toupper() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONSTEXPR char str::toupper </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a character to uppercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- Char to convert. If the character is not a lowercase letter, it will be returned unmodified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00156">156</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_aae017529a0116f69b6d0edf9d9ea7f96_cgraph.svg" width="291" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a16fb669c01ac6edd91ed062f90069635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fb669c01ac6edd91ed062f90069635">&#9670;&nbsp;</a></span>toupper() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONSTEXPR int str::toupper </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TOUPPER. </p>
<p>Convert a character stored in an int to uppercase. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Input character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00143">143</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a16fb669c01ac6edd91ed062f90069635_cgraph.svg" width="291" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a4cfbac05c04a1a2028714d8e1674ef71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfbac05c04a1a2028714d8e1674ef71">&#9670;&nbsp;</a></span>toupper() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONSTEXPR wchar_t str::toupper </td>
          <td>(</td>
          <td class="paramtype">const wchar_t &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a character to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Wide-char to convert. If the character is not an uppercase letter, it will be returned unmodified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>wchar_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00203">203</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a4cfbac05c04a1a2028714d8e1674ef71_cgraph.svg" width="291" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a37d1751d71d4ad832f648e305c9e3b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d1751d71d4ad832f648e305c9e3b40">&#9670;&nbsp;</a></span>toupper() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const WINCONSTEXPR std::string str::toupper </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a convertible-character to uppercase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type that is convertible to char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- Value to convert. If the value does not resolve to a lowercase letter, it will be returned as a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char</dd></dl>
<p>Convert a whole string to lowercase. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- String to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00188">188</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_a37d1751d71d4ad832f648e305c9e3b40_cgraph.svg" width="291" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae294fab98bc23e2063bda2780ea9ab55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae294fab98bc23e2063bda2780ea9ab55">&#9670;&nbsp;</a></span>toupper() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const WINCONSTEXPR std::wstring str::toupper </td>
          <td>(</td>
          <td class="paramtype">std::wstring&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a convertible-character to lowercase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type that is convertible to char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Value to convert. If the value does not resolve to an uppercase letter, it will be returned as a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char</dd></dl>
<p>Convert a whole string to lowercase. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

<p class="definition">Definition at line <a class="el" href="strconv_8hpp_source.html#l00235">235</a> of file <a class="el" href="strconv_8hpp_source.html">strconv.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_ae294fab98bc23e2063bda2780ea9ab55_cgraph.svg" width="291" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a9f9a7cdc58ff315c0dbdb4793171918f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9a7cdc58ff315c0dbdb4793171918f">&#9670;&nbsp;</a></span>toVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; str::toVector </td>
          <td>(</td>
          <td class="paramtype">std::stringstream&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; char &gt;&#160;</td>
          <td class="paramname"><em>delim</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a stringstream to a vector of strings, where each string contains one line from the stream. </p>
<p>@function toVector(stringstream&amp;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- Stringstream ref to convert. </td></tr>
    <tr><td class="paramname">delim</td><td>- Optional char delimiter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00354">354</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>

</div>
</div>
<a id="ae1d285a144a4f72cc7ac9fd1dd928f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d285a144a4f72cc7ac9fd1dd928f4e">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string str::trim </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em> = <code>&quot;&#160;\t\r\n\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove preceeding &amp; trailing characters from a given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input string. </td></tr>
    <tr><td class="paramname">chars</td><td>Any number of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String without preceeding or trailing whitespace. </dd></dl>

<p class="definition">Definition at line <a class="el" href="strmanip_8hpp_source.html#l00087">87</a> of file <a class="el" href="strmanip_8hpp_source.html">strmanip.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_ae1d285a144a4f72cc7ac9fd1dd928f4e_cgraph.svg" width="243" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacestr_ae1d285a144a4f72cc7ac9fd1dd928f4e_icgraph.svg" width="300" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abea510ab5719c607e5a2ce61bde9e03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea510ab5719c607e5a2ce61bde9e03e">&#9670;&nbsp;</a></span>ConvertibleStringT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept str::ConvertibleStringT = std::constructible_from&lt;std::string, T...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows types that are constructor-convertible to std::string. </p>
<p>@concept ConvertibleStringT </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Input Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="str_8hpp_source.html#l00152">152</a> of file <a class="el" href="str_8hpp_source.html">str.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacestr.html">str</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
