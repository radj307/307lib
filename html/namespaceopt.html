<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>307Lib: opt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gear-2.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">307Lib
   </div>
   <div id="projectbrief">C++ Libraries made by radj307</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceopt.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">opt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing functions &amp; objects related to "optional" variables.  
<a href="namespaceopt.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopt_1_1_arg.html">Arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic argument wrapper class that exposes helper functions.  <a href="classopt_1_1_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_arg_container.html">ArgContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for storing and interacting with parsed commandline arguments. <br  />
 The container itself is upstream from the parsing functions, see the <a class="el" href="structopt_1_1_params_a_p_i2.html">ParamsAPI2</a> class.  <a href="structopt_1_1_arg_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopt_1_1_argument.html">Argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_capture_list.html">CaptureList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a list of arguments that should be allowed to capture additional arguments. This is used by the parse function.  <a href="structopt_1_1_capture_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1casting__optional.html">casting_optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for std::optional that includes several helpful typecasting functions. <br  />
 This inherits &amp; forwards most of its functionality from std::optional. <br  />
 See functions with the word "cast" in their name for a list of new functions.  <a href="structopt_1_1casting__optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_index.html">Index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant compile-time variant index object. This allows retrieving types from a variant argument with friendly names rather than raw numbers or types.  <a href="structopt_1_1_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_input_wrapper.html">InputWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acts as a wrapper for char &amp; std::string input types, to allow variadic functions to receive either chars or strings as input, and contains some helpful methods of its own.  <a href="structopt_1_1_input_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_params_a_p_i2.html">ParamsAPI2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopt_1_1_params_a_p_i3.html">ParamsAPI3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1unsafe__optional.html">unsafe_optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An "unsafe" wrapper object that allows implicit "casting"/retrieval of the underlying value. <br  />
 If the value isn't set, an exception will be thrown during an implicit casting operation, making debugging very difficult. <br  />
 For this reason, it is NOT recommended to use the <a class="el" href="structopt_1_1unsafe__optional.html" title="An &quot;unsafe&quot; wrapper object that allows implicit &quot;casting&quot;/retrieval of the underlying value....">unsafe_optional</a> object in production code.  <a href="structopt_1_1unsafe__optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_variant_arg.html">VariantArg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8048bb6c81102ec4e6d0e267f620f928"><td class="memItemLeft" align="right" valign="top"><a id="a8048bb6c81102ec4e6d0e267f620f928"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a8048bb6c81102ec4e6d0e267f620f928">ArgContainerIteratorContainerType</a> = std::vector&lt; <a class="el" href="namespaceopt.html#ac8ea4d4fea9f5e3c6d46ababc4463b6c">ArgContainerIteratorType</a> &gt;</td></tr>
<tr class="memdesc:a8048bb6c81102ec4e6d0e267f620f928"><td class="mdescLeft">&#160;</td><td class="mdescRight">drugs <br /></td></tr>
<tr class="separator:a8048bb6c81102ec4e6d0e267f620f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ea4d4fea9f5e3c6d46ababc4463b6c"><td class="memItemLeft" align="right" valign="top"><a id="ac8ea4d4fea9f5e3c6d46ababc4463b6c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ac8ea4d4fea9f5e3c6d46ababc4463b6c">ArgContainerIteratorType</a> = ArgContainerType::const_iterator</td></tr>
<tr class="memdesc:ac8ea4d4fea9f5e3c6d46ababc4463b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">brain on <br /></td></tr>
<tr class="separator:ac8ea4d4fea9f5e3c6d46ababc4463b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe78d40b04433e531b74164cade6e80"><td class="memItemLeft" align="right" valign="top"><a id="adfe78d40b04433e531b74164cade6e80"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#adfe78d40b04433e531b74164cade6e80">ArgContainerType</a> = std::vector&lt; <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &gt;</td></tr>
<tr class="memdesc:adfe78d40b04433e531b74164cade6e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">your <br /></td></tr>
<tr class="separator:adfe78d40b04433e531b74164cade6e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fe1cf3921afd090fb0313449e7f33c"><td class="memItemLeft" align="right" valign="top"><a id="ad1fe1cf3921afd090fb0313449e7f33c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Args</b> = <a class="el" href="structopt_1_1_params_a_p_i2.html">ParamsAPI2</a></td></tr>
<tr class="separator:ad1fe1cf3921afd090fb0313449e7f33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0f844a7b674bfe1ff370b8fd947f7d"><td class="memItemLeft" align="right" valign="top"><a id="acd0f844a7b674bfe1ff370b8fd947f7d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CompoundFlag</b> = <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; CompoundFlagType &gt;</td></tr>
<tr class="separator:acd0f844a7b674bfe1ff370b8fd947f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf40dd1ca21c5ccc9b88c3685a81c3c"><td class="memItemLeft" align="right" valign="top"><a id="a1cf40dd1ca21c5ccc9b88c3685a81c3c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CompoundFlagType</b> = std::pair&lt; std::vector&lt; char &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="separator:a1cf40dd1ca21c5ccc9b88c3685a81c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99cb5f86173816ad15e25ca7fe9ac90"><td class="memItemLeft" align="right" valign="top"><a id="aa99cb5f86173816ad15e25ca7fe9ac90"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Flag</b> = <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; <a class="el" href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">FlagType</a> &gt;</td></tr>
<tr class="separator:aa99cb5f86173816ad15e25ca7fe9ac90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b17b9a781806db5683836e034cb85b"><td class="memItemLeft" align="right" valign="top"><a id="a26b17b9a781806db5683836e034cb85b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">FlagType</a> = std::pair&lt; char, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a26b17b9a781806db5683836e034cb85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable type contained within a Flag instance. <br /></td></tr>
<tr class="separator:a26b17b9a781806db5683836e034cb85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17e17cf8257066ba09d74695ea5738d"><td class="memItemLeft" align="right" valign="top"><a id="ad17e17cf8257066ba09d74695ea5738d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Option</b> = <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; <a class="el" href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">OptionType</a> &gt;</td></tr>
<tr class="separator:ad17e17cf8257066ba09d74695ea5738d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af479aa967940ddaafb0bffd528f37bb3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af479aa967940ddaafb0bffd528f37bb3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#af479aa967940ddaafb0bffd528f37bb3">optional</a> = <a class="el" href="structopt_1_1casting__optional.html">casting_optional</a>&lt; T &gt;</td></tr>
<tr class="memdesc:af479aa967940ddaafb0bffd528f37bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the <a class="el" href="structopt_1_1casting__optional.html" title="Wrapper for std::optional that includes several helpful typecasting functions.   This inherits &amp; forw...">casting_optional</a> object.  <a href="namespaceopt.html#af479aa967940ddaafb0bffd528f37bb3">More...</a><br /></td></tr>
<tr class="separator:af479aa967940ddaafb0bffd528f37bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7cc9a2010617a6b4f9e9707419bcdd"><td class="memItemLeft" align="right" valign="top"><a id="a8e7cc9a2010617a6b4f9e9707419bcdd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">OptionType</a> = std::pair&lt; std::string, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a8e7cc9a2010617a6b4f9e9707419bcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable type contained within an Option instance. <br /></td></tr>
<tr class="separator:a8e7cc9a2010617a6b4f9e9707419bcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2207e5e307ef6a7b39dd228cff76ca"><td class="memItemLeft" align="right" valign="top"><a id="acc2207e5e307ef6a7b39dd228cff76ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Parameter</b> = <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; <a class="el" href="namespaceopt.html#aef25741f3063b9139b8440400ddf74da">ParameterType</a> &gt;</td></tr>
<tr class="separator:acc2207e5e307ef6a7b39dd228cff76ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef25741f3063b9139b8440400ddf74da"><td class="memItemLeft" align="right" valign="top"><a id="aef25741f3063b9139b8440400ddf74da"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#aef25741f3063b9139b8440400ddf74da">ParameterType</a> = std::string</td></tr>
<tr class="memdesc:aef25741f3063b9139b8440400ddf74da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable type contained within a Parameter instance. <br /></td></tr>
<tr class="separator:aef25741f3063b9139b8440400ddf74da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49449e838a7675e67e0859a749f3bdb"><td class="memItemLeft" align="right" valign="top"><a id="ae49449e838a7675e67e0859a749f3bdb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StrVec</b> = std::vector&lt; std::string &gt;</td></tr>
<tr class="separator:ae49449e838a7675e67e0859a749f3bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96ecf1c473dc1d8a07674fd1858fe4f"><td class="memItemLeft" align="right" valign="top"><a id="af96ecf1c473dc1d8a07674fd1858fe4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> = std::variant&lt; std::monostate, <a class="el" href="classopt_1_1_arg.html">Parameter</a>, <a class="el" href="classopt_1_1_arg.html">Option</a>, <a class="el" href="classopt_1_1_arg.html">Flag</a> &gt;</td></tr>
<tr class="memdesc:af96ecf1c473dc1d8a07674fd1858fe4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant type that allows std::monostate (null/all), Parameter, Option, &amp; Flag types, in that order. <br /></td></tr>
<tr class="separator:af96ecf1c473dc1d8a07674fd1858fe4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a14827521fec8e1c561ed24c2f151bc5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a14827521fec8e1c561ed24c2f151bc5f">can_capture_next</a> (StrVec::const_iterator &amp;here, const StrVec::const_iterator &amp;end)</td></tr>
<tr class="memdesc:a14827521fec8e1c561ed24c2f151bc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given iterator CAN capture the next argument by checking <br  />
 if the next argument is not prefixed with a '-' or is prefixed with '-' but is also a number. <br  />
 Does NOT check if the given iterator is present on the capturelist!  <a href="namespaceopt.html#a14827521fec8e1c561ed24c2f151bc5f">More...</a><br /></td></tr>
<tr class="separator:a14827521fec8e1c561ed24c2f151bc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cec335d3ad0b30de028267001ee9e1f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a9cec335d3ad0b30de028267001ee9e1f">count_prefix</a> (const std::string &amp;str, const size_t &amp;max_delims)</td></tr>
<tr class="memdesc:a9cec335d3ad0b30de028267001ee9e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of characters at the beginning of a string.  <a href="namespaceopt.html#a9cec335d3ad0b30de028267001ee9e1f">More...</a><br /></td></tr>
<tr class="separator:a9cec335d3ad0b30de028267001ee9e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a373c5a56e4d1774fc66862eb3a2559"><td class="memItemLeft" align="right" valign="top"><a id="a6a373c5a56e4d1774fc66862eb3a2559"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>fromCFT</b> (const CompoundFlagType &amp;compoundFlag)</td></tr>
<tr class="separator:a6a373c5a56e4d1774fc66862eb3a2559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8723d0634e92526f4ca97fc8a93221ab"><td class="memTemplParams" colspan="2"><a id="a8723d0634e92526f4ca97fc8a93221ab"></a>
template&lt;ValidArg T&gt; </td></tr>
<tr class="memitem:a8723d0634e92526f4ca97fc8a93221ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;arg) noexcept(false)</td></tr>
<tr class="separator:a8723d0634e92526f4ca97fc8a93221ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cbc1a34097e981ba67ffd4a2742a2d"><td class="memTemplParams" colspan="2"><a id="ab0cbc1a34097e981ba67ffd4a2742a2d"></a>
template&lt;ValidArg Type&gt; </td></tr>
<tr class="memitem:ab0cbc1a34097e981ba67ffd4a2742a2d"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const <a class="el" href="structopt_1_1_index.html">Index</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_index</b> () noexcept(false)</td></tr>
<tr class="separator:ab0cbc1a34097e981ba67ffd4a2742a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1fb4aca58dd467ca61ba5767236982"><td class="memItemLeft" align="right" valign="top"><a id="acf1fb4aca58dd467ca61ba5767236982"></a>
const WINCONSTEXPR std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_name</b> (const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;arg)</td></tr>
<tr class="separator:acf1fb4aca58dd467ca61ba5767236982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87116aac6d12df8ca8a223b9f4f10d3"><td class="memItemLeft" align="right" valign="top">const WINCONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ae87116aac6d12df8ca8a223b9f4f10d3">is_delimiter</a> (const char &amp;c)</td></tr>
<tr class="memdesc:ae87116aac6d12df8ca8a223b9f4f10d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given character is a valid delimiter, according to the static Settings_ArgParser object.  <a href="namespaceopt.html#ae87116aac6d12df8ca8a223b9f4f10d3">More...</a><br /></td></tr>
<tr class="separator:ae87116aac6d12df8ca8a223b9f4f10d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa297a02e7d112f878e200ef839a78605"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#aa297a02e7d112f878e200ef839a78605">is_number</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:aa297a02e7d112f878e200ef839a78605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given string is a valid integer, floating-point, or hexadecimal number. Hexadecimal numbers must be prefixed with "0x" (or "-0x") to be detected properly.  <a href="namespaceopt.html#aa297a02e7d112f878e200ef839a78605">More...</a><br /></td></tr>
<tr class="separator:aa297a02e7d112f878e200ef839a78605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e37cea59bb7d8675fc517ef3d0e590"><td class="memTemplParams" colspan="2"><a id="a81e37cea59bb7d8675fc517ef3d0e590"></a>
template&lt;ValidArg Type&gt; </td></tr>
<tr class="memitem:a81e37cea59bb7d8675fc517ef3d0e590"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_type</b> (const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;arg)</td></tr>
<tr class="separator:a81e37cea59bb7d8675fc517ef3d0e590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f6625ec874e68c060b1e04795dbb18"><td class="memTemplParams" colspan="2">template&lt;ValidArgType T&gt; </td></tr>
<tr class="memitem:a05f6625ec874e68c060b1e04795dbb18"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a05f6625ec874e68c060b1e04795dbb18">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; T &gt; &amp;arg)</td></tr>
<tr class="memdesc:a05f6625ec874e68c060b1e04795dbb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream insertion operator for the <a class="el" href="classopt_1_1_arg.html" title="Polymorphic argument wrapper class that exposes helper functions.">Arg</a> class. See the Settings_Arg static struct for changing output format settings.  <a href="namespaceopt.html#a05f6625ec874e68c060b1e04795dbb18">More...</a><br /></td></tr>
<tr class="separator:a05f6625ec874e68c060b1e04795dbb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e94744bdbabe51bbb6262321407d0ed"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a8e94744bdbabe51bbb6262321407d0ed">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;varg)</td></tr>
<tr class="memdesc:a8e94744bdbabe51bbb6262321407d0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">VariantArgumentType output stream insertion operator.  <a href="namespaceopt.html#a8e94744bdbabe51bbb6262321407d0ed">More...</a><br /></td></tr>
<tr class="separator:a8e94744bdbabe51bbb6262321407d0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7a38c94d8cdda8ce9f5f12e42b365e"><td class="memItemLeft" align="right" valign="top">const WINCONSTEXPR std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a2d7a38c94d8cdda8ce9f5f12e42b365e">paramVecToStrVec</a> (const std::vector&lt; <a class="el" href="classopt_1_1_arg.html">opt::Parameter</a> &gt; &amp;param_vec)</td></tr>
<tr class="memdesc:a2d7a38c94d8cdda8ce9f5f12e42b365e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of Parameters to a vector of strings.  <a href="namespaceopt.html#a2d7a38c94d8cdda8ce9f5f12e42b365e">More...</a><br /></td></tr>
<tr class="separator:a2d7a38c94d8cdda8ce9f5f12e42b365e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc103cb3c943291e5f87bccf7df19651"><td class="memTemplParams" colspan="2">template&lt;ValidInputType... VT&gt; </td></tr>
<tr class="memitem:abc103cb3c943291e5f87bccf7df19651"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#abc103cb3c943291e5f87bccf7df19651">parse</a> (auto &amp;&amp;args, const VT &amp;... captures)</td></tr>
<tr class="memdesc:abc103cb3c943291e5f87bccf7df19651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse commandline arguments into an <a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> instance. This function accepts a variadic capture list.  <a href="namespaceopt.html#abc103cb3c943291e5f87bccf7df19651">More...</a><br /></td></tr>
<tr class="separator:abc103cb3c943291e5f87bccf7df19651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4748ebaec4da7456a93cd981c205486d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopt.html#adfe78d40b04433e531b74164cade6e80">ArgContainerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a4748ebaec4da7456a93cd981c205486d">parse</a> (StrVec &amp;&amp;args, const <a class="el" href="structopt_1_1_capture_list.html">CaptureList</a> &amp;captures)</td></tr>
<tr class="memdesc:a4748ebaec4da7456a93cd981c205486d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse commandline arguments into an <a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> instance. <br  />
 <b><a class="el" href="classopt_1_1_argument.html">Argument</a> Types</b> <br  />
 - Parameters are any arguments that do not begin with a dash '-' character that were not captured by another argument type. <br  />
 - Options are arguments that begin with 2 dash '-' characters, and can capture additional arguments if the option name appears in the capture list. <br  />
 - Flags are arguments that begin with a single dash '-' character, are a single character in length, and can capture additional arguments. Flags can appear alone, or in "chains" where each character is treated as an individual flag. In a flag chain, only the last flag can capture additional arguments. <br  />
 <b>Capture Rules</b> <br  />
 - Only options/flags specified in the capture list are allowed to capture additional arguments. Capture list entries should not include a delimiter prefix. <br  />
 - Options/Flags cannot be captured under any circumstance. ex: "--opt --opt captured" results in "--opt", &amp; "--opt" + "captured". <br  />
 - If a flag in a chain should capture an argument (either with an '=' delimiter or by context), it must appear at the end of the chain. <br  />
 - Any captured arguments do not appear in the argument list by themselves, and must be accessed through the argument that captured them.  <a href="namespaceopt.html#a4748ebaec4da7456a93cd981c205486d">More...</a><br /></td></tr>
<tr class="separator:a4748ebaec4da7456a93cd981c205486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f10f2c576dc410b4cacf831c949d09"><td class="memTemplParams" colspan="2">template&lt;typename IntegerT , IntegerT index&gt; </td></tr>
<tr class="memitem:aa2f10f2c576dc410b4cacf831c949d09"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#aa2f10f2c576dc410b4cacf831c949d09">requires</a> (index==static_cast&lt; IntegerT &gt;(0)) &amp;&amp;std</td></tr>
<tr class="memdesc:aa2f10f2c576dc410b4cacf831c949d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a std::monostate type from a VariantArgumentType instance.  <a href="namespaceopt.html#aa2f10f2c576dc410b4cacf831c949d09">More...</a><br /></td></tr>
<tr class="separator:aa2f10f2c576dc410b4cacf831c949d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2159b287993f819a2fbadd4f5798d426"><td class="memTemplParams" colspan="2"><a id="a2159b287993f819a2fbadd4f5798d426"></a>
template&lt;ValidArg... Type&gt; </td></tr>
<tr class="memitem:a2159b287993f819a2fbadd4f5798d426"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>requires</b> (sizeof...(Type) &gt; 1) inline static const expr const bool is_type(const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;arg)</td></tr>
<tr class="separator:a2159b287993f819a2fbadd4f5798d426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c659d3e86eb26fb94a5915b10cbb74d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a7c659d3e86eb26fb94a5915b10cbb74d">strip_prefix</a> (const std::string &amp;str, const size_t &amp;max_delims)</td></tr>
<tr class="memdesc:a7c659d3e86eb26fb94a5915b10cbb74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count &amp; remove prefix delimiters from a given string. Returns the stripped string &amp; the number of removed delimiters.  <a href="namespaceopt.html#a7c659d3e86eb26fb94a5915b10cbb74d">More...</a><br /></td></tr>
<tr class="separator:a7c659d3e86eb26fb94a5915b10cbb74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2239544491f3103f7ba7e0fa4b631029"><td class="memItemLeft" align="right" valign="top"><a id="a2239544491f3103f7ba7e0fa4b631029"></a>
CompoundFlagType&#160;</td><td class="memItemRight" valign="bottom"><b>toCFT</b> (const std::string &amp;s, const std::optional&lt; std::string &gt; &amp;capture=std::nullopt)</td></tr>
<tr class="separator:a2239544491f3103f7ba7e0fa4b631029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a04d5b8af8ab1a4b5b4652723649e0"><td class="memItemLeft" align="right" valign="top">static WINCONSTEXPR StrVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ab2a04d5b8af8ab1a4b5b4652723649e0">vectorize</a> (const int &amp;sz, char **arr, const int &amp;off=0)</td></tr>
<tr class="memdesc:ab2a04d5b8af8ab1a4b5b4652723649e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a std::vector of std::strings from a char** array.  <a href="namespaceopt.html#ab2a04d5b8af8ab1a4b5b4652723649e0">More...</a><br /></td></tr>
<tr class="separator:ab2a04d5b8af8ab1a4b5b4652723649e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5d706641e94a68458cc42af1f1374d15"><td class="memTemplParams" colspan="2"><a id="a5d706641e94a68458cc42af1f1374d15"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5d706641e94a68458cc42af1f1374d15"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a5d706641e94a68458cc42af1f1374d15">CanHaveValueArgument</a> = std::same_as&lt;T, <a class="el" href="classopt_1_1_arg.html">Option</a>&gt; || std::same_as&lt;T, <a class="el" href="classopt_1_1_arg.html">Flag</a>&gt;</td></tr>
<tr class="memdesc:a5d706641e94a68458cc42af1f1374d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows types: ( Option | Flag ) <br /></td></tr>
<tr class="separator:a5d706641e94a68458cc42af1f1374d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1533898171fa583a49f5b0ae1d5d8986"><td class="memTemplParams" colspan="2"><a id="a1533898171fa583a49f5b0ae1d5d8986"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1533898171fa583a49f5b0ae1d5d8986"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a1533898171fa583a49f5b0ae1d5d8986">CanHaveValueArgumentType</a> = std::same_as&lt;T, <a class="el" href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">OptionType</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">FlagType</a>&gt; || std::same_as&lt;T, CompoundFlagType&gt;</td></tr>
<tr class="memdesc:a1533898171fa583a49f5b0ae1d5d8986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept constraint for Option/Flag pair subtypes. <br /></td></tr>
<tr class="separator:a1533898171fa583a49f5b0ae1d5d8986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c25f48273450116b3e78ecd10faf6f"><td class="memItemLeft" ><a id="a90c25f48273450116b3e78ecd10faf6f"></a>
struct {</td></tr>
<tr class="memitem:a392d65460b28c5c8b6d88356334944e3"><td class="memItemLeft" >
&#160;&#160;&#160;std::vector&lt; unsigned char &gt;&#160;&#160;&#160;<a class="el" href="namespaceopt.html#a4b432ae180b54ef2d396baba32f45d36">opt::divider</a> { ' ' }</td></tr>
<tr class="memdesc:a392d65460b28c5c8b6d88356334944e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows changing the divider between an argument's name and its optional capture argument. Recommended values are ' ' or '=', but any list of characters can be used. <br /></td></tr>
<tr class="separator:a392d65460b28c5c8b6d88356334944e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666c4a4886fd83181decea34f3a0991c"><td class="memItemLeft" >
&#160;&#160;&#160;bool&#160;&#160;&#160;<b>enclose_multiword_with_quotes</b> { true }</td></tr>
<tr class="separator:a666c4a4886fd83181decea34f3a0991c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab683ef3412779bd6181ee86cfa50afba"><td class="memItemLeft" >
&#160;&#160;&#160;bool&#160;&#160;&#160;<b>include_captures</b> { true }</td></tr>
<tr class="separator:ab683ef3412779bd6181ee86cfa50afba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfeaf509480b3ffb0e6d3835ee67fe4"><td class="memItemLeft" >
&#160;&#160;&#160;unsigned char&#160;&#160;&#160;<b>quote_char</b> { '\&quot;' }</td></tr>
<tr class="separator:a9dfeaf509480b3ffb0e6d3835ee67fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c25f48273450116b3e78ecd10faf6f"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a90c25f48273450116b3e78ecd10faf6f">Settings_Arg</a></td></tr>
<tr class="memdesc:a90c25f48273450116b3e78ecd10faf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows changing some formatting when using the Arg::operator&lt;&lt; / Arg::operator&gt;&gt; methods. <br /></td></tr>
<tr class="separator:a90c25f48273450116b3e78ecd10faf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad24f650521129892e3c4c134660796"><td class="memItemLeft" ><a id="a1ad24f650521129892e3c4c134660796"></a>
struct {</td></tr>
<tr class="memitem:afe21f7e58c02453f73b0ea1343b5bba6"><td class="memItemLeft" >
&#160;&#160;&#160;std::vector&lt; char &gt;&#160;&#160;&#160;<a class="el" href="namespaceopt.html#ae8c01003898064a3b55b55bf6674f58e">opt::delimiters</a> { '-' }</td></tr>
<tr class="memdesc:afe21f7e58c02453f73b0ea1343b5bba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines valid argument prefix delimiters. By default, only '-' characters are accepted, however on windows forward-slash characters may be desired as well. <br /></td></tr>
<tr class="separator:afe21f7e58c02453f73b0ea1343b5bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad24f650521129892e3c4c134660796"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a1ad24f650521129892e3c4c134660796">Settings_ArgParser</a></td></tr>
<tr class="memdesc:a1ad24f650521129892e3c4c134660796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static (non-const) settings structure. <br /></td></tr>
<tr class="separator:a1ad24f650521129892e3c4c134660796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a63481366bb7bf0406ff735e6b592f"><td class="memTemplParams" colspan="2"><a id="af5a63481366bb7bf0406ff735e6b592f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af5a63481366bb7bf0406ff735e6b592f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#af5a63481366bb7bf0406ff735e6b592f">ValidArg</a> = std::same_as&lt;T, <a class="el" href="classopt_1_1_arg.html">Parameter</a>&gt; || std::same_as&lt;T, <a class="el" href="classopt_1_1_arg.html">Option</a>&gt; || std::same_as&lt;T, <a class="el" href="classopt_1_1_arg.html">Flag</a>&gt;</td></tr>
<tr class="memdesc:af5a63481366bb7bf0406ff735e6b592f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows types: ( Parameter | Option | Flag ) <br /></td></tr>
<tr class="separator:af5a63481366bb7bf0406ff735e6b592f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf158337f8369478586d64f9162afead"><td class="memTemplParams" colspan="2"><a id="adf158337f8369478586d64f9162afead"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adf158337f8369478586d64f9162afead"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#adf158337f8369478586d64f9162afead">ValidArgOrCompound</a> = <a class="el" href="namespaceopt.html#af5a63481366bb7bf0406ff735e6b592f">ValidArg</a>&lt;T&gt; || std::same_as&lt;T, <a class="el" href="classopt_1_1_arg.html">CompoundFlag</a>&gt;</td></tr>
<tr class="memdesc:adf158337f8369478586d64f9162afead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows types: ( Parameter | Option | Flag | CompoundFlag ) <br /></td></tr>
<tr class="separator:adf158337f8369478586d64f9162afead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5186e11563094f28ac3182224bfbc6d0"><td class="memTemplParams" colspan="2"><a id="a5186e11563094f28ac3182224bfbc6d0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5186e11563094f28ac3182224bfbc6d0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a5186e11563094f28ac3182224bfbc6d0">ValidArgType</a> = std::same_as&lt;T, <a class="el" href="namespaceopt.html#aef25741f3063b9139b8440400ddf74da">ParameterType</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">OptionType</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">FlagType</a>&gt;</td></tr>
<tr class="memdesc:a5186e11563094f28ac3182224bfbc6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept constraint for <a class="el" href="classopt_1_1_arg.html" title="Polymorphic argument wrapper class that exposes helper functions.">Arg</a> subtypes. Allows: ( ParameterType | OptionType | FlagType ) <br /></td></tr>
<tr class="separator:a5186e11563094f28ac3182224bfbc6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab813ec0eff2e375a9077ceffaae2f8a6"><td class="memTemplParams" colspan="2"><a id="ab813ec0eff2e375a9077ceffaae2f8a6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab813ec0eff2e375a9077ceffaae2f8a6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ValidArgTypeOrCompound</b> = <a class="el" href="namespaceopt.html#a5186e11563094f28ac3182224bfbc6d0">ValidArgType</a>&lt;T&gt; || std::same_as&lt;T, CompoundFlagType&gt;</td></tr>
<tr class="separator:ab813ec0eff2e375a9077ceffaae2f8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec060dbd6131b7d040118d88d50f6f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ec060dbd6131b7d040118d88d50f6f1"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a0ec060dbd6131b7d040118d88d50f6f1">ValidInputType</a> = std::same_as&lt;T, <a class="el" href="structopt_1_1_input_wrapper.html">InputWrapper</a>&gt; || std::same_as&lt;T, std::string&gt; || std::same_as&lt;T, char&gt; || std::convertible_to&lt;T, char&gt; || std::convertible_to&lt;T, std::string&gt;</td></tr>
<tr class="memdesc:a0ec060dbd6131b7d040118d88d50f6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that allows <a class="el" href="structopt_1_1_input_wrapper.html" title="Acts as a wrapper for char &amp; std::string input types, to allow variadic functions to receive either c...">InputWrapper</a>, char, std::string, or any types that are implicitly convertible to char or std::string.  <a href="namespaceopt.html#a0ec060dbd6131b7d040118d88d50f6f1">More...</a><br /></td></tr>
<tr class="separator:a0ec060dbd6131b7d040118d88d50f6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing functions &amp; objects related to "optional" variables. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="af479aa967940ddaafb0bffd528f37bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af479aa967940ddaafb0bffd528f37bb3">&#9670;&nbsp;</a></span>optional</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#af479aa967940ddaafb0bffd528f37bb3">opt::optional</a> = typedef <a class="el" href="structopt_1_1casting__optional.html">casting_optional</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the <a class="el" href="structopt_1_1casting__optional.html" title="Wrapper for std::optional that includes several helpful typecasting functions.   This inherits &amp; forw...">casting_optional</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="optional_8hpp_source.html#l00166">166</a> of file <a class="el" href="optional_8hpp_source.html">optional.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a14827521fec8e1c561ed24c2f151bc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14827521fec8e1c561ed24c2f151bc5f">&#9670;&nbsp;</a></span>can_capture_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::can_capture_next </td>
          <td>(</td>
          <td class="paramtype">StrVec::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>here</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrVec::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given iterator CAN capture the next argument by checking <br  />
 if the next argument is not prefixed with a '-' or is prefixed with '-' but is also a number. <br  />
 Does NOT check if the given iterator is present on the capturelist! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">here</td><td>The current iterator position. </td></tr>
    <tr><td class="paramname">end</td><td>The position of the end of the iterable range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00052">52</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a14827521fec8e1c561ed24c2f151bc5f_cgraph.svg" width="318" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a9cec335d3ad0b30de028267001ee9e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cec335d3ad0b30de028267001ee9e1f">&#9670;&nbsp;</a></span>count_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t opt::count_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of characters at the beginning of a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...DelimT</td><td>Variadic Template, accepts only char types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input string. </td></tr>
    <tr><td class="paramname">max_delims</td><td>Maximum number of delimiters to count before stopping, even if more delimiters exist. </td></tr>
    <tr><td class="paramname">...delims</td><td>At least one char type to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00067">67</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a9cec335d3ad0b30de028267001ee9e1f_cgraph.svg" width="318" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a9cec335d3ad0b30de028267001ee9e1f_icgraph.svg" width="448" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae87116aac6d12df8ca8a223b9f4f10d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87116aac6d12df8ca8a223b9f4f10d3">&#9670;&nbsp;</a></span>is_delimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const WINCONSTEXPR bool opt::is_delimiter </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given character is a valid delimiter, according to the static Settings_ArgParser object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Input Character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00022">22</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_ae87116aac6d12df8ca8a223b9f4f10d3_icgraph.svg" width="624" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa297a02e7d112f878e200ef839a78605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa297a02e7d112f878e200ef839a78605">&#9670;&nbsp;</a></span>is_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::is_number </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given string is a valid integer, floating-point, or hexadecimal number. Hexadecimal numbers must be prefixed with "0x" (or "-0x") to be detected properly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00032">32</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_aa297a02e7d112f878e200ef839a78605_icgraph.svg" width="344" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a05f6625ec874e68c060b1e04795dbb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f6625ec874e68c060b1e04795dbb18">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ValidArgType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; opt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream insertion operator for the <a class="el" href="classopt_1_1_arg.html" title="Polymorphic argument wrapper class that exposes helper functions.">Arg</a> class. See the Settings_Arg static struct for changing output format settings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- The type of argument contained within the given <a class="el" href="classopt_1_1_arg.html" title="Polymorphic argument wrapper class that exposes helper functions.">Arg</a> class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>- (implicit) Output Stream. </td></tr>
    <tr><td class="paramname">arg</td><td>- (implicit) <a class="el" href="classopt_1_1_argument.html">Argument</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00131">131</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a05f6625ec874e68c060b1e04795dbb18_cgraph.svg" width="322" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8e94744bdbabe51bbb6262321407d0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e94744bdbabe51bbb6262321407d0ed">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; opt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;&#160;</td>
          <td class="paramname"><em>varg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VariantArgumentType output stream insertion operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>- (implicit) Output Stream Reference. </td></tr>
    <tr><td class="paramname">varg</td><td>- (implicit) VariantArgumentType instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="_variant_argument_type_8hpp_source.html#l00149">149</a> of file <a class="el" href="_variant_argument_type_8hpp_source.html">VariantArgumentType.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a8e94744bdbabe51bbb6262321407d0ed_cgraph.svg" width="342" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a2d7a38c94d8cdda8ce9f5f12e42b365e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7a38c94d8cdda8ce9f5f12e42b365e">&#9670;&nbsp;</a></span>paramVecToStrVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const WINCONSTEXPR std::vector&lt;std::string&gt; opt::paramVecToStrVec </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classopt_1_1_arg.html">opt::Parameter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>param_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a vector of Parameters to a vector of strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param_vec</td><td>A vector of Parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="_params_a_p_i2_8hpp_source.html#l00434">434</a> of file <a class="el" href="_params_a_p_i2_8hpp_source.html">ParamsAPI2.hpp</a>.</p>

</div>
</div>
<a id="abc103cb3c943291e5f87bccf7df19651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc103cb3c943291e5f87bccf7df19651">&#9670;&nbsp;</a></span>parse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ValidInputType... VT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto opt::parse </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VT &amp;...&#160;</td>
          <td class="paramname"><em>captures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse commandline arguments into an <a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> instance. This function accepts a variadic capture list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VT...</td><td>Variadic Templated Input Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Commandline arguments as a vector of strings, in order and including argv[0]. </td></tr>
    <tr><td class="paramname">...captures</td><td>The names of any arguments that are allowed to capture additional arguments. If the user attempts to force capture an argument by appending "=..." but the argument is not on this list, the invalid capture will be added separately as a parameter instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00216">216</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>

</div>
</div>
<a id="a4748ebaec4da7456a93cd981c205486d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4748ebaec4da7456a93cd981c205486d">&#9670;&nbsp;</a></span>parse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopt.html#adfe78d40b04433e531b74164cade6e80">ArgContainerType</a> opt::parse </td>
          <td>(</td>
          <td class="paramtype">StrVec &amp;&amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopt_1_1_capture_list.html">CaptureList</a> &amp;&#160;</td>
          <td class="paramname"><em>captures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse commandline arguments into an <a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> instance. <br  />
 <b><a class="el" href="classopt_1_1_argument.html">Argument</a> Types</b> <br  />
 - Parameters are any arguments that do not begin with a dash '-' character that were not captured by another argument type. <br  />
 - Options are arguments that begin with 2 dash '-' characters, and can capture additional arguments if the option name appears in the capture list. <br  />
 - Flags are arguments that begin with a single dash '-' character, are a single character in length, and can capture additional arguments. Flags can appear alone, or in "chains" where each character is treated as an individual flag. In a flag chain, only the last flag can capture additional arguments. <br  />
 <b>Capture Rules</b> <br  />
 - Only options/flags specified in the capture list are allowed to capture additional arguments. Capture list entries should not include a delimiter prefix. <br  />
 - Options/Flags cannot be captured under any circumstance. ex: "--opt --opt captured" results in "--opt", &amp; "--opt" + "captured". <br  />
 - If a flag in a chain should capture an argument (either with an '=' delimiter or by context), it must appear at the end of the chain. <br  />
 - Any captured arguments do not appear in the argument list by themselves, and must be accessed through the argument that captured them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Commandline arguments as a vector of strings, in order and including argv[0]. </td></tr>
    <tr><td class="paramname">captures</td><td>A <a class="el" href="structopt_1_1_capture_list.html" title="Contains a list of arguments that should be allowed to capture additional arguments....">CaptureList</a> instance specifying which arguments are allowed to capture other arguments as their parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00138">138</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a4748ebaec4da7456a93cd981c205486d_cgraph.svg" width="624" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa2f10f2c576dc410b4cacf831c949d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f10f2c576dc410b4cacf831c949d09">&#9670;&nbsp;</a></span>requires()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerT , IntegerT index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">opt::requires </td>
          <td>(</td>
          <td class="paramtype">index&#160;</td>
          <td class="paramname"> = <code>=&#160;static_cast&lt;IntegerT&gt;(0)</code></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a std::monostate type from a VariantArgumentType instance. </p>
<p>Retrieve a Flag type from a VariantArgumentType instance.</p>
<p>Retrieve an Option type from a VariantArgumentType instance.</p>
<p>Retrieve a Parameter type from a VariantArgumentType instance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegerT</td><td>- Integer type </td></tr>
    <tr><td class="paramname">index</td><td>- The index number of the type to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>- The argument to retrieve a type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::monostate</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegerT</td><td>- Integer type </td></tr>
    <tr><td class="paramname">index</td><td>- The index number of the type to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>- The argument to retrieve a type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parameter</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegerT</td><td>- Integer type </td></tr>
    <tr><td class="paramname">index</td><td>- The index number of the type to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>- The argument to retrieve a type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Option</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegerT</td><td>- Integer type </td></tr>
    <tr><td class="paramname">index</td><td>- The index number of the type to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>- The argument to retrieve a type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag </dd></dl>

<p class="definition">Definition at line <a class="el" href="_variant_argument_type_8hpp_source.html#l00095">95</a> of file <a class="el" href="_variant_argument_type_8hpp_source.html">VariantArgumentType.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_aa2f10f2c576dc410b4cacf831c949d09_cgraph.svg" width="318" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a7c659d3e86eb26fb94a5915b10cbb74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c659d3e86eb26fb94a5915b10cbb74d">&#9670;&nbsp;</a></span>strip_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, size_t&gt; opt::strip_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count &amp; remove prefix delimiters from a given string. Returns the stripped string &amp; the number of removed delimiters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input string. </td></tr>
    <tr><td class="paramname">max_delims</td><td>Maximum number of delimiter prefixes to strip before stopping, even if there are more delimiters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::string, size_t&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00084">84</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a7c659d3e86eb26fb94a5915b10cbb74d_cgraph.svg" width="490" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a7c659d3e86eb26fb94a5915b10cbb74d_icgraph.svg" width="270" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab2a04d5b8af8ab1a4b5b4652723649e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a04d5b8af8ab1a4b5b4652723649e0">&#9670;&nbsp;</a></span>vectorize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static WINCONSTEXPR StrVec opt::vectorize </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>off</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a std::vector of std::strings from a char** array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Size of the array. </td></tr>
    <tr><td class="paramname">arr</td><td>Array. </td></tr>
    <tr><td class="paramname">off</td><td>The index to start at. Any elements that are skipped are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StrVec </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00224">224</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0ec060dbd6131b7d040118d88d50f6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec060dbd6131b7d040118d88d50f6f1">&#9670;&nbsp;</a></span>ValidInputType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept opt::ValidInputType = std::same_as&lt;T, <a class="el" href="structopt_1_1_input_wrapper.html">InputWrapper</a>&gt; || std::same_as&lt;T, std::string&gt; || std::same_as&lt;T, char&gt; || std::convertible_to&lt;T, char&gt; || std::convertible_to&lt;T, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept that allows <a class="el" href="structopt_1_1_input_wrapper.html" title="Acts as a wrapper for char &amp; std::string input types, to allow variadic functions to receive either c...">InputWrapper</a>, char, std::string, or any types that are implicitly convertible to char or std::string. </p>
<p>@concept ValidInputType </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_arg_container_8hpp_source.html#l00043">43</a> of file <a class="el" href="_arg_container_8hpp_source.html">ArgContainer.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceopt.html">opt</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
