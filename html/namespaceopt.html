<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>307Lib: opt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gear-2.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">307Lib
   </div>
   <div id="projectbrief">C++ Libraries made by radj307</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceopt.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">opt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopt_1_1_params_a_p_i2.html">ParamsAPI2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopt_1_1_arg.html">Arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic argument wrapper class that exposes helper functions.  <a href="classopt_1_1_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_input_wrapper.html">InputWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acts as a wrapper for char &amp; std::string input types, to allow variadic functions to receive either chars or strings as input, and contains some helpful methods of its own.  <a href="structopt_1_1_input_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_arg_container.html">ArgContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for storing and interacting with parsed commandline arguments. <br  />
 The container itself is upstream from the parsing functions, see the <a class="el" href="classopt_1_1_params_a_p_i2.html">ParamsAPI2</a> class.  <a href="structopt_1_1_arg_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_capture_list.html">CaptureList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a list of arguments that should be allowed to capture additional arguments. This is used by the parse function.  <a href="structopt_1_1_capture_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_index.html">Index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant compile-time variant index object. This allows retrieving types from a variant argument with friendly names rather than raw numbers or types.  <a href="structopt_1_1_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_virtual_argument.html">VirtualArgument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aef25741f3063b9139b8440400ddf74da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#aef25741f3063b9139b8440400ddf74da">ParameterType</a> = std::string</td></tr>
<tr class="memdesc:aef25741f3063b9139b8440400ddf74da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable type contained within a Parameter instance.  <a href="namespaceopt.html#aef25741f3063b9139b8440400ddf74da">More...</a><br /></td></tr>
<tr class="separator:aef25741f3063b9139b8440400ddf74da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7cc9a2010617a6b4f9e9707419bcdd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">OptionType</a> = std::pair&lt; std::string, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a8e7cc9a2010617a6b4f9e9707419bcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable type contained within an Option instance.  <a href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">More...</a><br /></td></tr>
<tr class="separator:a8e7cc9a2010617a6b4f9e9707419bcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b17b9a781806db5683836e034cb85b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">FlagType</a> = std::pair&lt; char, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a26b17b9a781806db5683836e034cb85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable type contained within a Flag instance.  <a href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">More...</a><br /></td></tr>
<tr class="separator:a26b17b9a781806db5683836e034cb85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2615cfb6e34b4dccd6647b8181ed4c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#abd2615cfb6e34b4dccd6647b8181ed4c">Option</a> = <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; std::pair&lt; std::string, std::optional&lt; std::string &gt; &gt;&gt;</td></tr>
<tr class="separator:abd2615cfb6e34b4dccd6647b8181ed4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d501ad109f7745fa44e7f52e6380d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a80d501ad109f7745fa44e7f52e6380d0">Flag</a> = <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; std::pair&lt; char, std::optional&lt; std::string &gt; &gt;&gt;</td></tr>
<tr class="separator:a80d501ad109f7745fa44e7f52e6380d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316557ae32d1fffe2b704fc5c9638807"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a316557ae32d1fffe2b704fc5c9638807">Parameter</a> = <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; std::string &gt;</td></tr>
<tr class="separator:a316557ae32d1fffe2b704fc5c9638807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe78d40b04433e531b74164cade6e80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#adfe78d40b04433e531b74164cade6e80">ArgContainerType</a> = std::vector&lt; <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &gt;</td></tr>
<tr class="memdesc:adfe78d40b04433e531b74164cade6e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">your  <a href="namespaceopt.html#adfe78d40b04433e531b74164cade6e80">More...</a><br /></td></tr>
<tr class="separator:adfe78d40b04433e531b74164cade6e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ea4d4fea9f5e3c6d46ababc4463b6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ac8ea4d4fea9f5e3c6d46ababc4463b6c">ArgContainerIteratorType</a> = ArgContainerType::const_iterator</td></tr>
<tr class="memdesc:ac8ea4d4fea9f5e3c6d46ababc4463b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">brain on  <a href="namespaceopt.html#ac8ea4d4fea9f5e3c6d46ababc4463b6c">More...</a><br /></td></tr>
<tr class="separator:ac8ea4d4fea9f5e3c6d46ababc4463b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8048bb6c81102ec4e6d0e267f620f928"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a8048bb6c81102ec4e6d0e267f620f928">ArgContainerIteratorContainerType</a> = std::vector&lt; <a class="el" href="namespaceopt.html#ac8ea4d4fea9f5e3c6d46ababc4463b6c">ArgContainerIteratorType</a> &gt;</td></tr>
<tr class="memdesc:a8048bb6c81102ec4e6d0e267f620f928"><td class="mdescLeft">&#160;</td><td class="mdescRight">drugs  <a href="namespaceopt.html#a8048bb6c81102ec4e6d0e267f620f928">More...</a><br /></td></tr>
<tr class="separator:a8048bb6c81102ec4e6d0e267f620f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49449e838a7675e67e0859a749f3bdb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ae49449e838a7675e67e0859a749f3bdb">StrVec</a> = std::vector&lt; std::string &gt;</td></tr>
<tr class="separator:ae49449e838a7675e67e0859a749f3bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96ecf1c473dc1d8a07674fd1858fe4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> = std::variant&lt; std::monostate, <a class="el" href="namespaceopt.html#a316557ae32d1fffe2b704fc5c9638807">Parameter</a>, <a class="el" href="namespaceopt.html#abd2615cfb6e34b4dccd6647b8181ed4c">Option</a>, <a class="el" href="namespaceopt.html#a80d501ad109f7745fa44e7f52e6380d0">Flag</a> &gt;</td></tr>
<tr class="memdesc:af96ecf1c473dc1d8a07674fd1858fe4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant type that allows std::monostate (null/all), Parameter, Option, &amp; Flag types, in that order.  <a href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">More...</a><br /></td></tr>
<tr class="separator:af96ecf1c473dc1d8a07674fd1858fe4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2db34133c5d7b2d0bbcdddd6c4c6a016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_layer_8hpp.html#a7ff62ace4b261d15f42b604ae7d6614d">_CONSTEXPR</a> const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a2db34133c5d7b2d0bbcdddd6c4c6a016">paramVecToStrVec</a> (const std::vector&lt; <a class="el" href="namespaceopt.html#a316557ae32d1fffe2b704fc5c9638807">opt::Parameter</a> &gt; &amp;param_vec)</td></tr>
<tr class="separator:a2db34133c5d7b2d0bbcdddd6c4c6a016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f6625ec874e68c060b1e04795dbb18"><td class="memTemplParams" colspan="2">template&lt;ValidArgType T&gt; </td></tr>
<tr class="memitem:a05f6625ec874e68c060b1e04795dbb18"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a05f6625ec874e68c060b1e04795dbb18">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; T &gt; &amp;arg)</td></tr>
<tr class="memdesc:a05f6625ec874e68c060b1e04795dbb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream insertion operator for the <a class="el" href="classopt_1_1_arg.html" title="Polymorphic argument wrapper class that exposes helper functions.">Arg</a> class. See the Settings_Arg static struct for changing output format settings.  <a href="namespaceopt.html#a05f6625ec874e68c060b1e04795dbb18">More...</a><br /></td></tr>
<tr class="separator:a05f6625ec874e68c060b1e04795dbb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294152959e0541808274c2ff685f8eb6"><td class="memItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a294152959e0541808274c2ff685f8eb6">is_delimiter</a> (const char &amp;c)</td></tr>
<tr class="memdesc:a294152959e0541808274c2ff685f8eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given character is a valid delimiter, according to the static Settings_ArgParser object.  <a href="namespaceopt.html#a294152959e0541808274c2ff685f8eb6">More...</a><br /></td></tr>
<tr class="separator:a294152959e0541808274c2ff685f8eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa297a02e7d112f878e200ef839a78605"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#aa297a02e7d112f878e200ef839a78605">is_number</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:aa297a02e7d112f878e200ef839a78605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given string is a valid integer, floating-point, or hexadecimal number. Hexadecimal numbers must be prefixed with "0x" (or "-0x") to be detected properly.  <a href="namespaceopt.html#aa297a02e7d112f878e200ef839a78605">More...</a><br /></td></tr>
<tr class="separator:aa297a02e7d112f878e200ef839a78605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14827521fec8e1c561ed24c2f151bc5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a14827521fec8e1c561ed24c2f151bc5f">can_capture_next</a> (StrVec::const_iterator &amp;here, const StrVec::const_iterator &amp;end)</td></tr>
<tr class="memdesc:a14827521fec8e1c561ed24c2f151bc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given iterator CAN capture the next argument by checking <br  />
 if the next argument is not prefixed with a '-' or is prefixed with '-' but is also a number. <br  />
 Does NOT check if the given iterator is present on the capturelist!  <a href="namespaceopt.html#a14827521fec8e1c561ed24c2f151bc5f">More...</a><br /></td></tr>
<tr class="separator:a14827521fec8e1c561ed24c2f151bc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cec335d3ad0b30de028267001ee9e1f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a9cec335d3ad0b30de028267001ee9e1f">count_prefix</a> (const std::string &amp;str, const size_t &amp;max_delims)</td></tr>
<tr class="memdesc:a9cec335d3ad0b30de028267001ee9e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of characters at the beginning of a string.  <a href="namespaceopt.html#a9cec335d3ad0b30de028267001ee9e1f">More...</a><br /></td></tr>
<tr class="separator:a9cec335d3ad0b30de028267001ee9e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c659d3e86eb26fb94a5915b10cbb74d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a7c659d3e86eb26fb94a5915b10cbb74d">strip_prefix</a> (const std::string &amp;str, const size_t &amp;max_delims)</td></tr>
<tr class="memdesc:a7c659d3e86eb26fb94a5915b10cbb74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count &amp; remove prefix delimiters from a given string. Returns the stripped string &amp; the number of removed delimiters.  <a href="namespaceopt.html#a7c659d3e86eb26fb94a5915b10cbb74d">More...</a><br /></td></tr>
<tr class="separator:a7c659d3e86eb26fb94a5915b10cbb74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4a82db2d7eef33350854b082131315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopt.html#adfe78d40b04433e531b74164cade6e80">ArgContainerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a3d4a82db2d7eef33350854b082131315">parse</a> (const <a class="el" href="namespaceopt.html#ae49449e838a7675e67e0859a749f3bdb">StrVec</a> &amp;args, const <a class="el" href="structopt_1_1_capture_list.html">CaptureList</a> &amp;captures)</td></tr>
<tr class="memdesc:a3d4a82db2d7eef33350854b082131315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse commandline arguments into an <a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> instance. <br  />
 <b>Argument Types</b> <br  />
 - Parameters are any arguments that do not begin with a dash '-' character that were not captured by another argument type. <br  />
 - Options are arguments that begin with 2 dash '-' characters, and can capture additional arguments if the option name appears in the capture list. <br  />
 - Flags are arguments that begin with a single dash '-' character, are a single character in length, and can capture additional arguments. Flags can appear alone, or in "chains" where each character is treated as an individual flag. In a flag chain, only the last flag can capture additional arguments. <br  />
 <b>Capture Rules</b> <br  />
 - Only options/flags specified in the capture list are allowed to capture additional arguments. Capture list entries should not include a delimiter prefix. <br  />
 - Options/Flags cannot be captured under any circumstance. ex: "--opt --opt captured" results in "--opt", &amp; "--opt" + "captured". <br  />
 - If a flag in a chain should capture an argument (either with an '=' delimiter or by context), it must appear at the end of the chain. <br  />
 - Any captured arguments do not appear in the argument list by themselves, and must be accessed through the argument that captured them.  <a href="namespaceopt.html#a3d4a82db2d7eef33350854b082131315">More...</a><br /></td></tr>
<tr class="separator:a3d4a82db2d7eef33350854b082131315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc103cb3c943291e5f87bccf7df19651"><td class="memTemplParams" colspan="2">template&lt;ValidInputType... VT&gt; </td></tr>
<tr class="memitem:abc103cb3c943291e5f87bccf7df19651"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#abc103cb3c943291e5f87bccf7df19651">parse</a> (auto &amp;&amp;args, const VT &amp;... captures)</td></tr>
<tr class="memdesc:abc103cb3c943291e5f87bccf7df19651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse commandline arguments into an <a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> instance. This function accepts a variadic capture list.  <a href="namespaceopt.html#abc103cb3c943291e5f87bccf7df19651">More...</a><br /></td></tr>
<tr class="separator:abc103cb3c943291e5f87bccf7df19651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4af6b73cdba4c9f27bf3fcd9b747e57"><td class="memItemLeft" align="right" valign="top">constexpr static <a class="el" href="namespaceopt.html#ae49449e838a7675e67e0859a749f3bdb">StrVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ad4af6b73cdba4c9f27bf3fcd9b747e57">vectorize</a> (const int &amp;sz, char **arr, const int &amp;off=0)</td></tr>
<tr class="memdesc:ad4af6b73cdba4c9f27bf3fcd9b747e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a std::vector of std::strings from a char** array.  <a href="namespaceopt.html#ad4af6b73cdba4c9f27bf3fcd9b747e57">More...</a><br /></td></tr>
<tr class="separator:ad4af6b73cdba4c9f27bf3fcd9b747e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33135292342ae5562b5fe2321d0cbe18"><td class="memTemplParams" colspan="2">template&lt;ValidArg Type&gt; </td></tr>
<tr class="memitem:a33135292342ae5562b5fe2321d0cbe18"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="structopt_1_1_index.html">Index</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a33135292342ae5562b5fe2321d0cbe18">get_index</a> () noexcept(false)</td></tr>
<tr class="separator:a33135292342ae5562b5fe2321d0cbe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e37cea59bb7d8675fc517ef3d0e590"><td class="memTemplParams" colspan="2">template&lt;ValidArg Type&gt; </td></tr>
<tr class="memitem:a81e37cea59bb7d8675fc517ef3d0e590"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a81e37cea59bb7d8675fc517ef3d0e590">is_type</a> (const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;arg)</td></tr>
<tr class="separator:a81e37cea59bb7d8675fc517ef3d0e590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2159b287993f819a2fbadd4f5798d426"><td class="memTemplParams" colspan="2">template&lt;ValidArg... Type&gt; </td></tr>
<tr class="memitem:a2159b287993f819a2fbadd4f5798d426"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a2159b287993f819a2fbadd4f5798d426">requires</a> (sizeof...(Type) &gt; 1) inline static const expr const bool <a class="el" href="namespaceopt.html#a81e37cea59bb7d8675fc517ef3d0e590">is_type</a>(const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;arg)</td></tr>
<tr class="separator:a2159b287993f819a2fbadd4f5798d426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e447cf9b68ce004f7a44a49cae6404"><td class="memItemLeft" align="right" valign="top">constexpr const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ab3e447cf9b68ce004f7a44a49cae6404">get_name</a> (const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;arg)</td></tr>
<tr class="separator:ab3e447cf9b68ce004f7a44a49cae6404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f10f2c576dc410b4cacf831c949d09"><td class="memTemplParams" colspan="2">template&lt;typename IntegerT , IntegerT index&gt; </td></tr>
<tr class="memitem:aa2f10f2c576dc410b4cacf831c949d09"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#aa2f10f2c576dc410b4cacf831c949d09">requires</a> (index==static_cast&lt; IntegerT &gt;(0)) &amp;&amp;std</td></tr>
<tr class="memdesc:aa2f10f2c576dc410b4cacf831c949d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a std::monostate type from a VariantArgumentType instance.  <a href="namespaceopt.html#aa2f10f2c576dc410b4cacf831c949d09">More...</a><br /></td></tr>
<tr class="separator:aa2f10f2c576dc410b4cacf831c949d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8723d0634e92526f4ca97fc8a93221ab"><td class="memTemplParams" colspan="2">template&lt;ValidArg T&gt; </td></tr>
<tr class="memitem:a8723d0634e92526f4ca97fc8a93221ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a8723d0634e92526f4ca97fc8a93221ab">get</a> (const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;arg) noexcept(false)</td></tr>
<tr class="separator:a8723d0634e92526f4ca97fc8a93221ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e94744bdbabe51bbb6262321407d0ed"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a8e94744bdbabe51bbb6262321407d0ed">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;varg)</td></tr>
<tr class="memdesc:a8e94744bdbabe51bbb6262321407d0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">VariantArgumentType output stream insertion operator.  <a href="namespaceopt.html#a8e94744bdbabe51bbb6262321407d0ed">More...</a><br /></td></tr>
<tr class="separator:a8e94744bdbabe51bbb6262321407d0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5186e11563094f28ac3182224bfbc6d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5186e11563094f28ac3182224bfbc6d0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a5186e11563094f28ac3182224bfbc6d0">ValidArgType</a> = std::same_as&lt;T, <a class="el" href="namespaceopt.html#aef25741f3063b9139b8440400ddf74da">ParameterType</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">OptionType</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">FlagType</a>&gt;</td></tr>
<tr class="memdesc:a5186e11563094f28ac3182224bfbc6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept constraint for <a class="el" href="classopt_1_1_arg.html" title="Polymorphic argument wrapper class that exposes helper functions.">Arg</a> subtypes. Allows: ( ParameterType | OptionType | FlagType )  <a href="namespaceopt.html#a5186e11563094f28ac3182224bfbc6d0">More...</a><br /></td></tr>
<tr class="separator:a5186e11563094f28ac3182224bfbc6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1533898171fa583a49f5b0ae1d5d8986"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1533898171fa583a49f5b0ae1d5d8986"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a1533898171fa583a49f5b0ae1d5d8986">CanHaveValueArgumentType</a> = std::same_as&lt;T, <a class="el" href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">OptionType</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">FlagType</a>&gt;</td></tr>
<tr class="memdesc:a1533898171fa583a49f5b0ae1d5d8986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept constraint for Option/Flag pair subtypes.  <a href="namespaceopt.html#a1533898171fa583a49f5b0ae1d5d8986">More...</a><br /></td></tr>
<tr class="separator:a1533898171fa583a49f5b0ae1d5d8986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c25f48273450116b3e78ecd10faf6f"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:ab683ef3412779bd6181ee86cfa50afba"><td class="memItemLeft" >&#160;&#160;&#160;bool&#160;&#160;&#160;<a class="el" href="namespaceopt.html#af1925c987700a22c15487e69b49ea84d">opt::include_captures</a> { true }</td></tr>
<tr class="separator:ab683ef3412779bd6181ee86cfa50afba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666c4a4886fd83181decea34f3a0991c"><td class="memItemLeft" >&#160;&#160;&#160;bool&#160;&#160;&#160;<a class="el" href="namespaceopt.html#a4f3475adc55a9472fc5dd5cb5ed19dab">opt::enclose_multiword_with_quotes</a> { true }</td></tr>
<tr class="separator:a666c4a4886fd83181decea34f3a0991c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfeaf509480b3ffb0e6d3835ee67fe4"><td class="memItemLeft" >&#160;&#160;&#160;unsigned char&#160;&#160;&#160;<a class="el" href="namespaceopt.html#aed4bb1fd09af1fecb79401708e096a6f">opt::quote_char</a> { '\&quot;' }</td></tr>
<tr class="separator:a9dfeaf509480b3ffb0e6d3835ee67fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392d65460b28c5c8b6d88356334944e3"><td class="memItemLeft" >&#160;&#160;&#160;std::vector&lt; unsigned char &gt;&#160;&#160;&#160;<a class="el" href="namespaceopt.html#a4b432ae180b54ef2d396baba32f45d36">opt::divider</a> { ' ' }</td></tr>
<tr class="memdesc:a392d65460b28c5c8b6d88356334944e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows changing the divider between an argument's name and its optional capture argument. Recommended values are ' ' or '=', but any list of characters can be used.  <a href="structopt_1_1_0d0.html#a392d65460b28c5c8b6d88356334944e3">More...</a><br /></td></tr>
<tr class="separator:a392d65460b28c5c8b6d88356334944e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c25f48273450116b3e78ecd10faf6f"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a90c25f48273450116b3e78ecd10faf6f">Settings_Arg</a></td></tr>
<tr class="memdesc:a90c25f48273450116b3e78ecd10faf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows changing some formatting when using the Arg::operator&lt;&lt; / Arg::operator&gt;&gt; methods.  <a href="namespaceopt.html#a90c25f48273450116b3e78ecd10faf6f">More...</a><br /></td></tr>
<tr class="separator:a90c25f48273450116b3e78ecd10faf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a63481366bb7bf0406ff735e6b592f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af5a63481366bb7bf0406ff735e6b592f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#af5a63481366bb7bf0406ff735e6b592f">ValidArg</a> = std::same_as&lt;T, <a class="el" href="namespaceopt.html#a316557ae32d1fffe2b704fc5c9638807">Parameter</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#abd2615cfb6e34b4dccd6647b8181ed4c">Option</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a80d501ad109f7745fa44e7f52e6380d0">Flag</a>&gt;</td></tr>
<tr class="memdesc:af5a63481366bb7bf0406ff735e6b592f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows types: ( Parameter | Option | Flag )  <a href="namespaceopt.html#af5a63481366bb7bf0406ff735e6b592f">More...</a><br /></td></tr>
<tr class="separator:af5a63481366bb7bf0406ff735e6b592f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d706641e94a68458cc42af1f1374d15"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5d706641e94a68458cc42af1f1374d15"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a5d706641e94a68458cc42af1f1374d15">CanHaveValueArgument</a> = std::same_as&lt;T, <a class="el" href="namespaceopt.html#abd2615cfb6e34b4dccd6647b8181ed4c">Option</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a80d501ad109f7745fa44e7f52e6380d0">Flag</a>&gt;</td></tr>
<tr class="memdesc:a5d706641e94a68458cc42af1f1374d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows types: ( Option | Flag )  <a href="namespaceopt.html#a5d706641e94a68458cc42af1f1374d15">More...</a><br /></td></tr>
<tr class="separator:a5d706641e94a68458cc42af1f1374d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec060dbd6131b7d040118d88d50f6f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ec060dbd6131b7d040118d88d50f6f1"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a0ec060dbd6131b7d040118d88d50f6f1">ValidInputType</a> = std::same_as&lt;T, <a class="el" href="structopt_1_1_input_wrapper.html">InputWrapper</a>&gt; || std::same_as&lt;T, std::string&gt; || std::same_as&lt;T, char&gt; || std::convertible_to&lt;T, char&gt; || std::convertible_to&lt;T, std::string&gt;</td></tr>
<tr class="memdesc:a0ec060dbd6131b7d040118d88d50f6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that allows <a class="el" href="structopt_1_1_input_wrapper.html" title="Acts as a wrapper for char &amp; std::string input types, to allow variadic functions to receive either c...">InputWrapper</a>, char, std::string, or any types that are implicitly convertible to char or std::string.  <a href="namespaceopt.html#a0ec060dbd6131b7d040118d88d50f6f1">More...</a><br /></td></tr>
<tr class="separator:a0ec060dbd6131b7d040118d88d50f6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad24f650521129892e3c4c134660796"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:afe21f7e58c02453f73b0ea1343b5bba6"><td class="memItemLeft" >&#160;&#160;&#160;std::vector&lt; char &gt;&#160;&#160;&#160;<a class="el" href="namespaceopt.html#ae8c01003898064a3b55b55bf6674f58e">opt::delimiters</a> { '-' }</td></tr>
<tr class="memdesc:afe21f7e58c02453f73b0ea1343b5bba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines valid argument prefix delimiters. By default, only '-' characters are accepted, however on windows forward-slash characters may be desired as well.  <a href="structopt_1_1_0d1.html#afe21f7e58c02453f73b0ea1343b5bba6">More...</a><br /></td></tr>
<tr class="separator:afe21f7e58c02453f73b0ea1343b5bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad24f650521129892e3c4c134660796"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a1ad24f650521129892e3c4c134660796">Settings_ArgParser</a></td></tr>
<tr class="memdesc:a1ad24f650521129892e3c4c134660796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static (non-const) settings structure.  <a href="namespaceopt.html#a1ad24f650521129892e3c4c134660796">More...</a><br /></td></tr>
<tr class="separator:a1ad24f650521129892e3c4c134660796"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8048bb6c81102ec4e6d0e267f620f928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8048bb6c81102ec4e6d0e267f620f928">&#9670;&nbsp;</a></span>ArgContainerIteratorContainerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a8048bb6c81102ec4e6d0e267f620f928">opt::ArgContainerIteratorContainerType</a> = typedef std::vector&lt;<a class="el" href="namespaceopt.html#ac8ea4d4fea9f5e3c6d46ababc4463b6c">ArgContainerIteratorType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>drugs </p>

<p class="definition">Definition at line <a class="el" href="_arg_container_8hpp_source.html#l00016">16</a> of file <a class="el" href="_arg_container_8hpp_source.html">ArgContainer.hpp</a>.</p>

</div>
</div>
<a id="ac8ea4d4fea9f5e3c6d46ababc4463b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ea4d4fea9f5e3c6d46ababc4463b6c">&#9670;&nbsp;</a></span>ArgContainerIteratorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#ac8ea4d4fea9f5e3c6d46ababc4463b6c">opt::ArgContainerIteratorType</a> = typedef ArgContainerType::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>brain on </p>

<p class="definition">Definition at line <a class="el" href="_arg_container_8hpp_source.html#l00015">15</a> of file <a class="el" href="_arg_container_8hpp_source.html">ArgContainer.hpp</a>.</p>

</div>
</div>
<a id="adfe78d40b04433e531b74164cade6e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe78d40b04433e531b74164cade6e80">&#9670;&nbsp;</a></span>ArgContainerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#adfe78d40b04433e531b74164cade6e80">opt::ArgContainerType</a> = typedef std::vector&lt;<a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>your </p>

<p class="definition">Definition at line <a class="el" href="_arg_container_8hpp_source.html#l00014">14</a> of file <a class="el" href="_arg_container_8hpp_source.html">ArgContainer.hpp</a>.</p>

</div>
</div>
<a id="a80d501ad109f7745fa44e7f52e6380d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d501ad109f7745fa44e7f52e6380d0">&#9670;&nbsp;</a></span>Flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a80d501ad109f7745fa44e7f52e6380d0">opt::Flag</a> = typedef <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt;std::pair&lt;char, std::optional&lt;std::string&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00127">127</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="a26b17b9a781806db5683836e034cb85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b17b9a781806db5683836e034cb85b">&#9670;&nbsp;</a></span>FlagType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">opt::FlagType</a> = typedef std::pair&lt;char, std::optional&lt;std::string&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The variable type contained within a Flag instance. </p>

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00011">11</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="abd2615cfb6e34b4dccd6647b8181ed4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2615cfb6e34b4dccd6647b8181ed4c">&#9670;&nbsp;</a></span>Option</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#abd2615cfb6e34b4dccd6647b8181ed4c">opt::Option</a> = typedef <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt;std::pair&lt;std::string, std::optional&lt;std::string&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00126">126</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="a8e7cc9a2010617a6b4f9e9707419bcdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7cc9a2010617a6b4f9e9707419bcdd">&#9670;&nbsp;</a></span>OptionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">opt::OptionType</a> = typedef std::pair&lt;std::string, std::optional&lt;std::string&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The variable type contained within an Option instance. </p>

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00009">9</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="a316557ae32d1fffe2b704fc5c9638807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316557ae32d1fffe2b704fc5c9638807">&#9670;&nbsp;</a></span>Parameter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a316557ae32d1fffe2b704fc5c9638807">opt::Parameter</a> = typedef <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt;std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00128">128</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="aef25741f3063b9139b8440400ddf74da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef25741f3063b9139b8440400ddf74da">&#9670;&nbsp;</a></span>ParameterType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#aef25741f3063b9139b8440400ddf74da">opt::ParameterType</a> = typedef std::string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The variable type contained within a Parameter instance. </p>

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00007">7</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="ae49449e838a7675e67e0859a749f3bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49449e838a7675e67e0859a749f3bdb">&#9670;&nbsp;</a></span>StrVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#ae49449e838a7675e67e0859a749f3bdb">opt::StrVec</a> = typedef std::vector&lt;std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00010">10</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>

</div>
</div>
<a id="af96ecf1c473dc1d8a07674fd1858fe4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96ecf1c473dc1d8a07674fd1858fe4f">&#9670;&nbsp;</a></span>VariantArgumentType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">opt::VariantArgumentType</a> = typedef std::variant&lt;std::monostate, <a class="el" href="namespaceopt.html#a316557ae32d1fffe2b704fc5c9638807">Parameter</a>, <a class="el" href="namespaceopt.html#abd2615cfb6e34b4dccd6647b8181ed4c">Option</a>, <a class="el" href="namespaceopt.html#a80d501ad109f7745fa44e7f52e6380d0">Flag</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant type that allows std::monostate (null/all), Parameter, Option, &amp; Flag types, in that order. </p>

<p class="definition">Definition at line <a class="el" href="_variant_argument_type_8hpp_source.html#l00013">13</a> of file <a class="el" href="_variant_argument_type_8hpp_source.html">VariantArgumentType.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a14827521fec8e1c561ed24c2f151bc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14827521fec8e1c561ed24c2f151bc5f">&#9670;&nbsp;</a></span>can_capture_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::can_capture_next </td>
          <td>(</td>
          <td class="paramtype">StrVec::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>here</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrVec::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given iterator CAN capture the next argument by checking <br  />
 if the next argument is not prefixed with a '-' or is prefixed with '-' but is also a number. <br  />
 Does NOT check if the given iterator is present on the capturelist! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">here</td><td>The current iterator position. </td></tr>
    <tr><td class="paramname">end</td><td>The position of the end of the iterable range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00052">52</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a14827521fec8e1c561ed24c2f151bc5f_cgraph.svg" width="318" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a9cec335d3ad0b30de028267001ee9e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cec335d3ad0b30de028267001ee9e1f">&#9670;&nbsp;</a></span>count_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t opt::count_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of characters at the beginning of a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...DelimT</td><td>Variadic Template, accepts only char types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input string. </td></tr>
    <tr><td class="paramname">max_delims</td><td>Maximum number of delimiters to count before stopping, even if more delimiters exist. </td></tr>
    <tr><td class="paramname">...delims</td><td>At least one char type to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00067">67</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a9cec335d3ad0b30de028267001ee9e1f_cgraph.svg" width="292" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a9cec335d3ad0b30de028267001ee9e1f_icgraph.svg" width="416" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a8723d0634e92526f4ca97fc8a93221ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8723d0634e92526f4ca97fc8a93221ab">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ValidArg T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto opt::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_variant_argument_type_8hpp_source.html#l00157">157</a> of file <a class="el" href="_variant_argument_type_8hpp_source.html">VariantArgumentType.hpp</a>.</p>

</div>
</div>
<a id="a33135292342ae5562b5fe2321d0cbe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33135292342ae5562b5fe2321d0cbe18">&#9670;&nbsp;</a></span>get_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ValidArg Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="structopt_1_1_index.html">Index</a>&amp; opt::get_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_variant_argument_type_8hpp_source.html#l00040">40</a> of file <a class="el" href="_variant_argument_type_8hpp_source.html">VariantArgumentType.hpp</a>.</p>

</div>
</div>
<a id="ab3e447cf9b68ce004f7a44a49cae6404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e447cf9b68ce004f7a44a49cae6404">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const std::string opt::get_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_variant_argument_type_8hpp_source.html#l00063">63</a> of file <a class="el" href="_variant_argument_type_8hpp_source.html">VariantArgumentType.hpp</a>.</p>

</div>
</div>
<a id="a294152959e0541808274c2ff685f8eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294152959e0541808274c2ff685f8eb6">&#9670;&nbsp;</a></span>is_delimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool opt::is_delimiter </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given character is a valid delimiter, according to the static Settings_ArgParser object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Input Character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00022">22</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a294152959e0541808274c2ff685f8eb6_icgraph.svg" width="579" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa297a02e7d112f878e200ef839a78605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa297a02e7d112f878e200ef839a78605">&#9670;&nbsp;</a></span>is_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::is_number </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given string is a valid integer, floating-point, or hexadecimal number. Hexadecimal numbers must be prefixed with "0x" (or "-0x") to be detected properly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input String </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00032">32</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_aa297a02e7d112f878e200ef839a78605_icgraph.svg" width="318" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a81e37cea59bb7d8675fc517ef3d0e590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e37cea59bb7d8675fc517ef3d0e590">&#9670;&nbsp;</a></span>is_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ValidArg Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr const bool opt::is_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_variant_argument_type_8hpp_source.html#l00053">53</a> of file <a class="el" href="_variant_argument_type_8hpp_source.html">VariantArgumentType.hpp</a>.</p>

</div>
</div>
<a id="a05f6625ec874e68c060b1e04795dbb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f6625ec874e68c060b1e04795dbb18">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ValidArgType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; opt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopt_1_1_arg.html">Arg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream insertion operator for the <a class="el" href="classopt_1_1_arg.html" title="Polymorphic argument wrapper class that exposes helper functions.">Arg</a> class. See the Settings_Arg static struct for changing output format settings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- The type of argument contained within the given <a class="el" href="classopt_1_1_arg.html" title="Polymorphic argument wrapper class that exposes helper functions.">Arg</a> class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>- (implicit) Output Stream. </td></tr>
    <tr><td class="paramname">arg</td><td>- (implicit) Argument instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00100">100</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="a8e94744bdbabe51bbb6262321407d0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e94744bdbabe51bbb6262321407d0ed">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; opt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopt.html#af96ecf1c473dc1d8a07674fd1858fe4f">VariantArgumentType</a> &amp;&#160;</td>
          <td class="paramname"><em>varg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>VariantArgumentType output stream insertion operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>- (implicit) Output Stream Reference. </td></tr>
    <tr><td class="paramname">varg</td><td>- (implicit) VariantArgumentType instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="_variant_argument_type_8hpp_source.html#l00168">168</a> of file <a class="el" href="_variant_argument_type_8hpp_source.html">VariantArgumentType.hpp</a>.</p>

</div>
</div>
<a id="a2db34133c5d7b2d0bbcdddd6c4c6a016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db34133c5d7b2d0bbcdddd6c4c6a016">&#9670;&nbsp;</a></span>paramVecToStrVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_layer_8hpp.html#a7ff62ace4b261d15f42b604ae7d6614d">_CONSTEXPR</a> const std::vector&lt;std::string&gt; opt::paramVecToStrVec </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopt.html#a316557ae32d1fffe2b704fc5c9638807">opt::Parameter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>param_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_params_a_p_i2_8hpp_source.html#l00158">158</a> of file <a class="el" href="_params_a_p_i2_8hpp_source.html">ParamsAPI2.hpp</a>.</p>

</div>
</div>
<a id="abc103cb3c943291e5f87bccf7df19651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc103cb3c943291e5f87bccf7df19651">&#9670;&nbsp;</a></span>parse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ValidInputType... VT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto opt::parse </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VT &amp;...&#160;</td>
          <td class="paramname"><em>captures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse commandline arguments into an <a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> instance. This function accepts a variadic capture list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VT...</td><td>Variadic Templated Input Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Commandline arguments as a vector of strings, in order and including argv[0]. </td></tr>
    <tr><td class="paramname">...captures</td><td>The names of any arguments that are allowed to capture additional arguments. If the user attempts to force capture an argument by appending "=..." but the argument is not on this list, the invalid capture will be added separately as a parameter instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00212">212</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>

</div>
</div>
<a id="a3d4a82db2d7eef33350854b082131315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4a82db2d7eef33350854b082131315">&#9670;&nbsp;</a></span>parse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopt.html#adfe78d40b04433e531b74164cade6e80">ArgContainerType</a> opt::parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopt.html#ae49449e838a7675e67e0859a749f3bdb">StrVec</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopt_1_1_capture_list.html">CaptureList</a> &amp;&#160;</td>
          <td class="paramname"><em>captures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse commandline arguments into an <a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> instance. <br  />
 <b>Argument Types</b> <br  />
 - Parameters are any arguments that do not begin with a dash '-' character that were not captured by another argument type. <br  />
 - Options are arguments that begin with 2 dash '-' characters, and can capture additional arguments if the option name appears in the capture list. <br  />
 - Flags are arguments that begin with a single dash '-' character, are a single character in length, and can capture additional arguments. Flags can appear alone, or in "chains" where each character is treated as an individual flag. In a flag chain, only the last flag can capture additional arguments. <br  />
 <b>Capture Rules</b> <br  />
 - Only options/flags specified in the capture list are allowed to capture additional arguments. Capture list entries should not include a delimiter prefix. <br  />
 - Options/Flags cannot be captured under any circumstance. ex: "--opt --opt captured" results in "--opt", &amp; "--opt" + "captured". <br  />
 - If a flag in a chain should capture an argument (either with an '=' delimiter or by context), it must appear at the end of the chain. <br  />
 - Any captured arguments do not appear in the argument list by themselves, and must be accessed through the argument that captured them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Commandline arguments as a vector of strings, in order and including argv[0]. </td></tr>
    <tr><td class="paramname">captures</td><td>A <a class="el" href="structopt_1_1_capture_list.html" title="Contains a list of arguments that should be allowed to capture additional arguments....">CaptureList</a> instance specifying which arguments are allowed to capture other arguments as their parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structopt_1_1_arg_container.html" title="A container for storing and interacting with parsed commandline arguments.   The container itself is ...">ArgContainer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00138">138</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a3d4a82db2d7eef33350854b082131315_cgraph.svg" width="579" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa2f10f2c576dc410b4cacf831c949d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f10f2c576dc410b4cacf831c949d09">&#9670;&nbsp;</a></span>requires() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerT , IntegerT index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">opt::requires </td>
          <td>(</td>
          <td class="paramtype">index&#160;</td>
          <td class="paramname"> = <code>=&#160;static_cast&lt;IntegerT&gt;(0)</code></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a std::monostate type from a VariantArgumentType instance. </p>
<p>Retrieve a Flag type from a VariantArgumentType instance.</p>
<p>Retrieve an Option type from a VariantArgumentType instance.</p>
<p>Retrieve a Parameter type from a VariantArgumentType instance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegerT</td><td>- Integer type </td></tr>
    <tr><td class="paramname">index</td><td>- The index number of the type to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>- The argument to retrieve a type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::monostate</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegerT</td><td>- Integer type </td></tr>
    <tr><td class="paramname">index</td><td>- The index number of the type to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>- The argument to retrieve a type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parameter</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegerT</td><td>- Integer type </td></tr>
    <tr><td class="paramname">index</td><td>- The index number of the type to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>- The argument to retrieve a type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Option</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegerT</td><td>- Integer type </td></tr>
    <tr><td class="paramname">index</td><td>- The index number of the type to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>- The argument to retrieve a type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag </dd></dl>

<p class="definition">Definition at line <a class="el" href="_variant_argument_type_8hpp_source.html#l00114">114</a> of file <a class="el" href="_variant_argument_type_8hpp_source.html">VariantArgumentType.hpp</a>.</p>

</div>
</div>
<a id="a2159b287993f819a2fbadd4f5798d426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2159b287993f819a2fbadd4f5798d426">&#9670;&nbsp;</a></span>requires() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ValidArg... Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">opt::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...&#160;</td>
          <td class="paramname">Type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_variant_argument_type_8hpp_source.html#l00057">57</a> of file <a class="el" href="_variant_argument_type_8hpp_source.html">VariantArgumentType.hpp</a>.</p>

</div>
</div>
<a id="a7c659d3e86eb26fb94a5915b10cbb74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c659d3e86eb26fb94a5915b10cbb74d">&#9670;&nbsp;</a></span>strip_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, size_t&gt; opt::strip_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count &amp; remove prefix delimiters from a given string. Returns the stripped string &amp; the number of removed delimiters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input string. </td></tr>
    <tr><td class="paramname">max_delims</td><td>Maximum number of delimiter prefixes to strip before stopping, even if there are more delimiters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::string, size_t&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00084">84</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a7c659d3e86eb26fb94a5915b10cbb74d_cgraph.svg" width="451" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt_a7c659d3e86eb26fb94a5915b10cbb74d_icgraph.svg" width="250" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad4af6b73cdba4c9f27bf3fcd9b747e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4af6b73cdba4c9f27bf3fcd9b747e57">&#9670;&nbsp;</a></span>vectorize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static <a class="el" href="namespaceopt.html#ae49449e838a7675e67e0859a749f3bdb">StrVec</a> opt::vectorize </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>off</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a std::vector of std::strings from a char** array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Size of the array. </td></tr>
    <tr><td class="paramname">arr</td><td>Array. </td></tr>
    <tr><td class="paramname">off</td><td>The index to start at. Any elements that are skipped are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StrVec </dd></dl>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00220">220</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5d706641e94a68458cc42af1f1374d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d706641e94a68458cc42af1f1374d15">&#9670;&nbsp;</a></span>CanHaveValueArgument</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept opt::CanHaveValueArgument = std::same_as&lt;T, <a class="el" href="namespaceopt.html#abd2615cfb6e34b4dccd6647b8181ed4c">Option</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a80d501ad109f7745fa44e7f52e6380d0">Flag</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows types: ( Option | Flag ) </p>

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00137">137</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="a1533898171fa583a49f5b0ae1d5d8986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1533898171fa583a49f5b0ae1d5d8986">&#9670;&nbsp;</a></span>CanHaveValueArgumentType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept opt::CanHaveValueArgumentType = std::same_as&lt;T, <a class="el" href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">OptionType</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">FlagType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept constraint for Option/Flag pair subtypes. </p>

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00016">16</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="ae8c01003898064a3b55b55bf6674f58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c01003898064a3b55b55bf6674f58e">&#9670;&nbsp;</a></span>delimiters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;char&gt; opt::delimiters { '-' }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines valid argument prefix delimiters. By default, only '-' characters are accepted, however on windows forward-slash characters may be desired as well. </p>

<p class="definition">Definition at line <a class="el" href="_arg_parser_8hpp_source.html#l00014">14</a> of file <a class="el" href="_arg_parser_8hpp_source.html">ArgParser.hpp</a>.</p>

</div>
</div>
<a id="a4b432ae180b54ef2d396baba32f45d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b432ae180b54ef2d396baba32f45d36">&#9670;&nbsp;</a></span>divider</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned char&gt; opt::divider { ' ' }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows changing the divider between an argument's name and its optional capture argument. Recommended values are ' ' or '=', but any list of characters can be used. </p>

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00089">89</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="a4f3475adc55a9472fc5dd5cb5ed19dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3475adc55a9472fc5dd5cb5ed19dab">&#9670;&nbsp;</a></span>enclose_multiword_with_quotes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::enclose_multiword_with_quotes { true }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00087">87</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="af1925c987700a22c15487e69b49ea84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1925c987700a22c15487e69b49ea84d">&#9670;&nbsp;</a></span>include_captures</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::include_captures { true }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00086">86</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="aed4bb1fd09af1fecb79401708e096a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4bb1fd09af1fecb79401708e096a6f">&#9670;&nbsp;</a></span>quote_char</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char opt::quote_char { '\&quot;' }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00088">88</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="a90c25f48273450116b3e78ecd10faf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c25f48273450116b3e78ecd10faf6f">&#9670;&nbsp;</a></span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }  opt::Settings_Arg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows changing some formatting when using the Arg::operator&lt;&lt; / Arg::operator&gt;&gt; methods. </p>

</div>
</div>
<a id="a1ad24f650521129892e3c4c134660796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad24f650521129892e3c4c134660796">&#9670;&nbsp;</a></span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }  opt::Settings_ArgParser</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Static (non-const) settings structure. </p>

</div>
</div>
<a id="af5a63481366bb7bf0406ff735e6b592f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a63481366bb7bf0406ff735e6b592f">&#9670;&nbsp;</a></span>ValidArg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept opt::ValidArg = std::same_as&lt;T, <a class="el" href="namespaceopt.html#a316557ae32d1fffe2b704fc5c9638807">Parameter</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#abd2615cfb6e34b4dccd6647b8181ed4c">Option</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a80d501ad109f7745fa44e7f52e6380d0">Flag</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows types: ( Parameter | Option | Flag ) </p>

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00133">133</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="a5186e11563094f28ac3182224bfbc6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5186e11563094f28ac3182224bfbc6d0">&#9670;&nbsp;</a></span>ValidArgType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept opt::ValidArgType = std::same_as&lt;T, <a class="el" href="namespaceopt.html#aef25741f3063b9139b8440400ddf74da">ParameterType</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a8e7cc9a2010617a6b4f9e9707419bcdd">OptionType</a>&gt; || std::same_as&lt;T, <a class="el" href="namespaceopt.html#a26b17b9a781806db5683836e034cb85b">FlagType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept constraint for <a class="el" href="classopt_1_1_arg.html" title="Polymorphic argument wrapper class that exposes helper functions.">Arg</a> subtypes. Allows: ( ParameterType | OptionType | FlagType ) </p>

<p class="definition">Definition at line <a class="el" href="_arg_8hpp_source.html#l00014">14</a> of file <a class="el" href="_arg_8hpp_source.html">Arg.hpp</a>.</p>

</div>
</div>
<a id="a0ec060dbd6131b7d040118d88d50f6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec060dbd6131b7d040118d88d50f6f1">&#9670;&nbsp;</a></span>ValidInputType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept opt::ValidInputType = std::same_as&lt;T, <a class="el" href="structopt_1_1_input_wrapper.html">InputWrapper</a>&gt; || std::same_as&lt;T, std::string&gt; || std::same_as&lt;T, char&gt; || std::convertible_to&lt;T, char&gt; || std::convertible_to&lt;T, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept that allows <a class="el" href="structopt_1_1_input_wrapper.html" title="Acts as a wrapper for char &amp; std::string input types, to allow variadic functions to receive either c...">InputWrapper</a>, char, std::string, or any types that are implicitly convertible to char or std::string. </p>
<p>@concept ValidInputType </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_arg_container_8hpp_source.html#l00043">43</a> of file <a class="el" href="_arg_container_8hpp_source.html">ArgContainer.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceopt.html">opt</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
