<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>307Lib: opt3 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gear-2.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">307Lib
   </div>
   <div id="projectbrief">C++ Libraries made by radj307</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceopt3.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">opt3 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains a commandline argument parser &amp; container object.  
<a href="namespaceopt3.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1arg__conflict.html">arg_conflict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple container object for a single argument 'conflict'; a much simpler form of argument definition that includes a name &amp; optional <code>ConflictStyle</code>.  <a href="structopt3_1_1arg__conflict.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1arg__container.html">arg_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container type derived directly from std::vector that exposes utility methods for managing &amp; interacting with argument lists. <br  />
 This object contains the bulk of the code in the entire <a class="el" href="namespaceopt3.html" title="Contains a commandline argument parser &amp; container object.">opt3</a> library. <br  />
 Additionally, this object and all derived types may be declared <code>const</code> without any loss of functionality, since commandline arguments are only parsed once.  <a href="structopt3_1_1arg__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1arg__manager.html">arg_manager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1_argument_parsing_rules.html">ArgumentParsingRules</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows configuration of the rules used when parsing arguments.  <a href="structopt3_1_1_argument_parsing_rules.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1base__arg.html">base_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty struct that serves as the templateless base type for the <a class="el" href="structopt3_1_1basic__arg__t.html" title="Basic argument wrapper object that contains a templated variable type with some useful methods.">basic_arg_t</a> struct.  <a href="structopt3_1_1base__arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1basic__arg__t.html">basic_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic argument wrapper object that contains a templated variable type with some useful methods.  <a href="structopt3_1_1basic__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1basic__arg__template.html">basic_arg_template</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1basic__vstring.html">basic_vstring</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable-string object with constructor overloads that accept a single character, c-strings, &amp; strings. If the filesystem library is included (before this header), std::filesystem::path types are also allowed.  <a href="structopt3_1_1basic__vstring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1capture__list.html">capture_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small wrapper object that inherits from a std::vector. TODO: Implement this properly instead of inheriting from std::vector.  <a href="structopt3_1_1capture__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopt3_1_1variant__template.html">variant_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction wrapper around <code><a class="el" href="structopt3_1_1basic__arg__template.html">basic_arg_template</a></code> that accepts types <code>TemplateOption</code> &amp; <code>TemplateFlag</code>  <a href="classopt3_1_1variant__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container object for a <em>group</em> of argument templates that all perform a similar function. <br  />
 A template group may also <b>conflict</b> with members of another template group; this is handled differently depending on the winning <code>ConflictStyle</code>  <a href="structopt3_1_1variant__template__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt3_1_1variantarg.html">variantarg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction wrapper around std::variant that directly exposes methods from the underlying <a class="el" href="structopt3_1_1basic__arg__t.html" title="Basic argument wrapper object that contains a templated variable type with some useful methods.">basic_arg_t</a> struct. <br  />
 This allows the programmer to interact with std::variant argument types as if they weren't actually variants.  <a href="structopt3_1_1variantarg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab54137eb3e9fc519d99cae5f2cd3f1fc"><td class="memItemLeft" align="right" valign="top"><a id="ab54137eb3e9fc519d99cae5f2cd3f1fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArgManager</b> = <a class="el" href="structopt3_1_1arg__manager.html">arg_manager</a></td></tr>
<tr class="separator:ab54137eb3e9fc519d99cae5f2cd3f1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b420740d1a99b7542ae9ebb37c34e7"><td class="memItemLeft" align="right" valign="top"><a id="a77b420740d1a99b7542ae9ebb37c34e7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#a77b420740d1a99b7542ae9ebb37c34e7">Flag</a> = <a class="el" href="structopt3_1_1basic__arg__t.html">basic_arg_t</a>&lt; <a class="el" href="opt3_8hpp.html#a8d4383d6072cc2c62c901b0412300939">_internal::flag_t</a> &gt;</td></tr>
<tr class="memdesc:a77b420740d1a99b7542ae9ebb37c34e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag argument type; these are single-character arguments that can be chained together and can capture values when enabled. <br /></td></tr>
<tr class="separator:a77b420740d1a99b7542ae9ebb37c34e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84949361063f8e17bd768ef3bc0a502"><td class="memItemLeft" align="right" valign="top"><a id="ae84949361063f8e17bd768ef3bc0a502"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#ae84949361063f8e17bd768ef3bc0a502">Option</a> = <a class="el" href="structopt3_1_1basic__arg__t.html">basic_arg_t</a>&lt; <a class="el" href="opt3_8hpp.html#a311d34c6adc54432307c64109838e383">_internal::option_t</a> &gt;</td></tr>
<tr class="memdesc:ae84949361063f8e17bd768ef3bc0a502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option argument type; these are multi-character arguments that can capture values when enabled. <br /></td></tr>
<tr class="separator:ae84949361063f8e17bd768ef3bc0a502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d306b4c192f9b35513b2874c39c5f6"><td class="memItemLeft" align="right" valign="top"><a id="ae5d306b4c192f9b35513b2874c39c5f6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#ae5d306b4c192f9b35513b2874c39c5f6">Parameter</a> = <a class="el" href="structopt3_1_1basic__arg__t.html">basic_arg_t</a>&lt; <a class="el" href="opt3_8hpp.html#afe9454a8d26d64d526dc3bd470359e9f">_internal::parameter_t</a> &gt;</td></tr>
<tr class="memdesc:ae5d306b4c192f9b35513b2874c39c5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter argument type; these are any arguments without special meaning. <br /></td></tr>
<tr class="separator:ae5d306b4c192f9b35513b2874c39c5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4838c80518467c9c7ed16b681d283164"><td class="memItemLeft" align="right" valign="top"><a id="a4838c80518467c9c7ed16b681d283164"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#a4838c80518467c9c7ed16b681d283164">TemplateFlag</a> = <a class="el" href="structopt3_1_1basic__arg__template.html">basic_arg_template</a>&lt; <a class="el" href="opt3_8hpp.html#a8d4383d6072cc2c62c901b0412300939">_internal::flag_t</a> &gt;</td></tr>
<tr class="memdesc:a4838c80518467c9c7ed16b681d283164"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument template for <code>Flag</code>s. <br /></td></tr>
<tr class="separator:a4838c80518467c9c7ed16b681d283164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9ddb9994af06e1e2c7ea0e88f0abc2"><td class="memItemLeft" align="right" valign="top"><a id="a9c9ddb9994af06e1e2c7ea0e88f0abc2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#a9c9ddb9994af06e1e2c7ea0e88f0abc2">TemplateOption</a> = <a class="el" href="structopt3_1_1basic__arg__template.html">basic_arg_template</a>&lt; <a class="el" href="opt3_8hpp.html#a311d34c6adc54432307c64109838e383">_internal::option_t</a> &gt;</td></tr>
<tr class="memdesc:a9c9ddb9994af06e1e2c7ea0e88f0abc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument template for <code>Option</code>s. <br /></td></tr>
<tr class="separator:a9c9ddb9994af06e1e2c7ea0e88f0abc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6ee3497cef008123109807aee8ceb6"><td class="memItemLeft" align="right" valign="top"><a id="a2b6ee3497cef008123109807aee8ceb6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#a2b6ee3497cef008123109807aee8ceb6">uchar</a> = unsigned char</td></tr>
<tr class="memdesc:a2b6ee3497cef008123109807aee8ceb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned char type <br /></td></tr>
<tr class="separator:a2b6ee3497cef008123109807aee8ceb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702940d28c661e65df03e476bbf675f6"><td class="memItemLeft" align="right" valign="top"><a id="a702940d28c661e65df03e476bbf675f6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#a702940d28c661e65df03e476bbf675f6">vstring</a> = <a class="el" href="structopt3_1_1basic__vstring.html">basic_vstring</a>&lt; char, std::char_traits&lt; char &gt;, std::allocator&lt; char &gt; &gt;</td></tr>
<tr class="memdesc:a702940d28c661e65df03e476bbf675f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Narrow-char width string type. <br /></td></tr>
<tr class="separator:a702940d28c661e65df03e476bbf675f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aed884f239ca32c2fe3dc2b12c399f142"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142">ConflictStyle</a> : uchar { <a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142a6adf97f83acf6453d4a6a4b1070f3754">None</a> = 0
, <a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142a705153d878cb91983bfd5cf2930a18cc">CapturesConflict</a> = 1
, <a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142af1d4ac54357cc0932f385d56814ba7e4">Conflict</a> = 2
 }</td></tr>
<tr class="memdesc:aed884f239ca32c2fe3dc2b12c399f142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the circumstances in which two argument groups conflict with each other.  <a href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142">More...</a><br /></td></tr>
<tr class="separator:aed884f239ca32c2fe3dc2b12c399f142"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a32c1367e3fec6fae43cd4c38b5a60028"><td class="memItemLeft" align="right" valign="top"><a id="a32c1367e3fec6fae43cd4c38b5a60028"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$make_typed_bitfield</b> (CaptureStyle, <a class="el" href="namespaceopt3.html#a2b6ee3497cef008123109807aee8ceb6">uchar</a>, Disabled=0, EqualsOnly=1, Optional=2, Required=4,)</td></tr>
<tr class="separator:a32c1367e3fec6fae43cd4c38b5a60028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ed85fd3aa84a9ec6899bea27da600f"><td class="memTemplParams" colspan="2">template&lt;var::any_same&lt; _internal::parameter_t, _internal::flag_t, _internal::option_t &gt; TValue&gt; </td></tr>
<tr class="memitem:ae4ed85fd3aa84a9ec6899bea27da600f"><td class="memTemplItemLeft" align="right" valign="top">WINCONSTEXPR <a class="el" href="structopt3_1_1variantarg.html">variantarg</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#ae4ed85fd3aa84a9ec6899bea27da600f">make_argument</a> (<a class="el" href="namespaceopt3.html#a702940d28c661e65df03e476bbf675f6">vstring</a> &amp;&amp;name, std::optional&lt; std::string &gt; &amp;&amp;capture=std::nullopt) noexcept(false)</td></tr>
<tr class="memdesc:ae4ed85fd3aa84a9ec6899bea27da600f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a variantarg of the specified type, with the given values.  <a href="namespaceopt3.html#ae4ed85fd3aa84a9ec6899bea27da600f">More...</a><br /></td></tr>
<tr class="separator:ae4ed85fd3aa84a9ec6899bea27da600f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35e9f86022da18932b030f40186ce2c"><td class="memTemplParams" colspan="2">template&lt;var::any_same_or_convertible&lt; variant_template, vstring &gt;... Ts&gt; </td></tr>
<tr class="memitem:ab35e9f86022da18932b030f40186ce2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#ab35e9f86022da18932b030f40186ce2c">make_template</a> (const CaptureStyle captureStyle, const <a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142">ConflictStyle</a> conflictStyle, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab35e9f86022da18932b030f40186ce2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance.  <a href="namespaceopt3.html#ab35e9f86022da18932b030f40186ce2c">More...</a><br /></td></tr>
<tr class="separator:ab35e9f86022da18932b030f40186ce2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2ba4e76d558734fcc7769ba80b51e8"><td class="memTemplParams" colspan="2">template&lt;var::any_same_or_convertible&lt; variant_template, vstring &gt;... Ts&gt; </td></tr>
<tr class="memitem:abb2ba4e76d558734fcc7769ba80b51e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#abb2ba4e76d558734fcc7769ba80b51e8">make_template</a> (const CaptureStyle captureStyle, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:abb2ba4e76d558734fcc7769ba80b51e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance.  <a href="namespaceopt3.html#abb2ba4e76d558734fcc7769ba80b51e8">More...</a><br /></td></tr>
<tr class="separator:abb2ba4e76d558734fcc7769ba80b51e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd6ab9614bbb9790b25fc0f85bca7d9"><td class="memTemplParams" colspan="2">template&lt;var::any_same_or_convertible&lt; variant_template, vstring &gt;... Ts&gt; </td></tr>
<tr class="memitem:a0bd6ab9614bbb9790b25fc0f85bca7d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#a0bd6ab9614bbb9790b25fc0f85bca7d9">make_template</a> (const <a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142">ConflictStyle</a> conflictStyle, const CaptureStyle captureStyle, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0bd6ab9614bbb9790b25fc0f85bca7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance.  <a href="namespaceopt3.html#a0bd6ab9614bbb9790b25fc0f85bca7d9">More...</a><br /></td></tr>
<tr class="separator:a0bd6ab9614bbb9790b25fc0f85bca7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ba8a24b4bbe45f7ca29366131fb715"><td class="memTemplParams" colspan="2">template&lt;var::any_same_or_convertible&lt; variant_template, vstring &gt;... Ts&gt; </td></tr>
<tr class="memitem:a71ba8a24b4bbe45f7ca29366131fb715"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#a71ba8a24b4bbe45f7ca29366131fb715">make_template</a> (const <a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142">ConflictStyle</a> conflictStyle, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a71ba8a24b4bbe45f7ca29366131fb715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance.  <a href="namespaceopt3.html#a71ba8a24b4bbe45f7ca29366131fb715">More...</a><br /></td></tr>
<tr class="separator:a71ba8a24b4bbe45f7ca29366131fb715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05336ef2c447f5f39b5a9330f07c6e8"><td class="memTemplParams" colspan="2">template&lt;var::any_same_or_convertible&lt; variant_template, vstring &gt;... Ts&gt; </td></tr>
<tr class="memitem:ae05336ef2c447f5f39b5a9330f07c6e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#ae05336ef2c447f5f39b5a9330f07c6e8">make_template</a> (Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae05336ef2c447f5f39b5a9330f07c6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance.  <a href="namespaceopt3.html#ae05336ef2c447f5f39b5a9330f07c6e8">More...</a><br /></td></tr>
<tr class="separator:ae05336ef2c447f5f39b5a9330f07c6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea34d330eb286847ca1a40b911c2afa"><td class="memItemLeft" align="right" valign="top">WINCONSTEXPR <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#adea34d330eb286847ca1a40b911c2afa">make_template</a> (<a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a> const &amp;g)</td></tr>
<tr class="memdesc:adea34d330eb286847ca1a40b911c2afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance.  <a href="namespaceopt3.html#adea34d330eb286847ca1a40b911c2afa">More...</a><br /></td></tr>
<tr class="separator:adea34d330eb286847ca1a40b911c2afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf933cbf05d9763e90322c14dbe8b52c"><td class="memItemLeft" align="right" valign="top"><a id="aaf933cbf05d9763e90322c14dbe8b52c"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classopt3_1_1variant__template.html">variant_template</a> &amp;vt)</td></tr>
<tr class="separator:aaf933cbf05d9763e90322c14dbe8b52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89455c11b14cc4363e1ffa33ae726be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopt3_1_1arg__container.html">arg_container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#a89455c11b14cc4363e1ffa33ae726be3">parse</a> (std::vector&lt; std::string &gt; &amp;&amp;args, <a class="el" href="structopt3_1_1capture__list.html">capture_list</a> captures, const <a class="el" href="structopt3_1_1_argument_parsing_rules.html">ArgumentParsingRules</a> &amp;parsingRules)</td></tr>
<tr class="memdesc:a89455c11b14cc4363e1ffa33ae726be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse commandline arguments into an ArgContainer instance.  <a href="namespaceopt3.html#a89455c11b14cc4363e1ffa33ae726be3">More...</a><br /></td></tr>
<tr class="separator:a89455c11b14cc4363e1ffa33ae726be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d90b644061f6d6ed53990770a7514fd"><td class="memTemplParams" colspan="2"><a id="a8d90b644061f6d6ed53990770a7514fd"></a>
template&lt;var::valid_char TChar, std::derived_from&lt; std::char_traits&lt; TChar &gt;&gt; TCharTraits = std::char_traits&lt;TChar&gt;, std::derived_from&lt; std::allocator&lt; TChar &gt;&gt; TAlloc = std::allocator&lt;TChar&gt;&gt; </td></tr>
<tr class="memitem:a8d90b644061f6d6ed53990770a7514fd"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; TChar, TCharTraits, TAlloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trim</b> (std::basic_string&lt; TChar, TCharTraits, TAlloc &gt; str, std::vector&lt; TChar &gt; const &amp;chars={ $<a class="el" href="sysarch_8h.html#ab80f02f8ff37d1be951f69a8f5b3c7a1">c</a>(TChar, ' '), $<a class="el" href="sysarch_8h.html#ab80f02f8ff37d1be951f69a8f5b3c7a1">c</a>(TChar, '\t'), $<a class="el" href="sysarch_8h.html#ab80f02f8ff37d1be951f69a8f5b3c7a1">c</a>(TChar, '\v'), $<a class="el" href="sysarch_8h.html#ab80f02f8ff37d1be951f69a8f5b3c7a1">c</a>(TChar, '\r'), $<a class="el" href="sysarch_8h.html#ab80f02f8ff37d1be951f69a8f5b3c7a1">c</a>(TChar, '\n') })</td></tr>
<tr class="separator:a8d90b644061f6d6ed53990770a7514fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf194ac0720918d082fa618da2235fce"><td class="memTemplParams" colspan="2"><a id="acf194ac0720918d082fa618da2235fce"></a>
template&lt;var::valid_char TChar, std::derived_from&lt; std::char_traits&lt; TChar &gt;&gt; TCharTraits = std::char_traits&lt;TChar&gt;, std::derived_from&lt; std::allocator&lt; TChar &gt;&gt; TAlloc = std::allocator&lt;TChar&gt;&gt; </td></tr>
<tr class="memitem:acf194ac0720918d082fa618da2235fce"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; TChar, TCharTraits, TAlloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trim_preceding</b> (std::basic_string&lt; TChar, TCharTraits, TAlloc &gt; str, std::vector&lt; TChar &gt; const &amp;chars)</td></tr>
<tr class="separator:acf194ac0720918d082fa618da2235fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f683d1e353835b0e44d1ba068f1aef4"><td class="memTemplParams" colspan="2"><a id="a0f683d1e353835b0e44d1ba068f1aef4"></a>
template&lt;var::valid_char TChar, std::derived_from&lt; std::char_traits&lt; TChar &gt;&gt; TCharTraits = std::char_traits&lt;TChar&gt;, std::derived_from&lt; std::allocator&lt; TChar &gt;&gt; TAlloc = std::allocator&lt;TChar&gt;&gt; </td></tr>
<tr class="memitem:a0f683d1e353835b0e44d1ba068f1aef4"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; TChar, TCharTraits, TAlloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trim_trailing</b> (std::basic_string&lt; TChar, TCharTraits, TAlloc &gt; str, std::vector&lt; TChar &gt; const &amp;chars)</td></tr>
<tr class="separator:a0f683d1e353835b0e44d1ba068f1aef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a01dc4d609f8216b8a937a5041b955"><td class="memItemLeft" align="right" valign="top">static WINCONSTEXPR std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#a21a01dc4d609f8216b8a937a5041b955">vectorize</a> (const int &amp;sz, char **arr, const int &amp;off=0)</td></tr>
<tr class="memdesc:a21a01dc4d609f8216b8a937a5041b955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a std::vector of std::strings from a char** array.  <a href="namespaceopt3.html#a21a01dc4d609f8216b8a937a5041b955">More...</a><br /></td></tr>
<tr class="separator:a21a01dc4d609f8216b8a937a5041b955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a615588f305359aeec65e45dbb4adafd3"><td class="memTemplParams" colspan="2"><a id="a615588f305359aeec65e45dbb4adafd3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a615588f305359aeec65e45dbb4adafd3"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#a615588f305359aeec65e45dbb4adafd3">valid_arg</a> = std::derived_from&lt;T, <a class="el" href="structopt3_1_1base__arg.html">base_arg</a>&gt;</td></tr>
<tr class="memdesc:a615588f305359aeec65e45dbb4adafd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint that allows any types derived from <a class="el" href="structopt3_1_1base__arg.html" title="An empty struct that serves as the templateless base type for the basic_arg_t struct.">base_arg</a>. <br /></td></tr>
<tr class="separator:a615588f305359aeec65e45dbb4adafd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe82f5494692ab94494ec5ad482d5139"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe82f5494692ab94494ec5ad482d5139"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt3.html#afe82f5494692ab94494ec5ad482d5139">valid_capture</a> = var::any_same_or_convertible&lt;T, <a class="el" href="classopt3_1_1variant__template.html">variant_template</a>, <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a>, <a class="el" href="namespaceopt3.html#a702940d28c661e65df03e476bbf675f6">vstring</a>&gt;</td></tr>
<tr class="memdesc:afe82f5494692ab94494ec5ad482d5139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint that only allows types that constitute a valid argument capture definition, such as <code><a class="el" href="classopt3_1_1variant__template.html" title="An abstraction wrapper around basic_arg_template that accepts types TemplateOption &amp; TemplateFlag">variant_template</a></code>, <code><a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a></code>, or <code>vstring</code>.  <a href="namespaceopt3.html#afe82f5494692ab94494ec5ad482d5139">More...</a><br /></td></tr>
<tr class="separator:afe82f5494692ab94494ec5ad482d5139"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains a commandline argument parser &amp; container object. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aed884f239ca32c2fe3dc2b12c399f142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed884f239ca32c2fe3dc2b12c399f142">&#9670;&nbsp;</a></span>ConflictStyle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142">opt3::ConflictStyle</a> : <a class="el" href="namespaceopt3.html#a2b6ee3497cef008123109807aee8ceb6">uchar</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the circumstances in which two argument groups conflict with each other. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aed884f239ca32c2fe3dc2b12c399f142a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Arguments do not conflict. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed884f239ca32c2fe3dc2b12c399f142a705153d878cb91983bfd5cf2930a18cc"></a>CapturesConflict&#160;</td><td class="fielddoc"><p>Both arguments can be present at the same time, but <b>only one</b> is allowed to capture, otherwise a conflict exception is thrown. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed884f239ca32c2fe3dc2b12c399f142af1d4ac54357cc0932f385d56814ba7e4"></a>Conflict&#160;</td><td class="fielddoc"><p>Only one of the arguments can be present at the same time. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l01214">1214</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae4ed85fd3aa84a9ec6899bea27da600f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ed85fd3aa84a9ec6899bea27da600f">&#9670;&nbsp;</a></span>make_argument()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::any_same&lt; _internal::parameter_t, _internal::flag_t, _internal::option_t &gt; TValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR <a class="el" href="structopt3_1_1variantarg.html">variantarg</a> opt3::make_argument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopt3.html#a702940d28c661e65df03e476bbf675f6">vstring</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::string &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>capture</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiates a variantarg of the specified type, with the given values. </p>
<p>Instantiates a variantarg of the specified type, with the given values. <br  />
 This overload accepts actual argument types instead of their underlying types, and translates them to the appropriate underlying type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TValue</td><td>The type of the underlying value. This is passed to the templated <a class="el" href="structopt3_1_1basic__arg__t.html" title="Basic argument wrapper object that contains a templated variable type with some useful methods.">basic_arg_t</a> struct. </td></tr>
    <tr><td class="paramname">T</td><td>Any type that is the same as, or is implicitly convertible to, std::string or char </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the argument. </td></tr>
    <tr><td class="paramname">capture</td><td>An optional capture value for this argument. <br  />
 Note that when TReturn is _internal::parameter_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A variantarg containing an argument of the specified type.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TArgument</td><td>The type of argument to instantiate. </td></tr>
    <tr><td class="paramname">T</td><td>Any type that is the same as, or is implicitly convertible to, std::string or char </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the argument. </td></tr>
    <tr><td class="paramname">capture</td><td>An optional capture value for this argument. <br  />
 Note that when TReturn is _internal::parameter_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A variantarg containing an argument of the specified type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l00333">333</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>

</div>
</div>
<a id="ab35e9f86022da18932b030f40186ce2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35e9f86022da18932b030f40186ce2c">&#9670;&nbsp;</a></span>make_template() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::any_same_or_convertible&lt; variant_template, vstring &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a> opt3::make_template </td>
          <td>(</td>
          <td class="paramtype">const CaptureStyle&#160;</td>
          <td class="paramname"><em>captureStyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142">ConflictStyle</a>&#160;</td>
          <td class="paramname"><em>conflictStyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">captureStyle</td><td>Determines how arguments from this template group can capture input. </td></tr>
    <tr><td class="paramname">conflictStyle</td><td>Determines how multiple arguments with the same ID are handled. </td></tr>
    <tr><td class="paramname">templates</td><td>Any number of <code><a class="el" href="classopt3_1_1variant__template.html" title="An abstraction wrapper around basic_arg_template that accepts types TemplateOption &amp; TemplateFlag">variant_template</a></code>s to include in the group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance with the specified parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l01580">1580</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>

</div>
</div>
<a id="abb2ba4e76d558734fcc7769ba80b51e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2ba4e76d558734fcc7769ba80b51e8">&#9670;&nbsp;</a></span>make_template() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::any_same_or_convertible&lt; variant_template, vstring &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a> opt3::make_template </td>
          <td>(</td>
          <td class="paramtype">const CaptureStyle&#160;</td>
          <td class="paramname"><em>captureStyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">captureStyle</td><td>Determines how arguments from this template group can capture input. </td></tr>
    <tr><td class="paramname">templates</td><td>Any number of <code><a class="el" href="classopt3_1_1variant__template.html" title="An abstraction wrapper around basic_arg_template that accepts types TemplateOption &amp; TemplateFlag">variant_template</a></code>s to include in the group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance with the specified parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l01611">1611</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>

</div>
</div>
<a id="a0bd6ab9614bbb9790b25fc0f85bca7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd6ab9614bbb9790b25fc0f85bca7d9">&#9670;&nbsp;</a></span>make_template() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::any_same_or_convertible&lt; variant_template, vstring &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a> opt3::make_template </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142">ConflictStyle</a>&#160;</td>
          <td class="paramname"><em>conflictStyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CaptureStyle&#160;</td>
          <td class="paramname"><em>captureStyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conflictStyle</td><td>Determines how multiple arguments with the same ID are handled. </td></tr>
    <tr><td class="paramname">captureStyle</td><td>Determines how arguments from this template group can capture input. </td></tr>
    <tr><td class="paramname">templates</td><td>Any number of <code><a class="el" href="classopt3_1_1variant__template.html" title="An abstraction wrapper around basic_arg_template that accepts types TemplateOption &amp; TemplateFlag">variant_template</a></code>s to include in the group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance with the specified parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l01596">1596</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>

</div>
</div>
<a id="a71ba8a24b4bbe45f7ca29366131fb715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ba8a24b4bbe45f7ca29366131fb715">&#9670;&nbsp;</a></span>make_template() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::any_same_or_convertible&lt; variant_template, vstring &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a> opt3::make_template </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopt3.html#aed884f239ca32c2fe3dc2b12c399f142">ConflictStyle</a>&#160;</td>
          <td class="paramname"><em>conflictStyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conflictStyle</td><td>Determines how multiple arguments with the same ID are handled. </td></tr>
    <tr><td class="paramname">templates</td><td>Any number of <code><a class="el" href="classopt3_1_1variant__template.html" title="An abstraction wrapper around basic_arg_template that accepts types TemplateOption &amp; TemplateFlag">variant_template</a></code>s to include in the group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance with the specified parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l01625">1625</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>

</div>
</div>
<a id="ae05336ef2c447f5f39b5a9330f07c6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05336ef2c447f5f39b5a9330f07c6e8">&#9670;&nbsp;</a></span>make_template() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;var::any_same_or_convertible&lt; variant_template, vstring &gt;... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a> opt3::make_template </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">templates</td><td>Any number of <code><a class="el" href="classopt3_1_1variant__template.html" title="An abstraction wrapper around basic_arg_template that accepts types TemplateOption &amp; TemplateFlag">variant_template</a></code>s to include in the group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance with the specified parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l01638">1638</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>

</div>
</div>
<a id="adea34d330eb286847ca1a40b911c2afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea34d330eb286847ca1a40b911c2afa">&#9670;&nbsp;</a></span>make_template() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WINCONSTEXPR <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a> opt3::make_template </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a> const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A pre-constructed <a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>g </dd></dl>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l01649">1649</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>

</div>
</div>
<a id="a89455c11b14cc4363e1ffa33ae726be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89455c11b14cc4363e1ffa33ae726be3">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopt3_1_1arg__container.html">arg_container</a> opt3::parse </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopt3_1_1capture__list.html">capture_list</a>&#160;</td>
          <td class="paramname"><em>captures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopt3_1_1_argument_parsing_rules.html">ArgumentParsingRules</a> &amp;&#160;</td>
          <td class="paramname"><em>parsingRules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse commandline arguments into an ArgContainer instance. </p>
<p>### Argument Types</p><ul>
<li>Parameters are any arguments that do not begin with a dash '-' character that were not captured by another argument type.</li>
<li>Options are arguments that begin with 2 dash '-' characters, and can capture additional arguments if the option name appears in the capture list.</li>
<li>Flags are arguments that begin with a single dash '-' character, are a single character in length, and can capture additional arguments. Flags can appear alone, or in "chains" where each character is treated as an individual flag. In a flag chain, only the last flag can capture additional arguments. </li>
</ul>
<h3><a class="anchor" id="autotoc_md16"></a>
Capture Rules</h3>
<ul>
<li>Only options/flags specified in the capture list are allowed to capture additional arguments. Capture list entries should not include a delimiter prefix.</li>
<li>Options/Flags cannot be captured under any circumstance. ex: "--opt --opt captured" results in "--opt", &amp; "--opt" + "captured".</li>
<li>If a flag in a chain should capture an argument (either with an '=' delimiter or by context), it must appear at the end of the chain.</li>
<li>Any captured arguments do not appear in the argument list by themselves, and must be accessed through the argument that captured them. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Commandline arguments as a vector of strings, in order and including argv[0]. </td></tr>
    <tr><td class="paramname">captures</td><td>A <code><a class="el" href="structopt3_1_1capture__list.html" title="A small wrapper object that inherits from a std::vector. TODO: Implement this properly instead of inh...">capture_list</a></code> instance specifying which arguments are allowed to capture other arguments as their parameters </td></tr>
    <tr><td class="paramname">parsingRules</td><td>An <code><a class="el" href="structopt3_1_1_argument_parsing_rules.html" title="Allows configuration of the rules used when parsing arguments.">ArgumentParsingRules</a></code> instance that provides the parser with a configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ArgContainer </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l01902">1902</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceopt3_a89455c11b14cc4363e1ffa33ae726be3_cgraph.svg" width="571" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a21a01dc4d609f8216b8a937a5041b955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a01dc4d609f8216b8a937a5041b955">&#9670;&nbsp;</a></span>vectorize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static WINCONSTEXPR std::vector&lt;std::string&gt; opt3::vectorize </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>off</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a std::vector of std::strings from a char** array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Size of the array. </td></tr>
    <tr><td class="paramname">arr</td><td>Array. </td></tr>
    <tr><td class="paramname">off</td><td>The index to start at. Any elements that are skipped are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l02048">2048</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afe82f5494692ab94494ec5ad482d5139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe82f5494692ab94494ec5ad482d5139">&#9670;&nbsp;</a></span>valid_capture</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept opt3::valid_capture = var::any_same_or_convertible&lt;T, <a class="el" href="classopt3_1_1variant__template.html">variant_template</a>, <a class="el" href="structopt3_1_1variant__template__group.html">variant_template_group</a>, <a class="el" href="namespaceopt3.html#a702940d28c661e65df03e476bbf675f6">vstring</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constraint that only allows types that constitute a valid argument capture definition, such as <code><a class="el" href="classopt3_1_1variant__template.html" title="An abstraction wrapper around basic_arg_template that accepts types TemplateOption &amp; TemplateFlag">variant_template</a></code>, <code><a class="el" href="structopt3_1_1variant__template__group.html" title="Container object for a group of argument templates that all perform a similar function....">variant_template_group</a></code>, or <code>vstring</code>. </p>
<p>@concept valid_capture </p>

<p class="definition">Definition at line <a class="el" href="opt3_8hpp_source.html#l01655">1655</a> of file <a class="el" href="opt3_8hpp_source.html">opt3.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceopt3.html">opt3</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
