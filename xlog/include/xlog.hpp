/**
 * @file	xLog.hpp
 * @author	radj307
 * @brief	Contains the xlog _(eXtensible LOG)_ namespace, a framework for implementing console logs into C++ programs.
 *\n		This header is dependent on additional libraries: 307lib::strlib
 */
#pragma once
#include "prefix.h"
#include "level.hpp"
#include "redirect.hpp"

#include <sysarch.h>
#include <str.hpp>
#include <var.hpp>

#include <iostream>
#include <string>
#include <optional>
#include <algorithm>


#pragma region UndefineMicrosoftBullshitMacros
#ifdef ERROR
#undef ERROR
#endif
#pragma endregion UndefineMicrosoftBullshitMacros

 /**
  * @def	XLOG_INCLUDE_SELF
  * @brief	When defined before including <xlog.hpp>, DEBUG level logs will include
  */
#ifndef XLOG_INCLUDE_SELF
#define XLOG_INCLUDE_SELF
#undef XLOG_INCLUDE_SELF
#else
#define XLOG_LEVEL_SELF
#endif

  /**
   * @namespace	xlog
   * @brief		Contains all user-facing xlog functions & objects.
   */
namespace xlog {
	/**
	 * @brief		Uses the bitwise OR operation to merge the given level with all levels below it.
	 * @param lvl	Input Log Level. Must be equal to 1, or a multiple of 2 to be valid.
	 * @returns		level::LogLevel
	 */
	inline level::LogLevel include_all_below(level::LogLevel lvl)
	{
		if (lvl != 1 && lvl % 2 != 0)
			return lvl;
		unsigned char out_lvl{ lvl };
		for (unsigned char i{ out_lvl }; i > 0; i /= 2)
			out_lvl |= i;
		return{ out_lvl };
	}

	/**
	 * @struct				OutputTarget
	 * @brief				Represents a method of outputting the logs generated by the program.
	 * @tparam StreamType	The type of stream used during output operations.
	 */
	template<class StreamType>
	struct OutputTarget {
		StreamType* target{ nullptr };
		OutputTarget(StreamType& output_target) : target{ &output_target } {}

		friend std::istream& operator>>(std::istream& is, const OutputTarget& o) { return is >> (*o.output).rdbuf(); }
		friend std::ostream& operator<<(std::ostream& os, const OutputTarget& o) { return os << (*o.output).rdbuf(); }

		void write(const std::string& str) const
		{
			(*target) << str;
			if (!str.empty() && str.back() != '\n')
				(*target) << '\n';
		}
	};

	/**
	 * @class				xLog
	 * @brief				Logging object.
	 * @tparam StreamType	The type of stream to use as the output target.
	 */
	template<class StreamType = std::ostream>
	class xLog {
	protected:
		OutputTarget<StreamType> _target;
		std::unique_ptr<level::LogLevel> _level;
		bool _add_prefix, _log_self{ false }, _allow_color{ false };

		/**
		 * @brief			Format a given message using the current settings.
		 * @param level		The log level associated with this message.
		 * @param message	The message string.
		 * @returns			std::string
		 */
		std::string format(const level::LogLevel& level, const std::string& message) const
		{
			if (!_add_prefix)
				return message;
			const char* message_type{ nullptr };
			switch (level) {
			case level::CRITICAL:
				message_type = _allow_color ? "\033[38;5;9m\033[1m[CRIT]\033[38;5;7m" : "[CRIT]";
				break;
			case level::ERROR:
				message_type = _allow_color ? "\033[38;5;9m[ERROR]\033[38;5;7m" : "[ERROR]";
				break;
			case level::WARNING:
				message_type = _allow_color ? "\033[38;5;11m[WARN]\033[38;5;7m" : "[WARN]";
				break;
			case level::LOG:
				message_type = _allow_color ? "\033[38;5;4m[LOG]\033[38;5;7m" : "[LOG]";
				break;
			case level::INFO:
				message_type = _allow_color ? "\033[38;5;12m[INFO]\033[38;5;7m" : "[INFO]";
				break;
			case level::MESSAGE:
				message_type = _allow_color ? "\033[38;5;10m[MSG]\033[38;5;7m" : "[MSG]";
				break;
			case level::DEBUG:
				message_type = _allow_color ? "\033[38;5;13m[DEBUG]\033[38;5;7m" : "[DEBUG]";
				break;
			default:
				break;
			}
			if (message_type != nullptr) {
				if constexpr (std::derived_from<StreamType, std::ofstream>)
					return { [](const std::string_view& message_prefix) -> std::string {
						const auto open{ message_prefix.find('[', 3ull) }, close{ message_prefix.find(']') };
						if (const auto& sz{message_prefix.size()};  open < sz && close < sz)
							return { message_prefix.substr(open, close - open + 1ull).data() };
						return{};
					}(message_type)+message };
				else
					return { message_type + message };
			}
			return { "\t"s + message };
		}

		/**
		 * @brief			Check if the current log level allows a given level.
		 * @param level		Check if the current log level contains this level.
		 * @returns bool
		 */
		bool currentLevelContains(const level::LogLevel& level) const
		{
			if (_level.get() != nullptr)
				return (*_level.get()).contains(level);
			return false;
		}

		/**
		 * @brief				Internal-use-only function that checks if self-logging is enabled, and if so, writes the given message with the DEBUG level.
		 * @param ...message	The message to write to the log.
		 * @returns				bool
		 */
		template<var::Streamable... VT>
		bool self_log(const VT&... message) const
		{
			return _log_self && currentLevelContains(level::DEBUG) && log(level::DEBUG, message...);
		}

	public:
		/**
		 * @brief				Default Constructor
		 * @param log_level		Default Log Level.
		 * @param add_prefix	When true, log level prefixes are enabled. (Ex: "[LOG]")
		 */
		xLog(const level::LogLevel& log_level = level::Default, const bool& add_prefix = true) : _target{ std::clog }, _level{ std::make_unique<level::LogLevel>(log_level) }, _add_prefix{ add_prefix } {}
		xLog(const OutputTarget<StreamType>& out, const level::LogLevel& log_level = level::Default, const bool& add_prefix = true) : _target{ out }, _level{ std::make_unique<level::LogLevel>(log_level) }, _add_prefix{ add_prefix } {}

		friend std::istream& operator>>(std::istream& is, const xLog<StreamType>& x) { return is >> x._target; }
		friend std::ostream& operator<<(std::ostream& os, const xLog<StreamType>& x) { return os << x._target; }

		/**
		 * @brief			Enable or disable the usage of colors in output.
		 * @param enable	When true, colors are enabled.
		 * @returns			bool
		 */
		bool setColorEnabled(const bool& enable)
		{
			const auto copy{ _allow_color };
			_allow_color = enable;
			return copy;
		}

		/**
		 * @brief			Set whether messages should automatically be given a colorized prefix such as "[ERROR]".
		 * @param enable	When true, messages include a colorized prefix.
		 * @returns bool	The previous prefix state.
		 */
		bool setPrefixEnabled(const bool& enable)
		{
			const auto copy{ _add_prefix };
			_add_prefix = enable;
			return copy;
		}

		/**
		 * @brief				Set the current whitelist level.
		 * @param level			This level will overwrite the previous one.
		 * @returns LogLevel	The previous whitelist level.
		 */
		level::LogLevel setLevel(const level::LogLevel& level)
		{
			const auto copy{ *_level.release() };
			_level = std::make_unique<level::LogLevel>(level);

			return copy;
		}

		/// @brief	Retrieve the current level whitelist setting.
		[[nodiscard]] level::LogLevel getLevel() const { return *_level.get(); }

		/**
		 * @brief				Create a message and send it to the current output target.
		 * @tparam ...Message	Any number of types that can be inserted into a stream with operator<<.
		 * @param level			This message's level.
		 * @param ...msg		The contents of this message.
		 * @returns				bool
		 */
		template<typename... Message>
		inline bool write(const level::LogLevel& level, const Message&... msg) const
		{
			const auto allowed{ currentLevelContains(level) };
			if (allowed)
				_target.write(format(level, str::stringify(msg...)));
			else
				self_log("Refused a message because the current log level does not allow messages of that type.");
			return allowed;
		}

		template<typename... Message> inline bool debug(Message&&... msg) const { return write(level::DEBUG, std::forward<Message>(msg)...); }
		template<typename... Message> inline bool info(Message&&... msg) const { return write(level::INFO, std::forward<Message>(msg)...); }
		template<typename... Message> inline bool log(Message&&... msg) const { return write(level::LOG, std::forward<Message>(msg)...); }
		template<typename... Message> inline bool msg(Message&&... msg) const { return write(level::MESSAGE, std::forward<Message>(msg)...); }
		template<typename... Message> inline bool warn(Message&&... msg) const { return write(level::WARNING, std::forward<Message>(msg)...); }
		template<typename... Message> inline bool error(Message&&... msg) const { return write(level::ERROR, std::forward<Message>(msg)...); }
		template<typename... Message> inline bool crit(Message&&... msg) const { return write(level::CRITICAL, std::forward<Message>(msg)...); }
	};

	using msg_break_t = nullptr_t;
	constexpr const msg_break_t endm = nullptr;

	/**
	 * @class				xLogs
	 * @brief				Extends the xLog object with operator<< stream capabilities.
	 * @tparam StreamType	The type of stream to use as the output target.
	 */
	template<class StreamType = std::ostream>
	class xLogs : public xLog<StreamType> {
		std::unique_ptr<level::LogLevel> _last{ nullptr };
		std::stringstream _buffer;

	public:
		/**
		 * @brief				Constructor
		 * @param out			The output target for logs.
		 * @param log_level		The log level whitelist.
		 * @param add_prefix	When true, log messages are prefixed with their level.
		 */
		xLogs(const OutputTarget<StreamType>& out, const level::LogLevel& log_level = level::Default, const bool& add_prefix = true) : xLog<StreamType>(out, log_level, add_prefix) {}
		xLogs(const level::LogLevel& log_level = level::Default, const bool& add_prefix = true) : xLog<StreamType>(log_level, add_prefix) {}
		
		std::streambuf* rdbuf() const { return _buffer.rdbuf(); }
		std::streambuf* rdbuf(std::streambuf* rdbuf) { return _buffer.rdbuf(rdbuf); }

		/**
		 * @brief		Stream insertion operator for the xLogs class.
		 *\n			Allows using xLogs in the same way as a std::ostream, with some important changes:
		 *\n			- A message level must be specified before messages can be inserted, unless prefixes are disabled.
		 *\n			- Messages are terminated with `endm` / nullptr.
		 *\n			- Messages are only sent to the output target once endm has been received.
		 * @tparam T	Input Type
		 * @param oxl	(implicit) xLogs instance.
		 * @param m		(implicit) Message type.
		 */
		template<var::Streamable T>
		friend xLogs<StreamType>& operator<<(xLogs<StreamType>& oxl, const T& m)
		{
			if constexpr (std::same_as<T, level::LogLevel>)
				oxl._last = std::make_unique<level::LogLevel>(m);
			else if constexpr (std::same_as<T, msg_break_t>) {
				if (!oxl._add_prefix || oxl._last.get() == nullptr)
					oxl.write(level::NONE, oxl._buffer.str());
				else
					oxl.write(*oxl._last.get(), oxl._buffer.str());
				oxl._buffer = {};
			}
			else if (!oxl._add_prefix || oxl._last.get() != nullptr)
				oxl._buffer << m;
			return oxl;
		}
		/**
		 * @brief		Allows inserting an entire output stream into the xLogs instance.
		 * @param oxl	(implicit) xLogs instance.
		 * @param os	(implicit) Output Stream.
		 */
		friend xLogs<StreamType>& operator<<(xLogs<StreamType>& oxl, std::ostream& os)
		{
			oxl << os.rdbuf();
		}
	};
}